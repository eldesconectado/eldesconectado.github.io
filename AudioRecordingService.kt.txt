package com.example.mexicoparanormal

import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.Service
import android.content.Context
import android.content.Intent
import android.media.AudioFormat
import android.media.AudioRecord
import android.media.MediaRecorder
import android.os.Build
import android.os.IBinder
import android.util.Log
import androidx.core.app.NotificationCompat
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.cancel
import kotlinx.coroutines.launch
import java.io.File
import java.io.FileOutputStream
import java.io.IOException
import java.nio.ByteBuffer
import java.nio.ByteOrder

class AudioRecordingService : Service() {

    private var audioRecord: AudioRecord? = null
    private var isRecording = false
    private var recordingJob: Job? = null
    private val serviceScope = CoroutineScope(Dispatchers.IO)

    private lateinit var notificationManager: NotificationManager

    companion object {
        private const val LOG_TAG = "AudioRecordingService"
        private const val NOTIFICATION_CHANNEL_ID = "AudioRecordingChannel"
        private const val NOTIFICATION_ID = 101

        // Parámetros de audio (ajustar según tus necesidades)
        private const val SAMPLE_RATE = 44100 // Hz
        private const val CHANNEL_CONFIG = AudioFormat.CHANNEL_IN_MONO
        private const val AUDIO_FORMAT = AudioFormat.ENCODING_PCM_16BIT

        // Acciones para Intents
        const val ACTION_START_RECORDING = "com.example.mexicoparanormal.START_RECORDING"
        const val ACTION_STOP_RECORDING = "com.example.mexicoparanormal.STOP_RECORDING"
        const val EXTRA_FILE_PATH = "file_path"
    }

    override fun onCreate() {
        super.onCreate()
        Log.d(LOG_TAG, "Servicio de grabación de audio creado.")
        notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        createNotificationChannel()
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        Log.d(LOG_TAG, "onStartCommand: ${intent?.action}")
        when (intent?.action) {
            ACTION_START_RECORDING -> {
                val filePath = intent.getStringExtra(EXTRA_FILE_PATH)
                if (filePath != null) {
                    startRecording(filePath)
                } else {
                    Log.e(LOG_TAG, "Ruta de archivo no proporcionada para iniciar grabación.")
                    stopSelf()
                }
            }
            ACTION_STOP_RECORDING -> {
                stopRecording()
            }
        }
        return START_NOT_STICKY // El servicio no se reinicia si el sistema lo mata.
    }

    override fun onDestroy() {
        super.onDestroy()
        stopRecording() // Asegurarse de detener la grabación al destruir el servicio
        serviceScope.cancel() // Cancelar todas las corrutinas
        Log.d(LOG_TAG, "Servicio de grabación de audio destruido.")
    }

    override fun onBind(intent: Intent?): IBinder? {
        return null // Este servicio no se enlaza con componentes, es un servicio iniciado.
    }

    private fun createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val serviceChannel = NotificationChannel(
                NOTIFICATION_CHANNEL_ID,
                "Grabación de Audio en Segundo Plano",
                NotificationManager.IMPORTANCE_LOW
            )
            notificationManager.createNotificationChannel(serviceChannel)
        }
    }

    private fun getNotification(): Notification {
        // En un escenario real, deberías tener un PendingIntent para abrir tu actividad
        // principal cuando se toca la notificación.
        val notificationIntent = Intent(this, RecordAudioFragment::class.java) // O tu actividad principal
        val pendingIntent = android.app.PendingIntent.getActivity(
            this,
            0,
            notificationIntent,
            android.app.PendingIntent.FLAG_IMMUTABLE
        )

        return NotificationCompat.Builder(this, NOTIFICATION_CHANNEL_ID)
            .setContentTitle("Grabando Audio")
            .setContentText("El audio se está grabando en segundo plano.")
            .setSmallIcon(R.drawable.ic_audio_waves) // Asegúrate de tener este ícono o uno similar
            .setContentIntent(pendingIntent)
            .setOngoing(true) // Hace que la notificación no se pueda descartar
            .build()
    }

    private fun startRecording(filePath: String) {
        if (isRecording) {
            Log.d(LOG_TAG, "Ya se está grabando.")
            return
        }

        val minBufferSize = AudioRecord.getMinBufferSize(SAMPLE_RATE, CHANNEL_CONFIG, AUDIO_FORMAT)
        if (minBufferSize == AudioRecord.ERROR_BAD_VALUE || minBufferSize == AudioRecord.ERROR) {
            Log.e(LOG_TAG, "Parámetros de audio no válidos o error al obtener el tamaño mínimo del buffer.")
            return
        }

        try {
            audioRecord = AudioRecord(
                MediaRecorder.AudioSource.MIC,
                SAMPLE_RATE,
                CHANNEL_CONFIG,
                AUDIO_FORMAT,
                minBufferSize
            )

            if (audioRecord?.state != AudioRecord.STATE_INITIALIZED) {
                Log.e(LOG_TAG, "AudioRecord no se pudo inicializar. Verifique permisos o hardware.")
                return
            }

            // Iniciar el servicio en primer plano para evitar que Android lo mate
            startForeground(NOTIFICATION_ID, getNotification())

            isRecording = true
            audioRecord?.startRecording()
            Log.d(LOG_TAG, "Grabación iniciada en: $filePath")

            recordingJob = serviceScope.launch {
                val buffer = ByteArray(minBufferSize)
                var fos: FileOutputStream? = null
                try {
                    val outputFile = File(filePath)
                    if (!outputFile.exists()) {
                        outputFile.createNewFile()
                    }
                    fos = FileOutputStream(outputFile)

                    while (isRecording) {
                        val bytesRead = audioRecord?.read(buffer, 0, buffer.size) ?: 0
                        if (bytesRead > 0) {
                            fos.write(buffer, 0, bytesRead)
                            // Aquí podrías enviar los datos al WaveformView a través de un Broadcast
                            // o una interfaz si fuera necesario actualizarlo en tiempo real.
                        }
                    }
                } catch (e: IOException) {
                    Log.e(LOG_TAG, "Error de escritura de archivo durante la grabación: ${e.message}")
                } finally {
                    fos?.close()
                    Log.d(LOG_TAG, "Archivo de grabación cerrado.")
                }
            }
        } catch (e: SecurityException) {
            Log.e(LOG_TAG, "Permiso de micrófono denegado: ${e.message}")
            stopSelf() // Detener el servicio si no hay permiso
        } catch (e: Exception) {
            Log.e(LOG_TAG, "Error inesperado al iniciar la grabación: ${e.message}")
            stopSelf()
        }
    }

    private fun stopRecording() {
        if (!isRecording) {
            Log.d(LOG_TAG, "No hay grabación activa para detener.")
            return
        }
        isRecording = false
        recordingJob?.cancel() // Cancelar la corrutina de grabación
        audioRecord?.apply {
            if (state == AudioRecord.STATE_INITIALIZED) {
                stop()
                release()
            }
        }
        audioRecord = null
        stopForeground(true) // Eliminar la notificación del servicio en primer plano
        Log.d(LOG_TAG, "Grabación detenida.")
        stopSelf() // Detener el servicio completamente
    }
}