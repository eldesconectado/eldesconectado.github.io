

===== Archivo: app\src\main\res\drawable\ =====


bg_record_button.xml - Botón grabar
calaverita.png - Logo principal
divider_vertical.xml - Es un divisor blanco que está entre los botones de subir imagen
glassmorphism_background.xml - Efecto de vidrio esmerilado
gradient_background.xml - El fondo degradado que tienen todas las pantallas del proyecto
ic_admin.xml - Ícono perfil de administrador
ic_approved.xml - Ícono aprobados
ic_arrow_back.xml - Ícono X botón regresar
ic_arrow_left.xml - Ícono publicación anterior
ic_arrow_right.xml - Ícono publicación siguiente
ic_attachment.xml - Ícono de adjuntar
ic_audio_waves.xml - Descripción no definida
ic_book.xml - Ícono relato
ic_close.xml - Ícono X para cerrar
ic_comment.xml - Ícono comentarios
ic_coo.xml - Ícono coordenadas
ic_corazon.xml - Ícono favoritos publicación y favoritos guardados
ic_delete.xml - Ícono eliminar cuenta
ic_emojis.xml - Ícono para comentarios con emojis
ic_favorite.xml - Ícono sección favoritos
ic_info.xml - Ícono información
ic_launcher_background.xml - Fondo del ícono de la app
ic_launcher_foreground.xml - Parte frontal del ícono
ic_logout.xml - Ícono cerrar sesión
ic_map.xml - Ícono sección mapa paranormal
ic_megusta.xml - Ícono 'Me gusta'
ic_notifications.xml - Ícono campana notificaciones
ic_pause.xml - Ícono pausar
ic_pause_red.xml - Descripción no definida
ic_pending.xml - Ícono pendientes
ic_perfil.xml - Ícono perfil de usuario
ic_photo.xml - Ícono foto
ic_places.xml - Ícono sección lugares investigados
ic_play.xml - Ícono reproducir
ic_recent.xml - Ícono sección recientes
ic_record.xml - Ícono historial
ic_record_red.xml - Ícono grabar rojo
ic_rejected.xml - Ícono rechazados
ic_reply.xml - Ícono responder
ic_save_audio.xml - Ícono guardar audio
ic_search.xml - Barra de búsqueda
ic_search_action.xml - Enviar en búsqueda
ic_send.xml - Enviar
ic_settings.xml - Ícono editar perfil de usuario
ic_sound_off.xml - Silenciar sonido
ic_sound_on.xml - Activar sonido
ic_stop.xml - Ícono detener
ic_stop_red.xml - Ícono detener rojo
ic_supervised.xml - Ícono gestión de usuarios
ic_text_format.xml - Cambiar a mayúsculas
ic_upload.xml - Ícono mis envíos / icono subir
ic_video.xml - Ícono video
ic_zoom_in_out.xml - Zoom
placeholder_image.xml - Imagen temporal
spinner_background.xml - Para dar estilo a los Spinners


===== Archivo: .gitignore =====


*.iml
.gradle
/local.properties
/.idea/caches
/.idea/libraries
/.idea/modules.xml
/.idea/workspace.xml
/.idea/navEditor.xml
/.idea/assetWizardSettings.xml
.DS_Store
/build
/captures
.externalNativeBuild
.cxx
local.properties


===== Destacados en google-services.json =====


          "client_id": "463011268660-hs0hkqmv42ptbcfug748j9fi6nhk75ce.apps.googleusercontent.com",
          "client_type": 3


===== Archivo: app\google-services.json =====


{
  "project_info": {
    "project_number": "463011268660",
    "project_id": "mexicoparanormal-ea51f",
    "storage_bucket": "mexicoparanormal-ea51f.firebasestorage.app"
  },
  "client": [
    {
      "client_info": {
        "mobilesdk_app_id": "1:463011268660:android:ee3e2b3b0b0c33c3b9e261",
        "android_client_info": {
          "package_name": "com.example.mexicoparanormal"
        }
      },
      "oauth_client": [
        {
          "client_type": 1,
          "android_info": {
            "package_name": "com.example.mexicoparanormal",
            "certificate_hash": "4daf49fba957ce820bd923ce21b735a376c5ead6"
          }
        },
        {
          "client_type": 1,
          "android_info": {
            "package_name": "com.example.mexicoparanormal",
            "certificate_hash": "2879527777f978475b44b5da4b70994b80201173"
          }
        },
        {
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCjpOI_gOXiYCt03_rVBHvXxV8PyAyifiw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
            }
          ]
        }
      }
    }
  ],
  "configuration_version": "1"
}


===== Archivo: app\src\main\res\font =====


montserratbold.ttf
weiss_antiqua.otf


===== Archivo: local.properties =====


## This file is automatically generated by Android Studio.
# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
#
# This file should *NOT* be checked into Version Control Systems,
# as it contains information specific to your local configuration.
#
# Location of the SDK. This is only used by Gradle.
# For customization when using a Version Control System, please read the
# header note.
sdk.dir=C\:\\Users\\Leonardo\\AppData\\Local\\Android\\Sdk


===== Archivo: build.gradle.kts =====


// Top-level build file where you can add configuration options common to all sub-projects/modules.
plugins {
    alias(libs.plugins.android.application) apply false
    alias(libs.plugins.kotlin.android) apply false
    alias(libs.plugins.google.services) apply false
}


===== Archivo: settings.gradle.kts =====


@file:Suppress("UnstableApiUsage")  // <-- Quitar advertencias de APIs incubadoras, relacionadas con repositoriesMode que están marcadas como experimentales en la versión de Gradle que estamos usando

pluginManagement {
    repositories {
        google {
            content {
                includeGroupByRegex("com\\.android.*")
                includeGroupByRegex("com\\.google.*")
                includeGroupByRegex("androidx.*")
            }
        }
        mavenCentral()
        gradlePluginPortal()
    }
}
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
    }
}

rootProject.name = "MexicoParanormal"
include(":app")


===== Archivo: gradle.properties =====


# Project-wide Gradle settings.
# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.
# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html
# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
org.gradle.jvmargs=-Xmx1024m -Dfile.encoding=UTF-8
# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. For more details, visit
# https://developer.android.com/r/tools/gradle-multi-project-decoupled-projects
# org.gradle.parallel=true
# AndroidX package structure to make it clearer which packages are bundled with the
# Android operating system, and which are packaged with your app's APK
# https://developer.android.com/topic/libraries/support-library/androidx-rn
android.useAndroidX=true
# Kotlin code style for this project: "official" or "obsolete":
kotlin.code.style=official
# Enables namespacing of each library's R class so that its R class includes only the
# resources declared in the library itself and none from the library's dependencies,
# thereby reducing the size of the R class for that library
android.nonTransitiveRClass=true


===== Archivo: gradle\\wrapper\\gradle-wrapper.properties =====


#Tue Apr 15 19:37:17 COT 2025
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.11.1-bin.zip
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists


===== Archivo: gradle\\libs.versions.toml =====


[versions]
agp = "8.10.0"
kotlin = "2.0.21"
coreKtx = "1.16.0"
junit = "4.13.2"
junitVersion = "1.2.1"
espressoCore = "3.6.1"
appcompat = "1.7.0"
material = "1.12.0"
activity = "1.10.1"
constraintlayout = "2.2.1"
recyclerview = "1.4.0"
androidYoutubePlayer = "12.1.0"
firebaseBom = "33.13.0"
googleServices = "4.4.2"
playServicesAuth = "21.3.0"
credentials = "1.5.0"
googleid = "1.1.1"
viewpager2 = "1.1.0"

[libraries]
androidx-core-ktx = { group = "androidx.core", name = "core-ktx", version.ref = "coreKtx" }
junit = { group = "junit", name = "junit", version.ref = "junit" }
androidx-junit = { group = "androidx.test.ext", name = "junit", version.ref = "junitVersion" }
androidx-espresso-core = { group = "androidx.test.espresso", name = "espresso-core", version.ref = "espressoCore" }
androidx-appcompat = { group = "androidx.appcompat", name = "appcompat", version.ref = "appcompat" }
material = { group = "com.google.android.material", name = "material", version.ref = "material" }
androidx-activity = { group = "androidx.activity", name = "activity", version.ref = "activity" }
androidx-constraintlayout = { group = "androidx.constraintlayout", name = "constraintlayout", version.ref = "constraintlayout" }
androidx-recyclerview = { group = "androidx.recyclerview", name = "recyclerview", version.ref = "recyclerview" }
androidYoutubePlayer-core = { group = "com.pierfrancescosoffritti.androidyoutubeplayer", name = "core", version.ref = "androidYoutubePlayer" }

firebase-bom = { group = "com.google.firebase", name = "firebase-bom", version.ref = "firebaseBom" }
firebase-auth = { group = "com.google.firebase", name = "firebase-auth-ktx" }
firebase-firestore = { group = "com.google.firebase", name = "firebase-firestore-ktx" }
play-services-auth = { group = "com.google.android.gms", name = "play-services-auth", version.ref = "playServicesAuth" }
androidx-credentials = { group = "androidx.credentials", name = "credentials", version.ref = "credentials" }
androidx-credentials-play-services-auth = { group = "androidx.credentials", name = "credentials-play-services-auth", version.ref = "credentials" }
googleid = { group = "com.google.android.libraries.identity.googleid", name = "googleid", version.ref = "googleid" }
androidx-viewpager2 = { group = "androidx.viewpager2", name = "viewpager2", version.ref = "viewpager2" }

[plugins]
android-application = { id = "com.android.application", version.ref = "agp" }
kotlin-android = { id = "org.jetbrains.kotlin.android", version.ref = "kotlin" }
google-services = { id = "com.google.gms.google-services", version.ref = "googleServices" }


===== Archivo: app\\build.gradle.kts =====


plugins {
    alias(libs.plugins.android.application)
    alias(libs.plugins.kotlin.android)
    alias(libs.plugins.google.services)
}

android {
    namespace = "com.example.mexicoparanormal"
    compileSdk = 35

    defaultConfig {
        applicationId = "com.example.mexicoparanormal"
        minSdk = 24
        targetSdk = 35
        versionCode = 1
        versionName = "1.0"

        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
    }

    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_11
        targetCompatibility = JavaVersion.VERSION_11
    }

    kotlinOptions {
        jvmTarget = "11"
    }

    buildFeatures {
        viewBinding = true
    }

    packaging {
        resources.excludes.add("META-INF/INDEX.LIST")
        resources.excludes.add("META-INF/DEPENDENCIES")
        resources.excludes.add("META-INF/io.netty.versions.properties")
    }
}

dependencies {
    implementation(libs.androidx.core.ktx)
    // implementation("androidx.core:core-ktx:1.16.0") // Ya está incluido arriba como libs.androidx.core.ktx
    implementation(libs.androidx.appcompat)
    implementation(libs.material)
    implementation(libs.androidx.constraintlayout)
    implementation(libs.androidx.recyclerview)

    implementation(libs.androidx.credentials)
    implementation(libs.androidx.credentials.play.services.auth)
    implementation(libs.googleid)
    implementation(libs.play.services.auth)

    // Firebase
    implementation(platform(libs.firebase.bom))
    implementation(libs.firebase.auth)
    implementation(libs.firebase.firestore)
    implementation("com.google.firebase:firebase-storage-ktx:20.3.0") // Mantén tu versión o actualiza si es necesario

    // RECOMENDACIÓN 2: Firebase App Check
    // Agrega la dependencia para Firebase App Check con Play Integrity (recomendado)
       implementation("com.google.firebase:firebase-appcheck-playintegrity:18.0.0") // Verifica la última versión
    // Opcional: Si necesitas SafetyNet (menos recomendado, Play Integrity es el sucesor)
    // implementation("com.google.firebase:firebase-appcheck-safetynet:17.1.1") // Verifica la última versión

    // Cloudinary
    implementation("com.cloudinary:cloudinary-android:2.0.0")

    // Glide
    implementation("com.github.bumptech.glide:glide:4.16.0")
    annotationProcessor("com.github.bumptech.glide:compiler:4.16.0")

    // YouTube Player
    implementation(libs.androidYoutubePlayer.core)
    implementation(libs.androidx.viewpager2)

    // Testing
    testImplementation(libs.junit)
    androidTestImplementation(libs.androidx.junit)
    androidTestImplementation(libs.androidx.espresso.core)

    // Añade esta línea para fragment-ktx. Usamos la versión 1.7.0 para alinearla con tu appcompat.
    implementation("androidx.fragment:fragment-ktx:1.8.7")

    // Dependencias de Google Maps y Places
    implementation("com.google.android.gms:play-services-maps:19.2.0") // O la versión que uses de libs.versions.toml si está allí
    implementation("com.google.android.gms:play-services-location:21.3.0") // O la versión que uses de libs.versions.toml si está allí
    // RECOMENDACIÓN 1: Se elimina la dependencia antigua de play-services-places
    // implementation("com.google.android.gms:play-services-places:17.1.0") // <--- ELIMINADA
    implementation("com.google.android.libraries.places:places:4.3.1") // Mantén esta o actualiza si es necesario

    // RECOMENDACIÓN 3: ProviderInstaller (si es necesario)
    // Si los warnings de ProviderInstaller persisten o causan problemas, puedes agregar:
    // implementation("com.google.android.gms:play-services-basement:18.4.0") // Verifica la última versión de play-services-basement

    // Nueva dependencia para Utilidades de Maps (Incluye Geojson)
    implementation("com.google.maps.android:maps-utils-ktx:3.4.0") // Verifica la última versión

    // ExoPlayer
    implementation("com.google.android.exoplayer:exoplayer:2.19.1") // Verifica la última versión

    // ONNX Runtime for Android
    implementation("com.microsoft.onnxruntime:onnxruntime-android:1.22.0") // Verifica la última versión
    implementation("com.github.wendykierp:JTransforms:3.1") // JTransforms

    // Kotlin Coroutines
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.8.1") // Verifica la última versión estable
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:1.8.1") // Verifica la última versión estable

}


===== Archivo: app\\proguard-rules.pro =====


# Add project specific ProGuard rules here.
# You can control the set of applied configuration files using the
# proguardFiles setting in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}

# Uncomment this to preserve the line number information for
# debugging stack traces.
#-keepattributes SourceFile,LineNumberTable

# If you keep the line number information, uncomment this to
# hide the original source file name.
#-renamesourcefileattribute SourceFile


===== Archivo: app\google-services.json =====


{
  "project_info": {
    "project_number": "463011268660",
    "project_id": "mexicoparanormal-ea51f",
    "storage_bucket": "mexicoparanormal-ea51f.firebasestorage.app"
  },
  "client": [
    {
      "client_info": {
        "mobilesdk_app_id": "1:463011268660:android:ee3e2b3b0b0c33c3b9e261",
        "android_client_info": {
          "package_name": "com.example.mexicoparanormal"
        }
      },
      "oauth_client": [
        {
          "client_id": "463011268660-hs0hkqmv42ptbcfug748j9fi6nhk75ce.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "com.example.mexicoparanormal",
            "certificate_hash": "4daf49fba957ce820bd923ce21b735a376c5ead6"
          }
        },
        {
          "client_id": "463011268660-s3r6osqv10g9ong22p51fm1q9argr64h.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "com.example.mexicoparanormal",
            "certificate_hash": "2879527777f978475b44b5da4b70994b80201173"
          }
        },
        {
          "client_id": "463011268660-vhi439m4jrspflaopfod6inlte2m7jre.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCjpOI_gOXiYCt03_rVBHvXxV8PyAyifiw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "463011268660-vhi439m4jrspflaopfod6inlte2m7jre.apps.googleusercontent.com",
              "client_type": 3
            }
          ]
        }
      }
    }
  ],
  "configuration_version": "1"
}


===== Archivo: app\src\androidTest\java\com\example\mexicoparanormal\ExampleInstrumentedTest.kt =====


package com.example.mexicoparanormal

import androidx.test.platform.app.InstrumentationRegistry
import androidx.test.ext.junit.runners.AndroidJUnit4

import org.junit.Test
import org.junit.runner.RunWith

import org.junit.Assert.*

/**
 * Instrumented test, which will execute on an Android device.
 *
 * See [testing documentation](http://d.android.com/tools/testing).
 */
@RunWith(AndroidJUnit4::class)
class ExampleInstrumentedTest {
    @Test
    fun useAppContext() {
        // Context of the app under test.
        val appContext = InstrumentationRegistry.getInstrumentation().targetContext
        assertEquals("com.example.mexicoparanormal", appContext.packageName)
    }
}


===== Archivo: app\src\main\AndroidManifest.xml =====


<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
    <uses-permission android:name="android.permission.RECORD_AUDIO" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_MICROPHONE" />
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS"/>
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" android:maxSdkVersion="28" />


    <application
        android:name=".MexicoParanormalApplication"
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.MexicoParanormal"
        tools:targetApi="31"
        tools:replace="android:fullBackupContent">


        <meta-data
            android:name="com.google.android.geo.API_KEY"
            android:value="AIzaSyDBcaOlwFvqg6o-py9-dP6UzAFsciH0B2A" />

        <meta-data
            android:name="com.google.android.gms.maps.api_key"
            android:value="AIzaSyDBcaOlwFvqg6o-py9-dP6UzAFsciH0B2A" />

        <service
            android:name=".AudioRecordingService"
            android:exported="false"
            android:foregroundServiceType="microphone" />

        <activity
            android:name=".MapsActivity"
            android:exported="false" />

        <activity
            android:name=".UploadVideoActivity"
            android:exported="false" />
        <activity
            android:name=".UploadImageActivity"
            android:exported="false"
            android:theme="@style/Theme.MexicoParanormal" />
        <activity
            android:name=".UploadStoryActivity"
            android:exported="false"
            android:launchMode="singleTop"/>
        <activity
            android:name=".UserProfileActivity"
            android:exported="false"
            android:label="@string/profile" />
        <activity
            android:name=".AdminProfileActivity"
            android:exported="false"
            android:label="@string/admin_profile_activity_title" />
        <activity
            android:name=".VideoViewerActivity"
            android:exported="false" />
        <activity
            android:name=".ImageViewerActivity"
            android:exported="false" />
        <activity
            android:name=".RelatoViewerActivity"
            android:exported="false" />
        <activity
            android:name=".SearchResultsActivity"
            android:exported="false" />
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:windowSoftInputMode="adjustResize"> <intent-filter>
            <action android:name="android.intent.action.MAIN" />
            <category android:name="android.intent.category.LAUNCHER" />
        </intent-filter>
        </activity>

        <activity
            android:name=".EditProfileActivity"
            android:exported="false" />

        <activity
            android:name=".PendingUploadsActivity"
            android:exported="false"
            android:label="@string/title_pending_uploads"
            android:theme="@style/Theme.MexicoParanormal" />
    </application>
</manifest>


===== Archivo: app\src\main\java\com\example\mexicoparanormal\AdminModerationFragment.kt =====


package com.example.mexicoparanormal

import android.os.Bundle
import androidx.fragment.app.Fragment
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Toast
import com.example.mexicoparanormal.databinding.FragmentAdminModerationBinding
// TODO: Importar modelos de datos, adaptadores de RecyclerView y Firebase Firestore cuando se implemente la lógica.

class AdminModerationFragment : Fragment() {

    private var _binding: FragmentAdminModerationBinding? = null
    private val binding get() = _binding!!

    // TODO: Inicializar Firestore y adaptadores de RecyclerView aquí

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        _binding = FragmentAdminModerationBinding.inflate(inflater, container, false)
        val root = binding.root

        // Configurar RecyclerViews (cuando estén listos)
        // setupPendingRecyclerViews()
        // setupHistoryRecyclerViews()
        // setupUserManagementRecyclerViews()

        // Configurar Listeners para los botones de Ban/Unban (Placeholder)
        binding.btnBanUser.setOnClickListener {
            // TODO: Implementar lógica para seleccionar y banear usuarios
            Toast.makeText(requireContext(), getString(R.string.admin_moderation_ban_user_placeholder), Toast.LENGTH_SHORT).show()
        }

        binding.btnUnbanUser.setOnClickListener {
            // TODO: Implementar lógica para seleccionar y desbanear usuarios
            Toast.makeText(requireContext(), getString(R.string.admin_moderation_unban_user_placeholder), Toast.LENGTH_SHORT).show()
        }

        // Cargar datos iniciales (cuando la lógica de Firestore esté lista)
        // loadPendingItems()
        // loadModerationHistory()
        // loadUsersForManagement()

        return root
    }

    // TODO: Implementar funciones para configurar RecyclerViews
    // private fun setupPendingRecyclerViews() { ... }
    // private fun setupHistoryRecyclerViews() { ... }
    // private fun setupUserManagementRecyclerViews() { ... }

    // TODO: Implementar funciones para cargar datos desde Firestore
    // private fun loadPendingItems() { ... }
    // private fun loadModerationHistory() { ... }
    // private fun loadUsersForManagement() { ... }

    // TODO: Implementar funciones para acciones de moderación (Aprobar, Rechazar)
    // private fun approveItem(itemId: String, itemType: String) { ... }
    // private fun rejectItem(itemId: String, itemType: String, reason: String) { ... }

    // TODO: Implementar funciones para acciones de gestión de usuarios (Banear, Desbanear)
    // private fun banUser(userId: String) { ... }
    // private fun unbanUser(userId: String) { ... }


    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }
}


===== Archivo: app\src\main\java\com\example\mexicoparanormal\AdminProfileActivity.kt =====


package com.example.mexicoparanormal

import android.content.Intent
import android.os.Bundle
import androidx.activity.OnBackPressedCallback
import androidx.appcompat.app.AppCompatActivity
import androidx.fragment.app.Fragment
import androidx.viewpager2.adapter.FragmentStateAdapter
import com.example.mexicoparanormal.databinding.ActivityAdminProfileBinding
import com.google.android.material.tabs.TabLayoutMediator

class AdminProfileActivity : AppCompatActivity() {

    private lateinit var binding: ActivityAdminProfileBinding

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityAdminProfileBinding.inflate(layoutInflater)
        setContentView(binding.root)

        // Configurar botón de regreso en la barra de título
        binding.btnBackAdmin.setOnClickListener {
            // Finaliza esta actividad para regresar a MainActivity
            finish()
        }

        // Configurar ViewPager2 y TabLayout
        binding.viewPagerAdmin.adapter = AdminProfilePagerAdapter(this)

        TabLayoutMediator(binding.tabLayoutAdmin, binding.viewPagerAdmin) { tab, position ->
            val tabTitle = when (position) {
                0 -> getString(R.string.tab_moderation_title)
                1 -> getString(R.string.uploads)
                2 -> getString(R.string.settings)
                else -> null
            }
            tab.text = tabTitle
            tab.contentDescription = tabTitle // Para accesibilidad
        }.attach()

        // Manejo del botón de retroceso del sistema
        val callback = object : OnBackPressedCallback(true) {
            override fun handleOnBackPressed() {
                // Si estamos en la primera pestaña (Moderación), salir de la actividad
                if (binding.viewPagerAdmin.currentItem == 0) {
                    finish() // Finaliza AdminProfileActivity para volver a MainActivity
                } else {
                    // Si no estamos en la primera pestaña, ir a la pestaña anterior
                    binding.viewPagerAdmin.currentItem = binding.viewPagerAdmin.currentItem - 1
                }
            }
        }
        this.onBackPressedDispatcher.addCallback(this, callback)

        // Listener para el ícono de notificaciones (Placeholder)
        binding.iconNotificationAdmin.setOnClickListener {
            // TODO: Implementar la lógica para mostrar notificaciones del administrador
            // Por ejemplo, abrir una nueva actividad o un diálogo.
            // Toast.makeText(this, "Notificaciones de Admin (Próximamente)", Toast.LENGTH_SHORT).show()
        }
    }

    private inner class AdminProfilePagerAdapter(activity: AppCompatActivity) : FragmentStateAdapter(activity) {
        override fun getItemCount(): Int = 3 // Moderación, Subidas, Personalización

        override fun createFragment(position: Int): Fragment {
            return when (position) {
                0 -> AdminModerationFragment() // Nuevo fragmento para moderación
                1 -> UploadsFragment()       // Reutilizar fragmento de subidas
                2 -> SettingsFragment()      // Reutilizar fragmento de personalización
                else -> throw IllegalStateException(getString(R.string.error_invalid_fragment_position, position))
            }
        }
    }
}


===== Archivo: app\src\main\java\com\example\mexicoparanormal\AttachAudioFragment.kt =====


package com.example.mexicoparanormal

import android.content.Context
import android.media.MediaCodec
import android.media.MediaExtractor
import android.media.MediaFormat
import android.media.MediaMetadataRetriever
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.os.ParcelFileDescriptor
import android.provider.OpenableColumns
import android.util.Log
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.SeekBar
import android.widget.Toast
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AlertDialog
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope // La necesitas para el viewLifecycleOwner.lifecycleScope
// import androidx.lifecycle.viewLifecycleOwner // MODIFICACIÓN: Elimina esta línea, ya no es necesaria aquí.
import com.example.mexicoparanormal.databinding.FragmentAttachAudioBinding
import com.google.android.exoplayer2.ExoPlayer
import com.google.android.exoplayer2.MediaItem
import com.google.android.exoplayer2.PlaybackException
import com.google.android.exoplayer2.PlaybackParameters
import com.google.android.exoplayer2.Player
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.FileNotFoundException
import java.io.IOException
import java.nio.ByteBuffer
import java.nio.ByteOrder
import java.nio.ShortBuffer
import java.util.Locale
import java.util.concurrent.TimeUnit
import kotlin.math.abs
import kotlin.math.max
import kotlinx.coroutines.currentCoroutineContext

class AttachAudioFragment : Fragment(), WaveformView.OnWaveformInteractionListener {

    private var _binding: FragmentAttachAudioBinding? = null
    private val binding get() = _binding!!

    private var exoPlayer: ExoPlayer? = null
    private var attachedAudioUri: Uri? = null
    private var attachedAudioOriginalName: String? = null

    private val playbackSpeeds = floatArrayOf(0.5f, 1.0f, 1.5f, 2.0f)
    private lateinit var playbackSpeedStrings: Array<String>
    private var currentSpeedIndex = 1 // Índice para 1.0x

    private var playbackPosition: Long = 0
    private var playWhenReady: Boolean = true

    private val seekBarUpdateHandler = Handler(Looper.getMainLooper())
    private lateinit var runnableUpdateSeekBar: Runnable

    private var currentToast: Toast? = null
    private lateinit var waveformView: WaveformView
    private var waveformGenerationJob: Job? = null


    interface AudioAttachListener {
        fun onAudioAttached(uri: Uri?, originalFileName: String?)
        fun onAttachedAudioDeleted()
    }
    private var listener: AudioAttachListener? = null

    companion object {
        private const val TAG = "AttachAudioFragment"
        private const val MAX_AUDIO_SIZE_MB = 20
        private const val MAX_AUDIO_DURATION_MINUTES = 20
        private const val WAVEFORM_SAMPLES = WaveformView.WAVEFORM_SAMPLES_CONST
        @JvmStatic
        fun newInstance() = AttachAudioFragment()
    }

    private val selectAudioLauncher =
        registerForActivityResult(ActivityResultContracts.GetContent()) { uri: Uri? ->
            if (uri != null) {
                try {
                    val fileName = getFileNameFromUri(uri)
                    val fileSize = getFileSizeFromUri(uri)
                    val type = requireContext().contentResolver.getType(uri)

                    val allowedMimeTypes = listOf(
                        "audio/mpeg", "audio/opus", "audio/ogg",
                        "audio/mp4", "audio/x-m4a", "audio/aac"
                    )

                    var isValidType = false
                    if (type != null && allowedMimeTypes.contains(type.lowercase(Locale.getDefault()))) {
                        isValidType = true
                    } else {
                        val fileExtension = fileName.substringAfterLast('.', "").lowercase(Locale.getDefault())
                        if (listOf("mp3", "opus", "ogg", "m4a", "aac").contains(fileExtension)) {
                            isValidType = true
                        }
                    }

                    if (!isValidType) {
                        showSafeToast(getString(R.string.error_audio_invalid_type_detailed, fileName, type ?: getString(R.string.unknown_format)))
                        return@registerForActivityResult
                    }

                    val maxFileSizeBytes = MAX_AUDIO_SIZE_MB * 1024 * 1024
                    if (fileSize > maxFileSizeBytes) {
                        showSafeToast(getString(R.string.error_audio_file_too_large_detailed, MAX_AUDIO_SIZE_MB, fileSize / (1024 * 1024)))
                        return@registerForActivityResult
                    }

                    val durationMs = getAudioDuration(uri)
                    if (durationMs == null) {
                        showSafeToast(getString(R.string.error_audio_cannot_get_duration, fileName))
                        return@registerForActivityResult
                    }
                    if (durationMs > MAX_AUDIO_DURATION_MINUTES * 60 * 1000) {
                        showSafeToast(getString(R.string.error_audio_duration_exceeded_detailed, MAX_AUDIO_DURATION_MINUTES, durationMs / (60 * 1000)))
                        return@registerForActivityResult
                    }

                    releasePlayer()
                    waveformGenerationJob?.cancel()
                    attachedAudioUri = uri
                    attachedAudioOriginalName = fileName
                    showAttachedAudioPlayer(uri, fileName)
                    listener?.onAudioAttached(attachedAudioUri, attachedAudioOriginalName)
                    showSafeToast(getString(R.string.audio_selection_successful))

                } catch (e: SecurityException) {
                    Log.e(TAG, getString(R.string.log_error_security_exception_select_audio, e.message), e)
                    showSafeToast(getString(R.string.error_accessing_file_permission, uri.lastPathSegment ?: getString(R.string.selected_audio_default_name)))
                } catch (e: Exception) {
                    Log.e(TAG, getString(R.string.log_error_processing_selected_audio, e.message), e)
                    showSafeToast(getString(R.string.upload_file_error_message, e.localizedMessage ?: getString(R.string.unknown_error)))
                }
            } else {
                showSafeToast(getString(R.string.error_audio_selection_cancelled))
            }
        }

    override fun onAttach(context: Context) {
        super.onAttach(context)
        if (context is AudioAttachListener) {
            listener = context
        } else {
            throw ClassCastException(getString(R.string.error_must_implement_audio_attach_listener, context.toString()))
        }
    }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        _binding = FragmentAttachAudioBinding.inflate(inflater, container, false)
        waveformView = binding.waveformViewAttach
        waveformView.onWaveformInteractionListener = this
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        binding.tvInfoAttachFile.text = getString(R.string.info_attach_audio_file, MAX_AUDIO_SIZE_MB, MAX_AUDIO_DURATION_MINUTES)
        playbackSpeedStrings = arrayOf("0.5x", getString(R.string.text_playback_speed_1x), "1.5x", "2x")
        setupUI()
        initializeSeekBarUpdater()

        if (attachedAudioUri != null && attachedAudioOriginalName != null) {
            showAttachedAudioPlayer(attachedAudioUri!!, attachedAudioOriginalName!!)
        }
    }

    private fun setupUI() {
        binding.btnSelectAudioFile.visibility = View.VISIBLE
        binding.waveformContainer.visibility = View.GONE
        binding.tvLoadingWaveformIndicator.visibility = View.GONE
        binding.attachedAudioPlayerSection.visibility = View.GONE
        binding.seekBarAttachedAudio.visibility = View.GONE
        binding.tvPlayerTimerAttach?.text = getString(R.string.player_timer_default_ss)
        if(::waveformView.isInitialized) waveformView.clearWaveform()


        binding.btnSelectAudioFile.setOnClickListener {
            if (exoPlayer?.isPlaying == true) pausePlayback()
            selectAudioLauncher.launch("audio/*")
        }
        binding.btnPlayAttachedAudio.setOnClickListener {
            attachedAudioUri?.let { uri ->
                if (exoPlayer?.isPlaying != true) {
                    if (exoPlayer == null || exoPlayer?.currentMediaItem?.mediaId != uri.toString() || exoPlayer?.playbackState == Player.STATE_ENDED) {
                        initializeAndPlayAttachedAudio(uri, true)
                    } else {
                        exoPlayer?.play()
                    }
                }
            } ?: showSafeToast(getString(R.string.error_no_audio_to_play))
        }
        binding.btnPauseAttachedAudio.setOnClickListener { pausePlayback() }
        binding.btnDeleteAttachedAudio.setOnClickListener { deleteAttachedAudio() }
        binding.tvPlaybackSpeedAttached.setOnClickListener { cyclePlaybackSpeed(); applyPlaybackSpeed() }
        binding.seekBarAttachedAudio.setOnSeekBarChangeListener(object : SeekBar.OnSeekBarChangeListener {
            override fun onProgressChanged(seekBar: SeekBar?, progress: Int, fromUser: Boolean) {
                if (fromUser && exoPlayer != null) {
                    val newPosition = progress.toLong()
                    exoPlayer?.seekTo(newPosition)
                    if (::waveformView.isInitialized && (exoPlayer?.duration ?: 0L) > 0L) {
                        waveformView.updatePlaybackIndicator(newPosition, exoPlayer!!.duration)
                    }
                }
            }
            override fun onStartTrackingTouch(seekBar: SeekBar?) { /* No se necesita implementación */ }
            override fun onStopTrackingTouch(seekBar: SeekBar?) { /* No se necesita implementación */ }
        })
        binding.tvPlaybackSpeedAttached.text = playbackSpeedStrings[currentSpeedIndex]
    }

    private fun showAttachedAudioPlayer(uri: Uri, fileName: String) {
        binding.btnSelectAudioFile.visibility = View.GONE

        if(::waveformView.isInitialized) waveformView.clearWaveform()

        launchAudioAnalysis(uri)

        binding.tvAttachedAudioInfo.text = fileName
        binding.attachedAudioPlayerSection.visibility = View.VISIBLE
        initializeExoPlayer(uri, false)
    }

    private fun launchAudioAnalysis(audioUri: Uri) {
        if (!isAdded || !::waveformView.isInitialized) {
            Log.w(TAG, "launchAudioAnalysis: Fragment not added or waveformView not initialized. URI: $audioUri")
            return
        }
        Log.d(TAG, getString(R.string.log_launch_audio_analysis, audioUri.toString()))

        binding.waveformContainer.visibility = View.VISIBLE
        binding.waveformViewAttach.visibility = View.GONE
        binding.tvLoadingWaveformIndicator.visibility = View.VISIBLE

        waveformGenerationJob?.cancel()
        // Corrección: Usar viewLifecycleOwner.lifecycleScope
        waveformGenerationJob = viewLifecycleOwner.lifecycleScope.launch(Dispatchers.IO) {
            val normalizedAmplitudes = extractAmplitudes(requireContext(), audioUri, WAVEFORM_SAMPLES)

            if (!isActive) { // isActive se refiere a viewLifecycleOwner.lifecycleScope.isActive
                Log.d(TAG, getString(R.string.log_waveform_job_cancelled, audioUri.toString()))
                withContext(Dispatchers.Main) {
                    if (isAdded && _binding != null) { // Comprobar _binding
                        binding.tvLoadingWaveformIndicator.visibility = View.GONE
                    }
                }
                return@launch
            }

            withContext(Dispatchers.Main) {
                if (!isAdded || _binding == null ) { // Comprobación principal aquí
                    Log.w(TAG, "AttachAudioFragment: Fragment not added or binding is null after extraction. URI: $audioUri")
                    return@withContext
                }
                binding.tvLoadingWaveformIndicator.visibility = View.GONE

                if (normalizedAmplitudes.isNotEmpty()) {
                    Log.i(TAG, "AttachAudioFragment: Attempting to display waveform. Data available. URI: $audioUri. Amplitudes count: ${normalizedAmplitudes.size}")
                    binding.waveformContainer.visibility = View.VISIBLE
                    binding.waveformViewAttach.visibility = View.VISIBLE
                    binding.waveformViewAttach.post {
                        // Corrección: Condición actualizada dentro del post
                        if (isAdded && _binding != null) {
                            Log.d(TAG, "AttachAudioFragment: Inside post, setting waveform data. URI: $audioUri")
                            waveformView.setWaveformData(normalizedAmplitudes)
                            Log.d(TAG, getString(R.string.log_waveform_data_set) + " for URI: $audioUri")
                        } else {
                            val reason = mutableListOf<String>()
                            if (!isAdded) reason.add("fragment not added")
                            if (_binding == null) reason.add("binding is null")
                            Log.w(TAG, "AttachAudioFragment: Inside post, NOT setting waveform data (${reason.joinToString()}). URI: $audioUri")
                        }
                    }
                    Log.d(TAG, getString(R.string.log_waveform_update_samples, normalizedAmplitudes.size))
                } else {
                    Log.w(TAG, "AttachAudioFragment: No normalized amplitudes to display. URI: $audioUri")
                    if(::waveformView.isInitialized) waveformView.clearWaveform()
                    binding.waveformViewAttach.visibility = View.GONE
                    binding.waveformContainer.visibility = View.GONE
                    showSafeToast(getString(R.string.error_generating_waveform_preview))
                }
            }
        }
    }

    private suspend fun extractAmplitudes(context: Context, audioUri: Uri, targetSamples: Int): List<Float> {
        Log.d(TAG, getString(R.string.log_starting_amplitude_extraction, audioUri.toString(), targetSamples.toString()))
        val rawAmplitudes = mutableListOf<Int>()
        var extractor: MediaExtractor? = null
        var codec: MediaCodec? = null
        val contentResolver = context.contentResolver
        var pfd: ParcelFileDescriptor? = null

        try {
            extractor = MediaExtractor()
            pfd = contentResolver.openFileDescriptor(audioUri, "r")
            if (pfd == null) {
                Log.e(TAG, getString(R.string.log_error_open_filedescriptor_null, audioUri.toString()))
                return emptyList()
            }
            extractor.setDataSource(pfd.fileDescriptor)
            Log.d(TAG, getString(R.string.log_mediasource_set_successful))


            var audioTrackIndex = -1
            var inputFormat: MediaFormat? = null
            for (i in 0 until extractor.trackCount) {
                val format = extractor.getTrackFormat(i)
                val mime = format.getString(MediaFormat.KEY_MIME)
                Log.d(TAG, getString(R.string.log_track_info, i.toString(), mime.toString(), format.toString()))
                if (mime?.startsWith("audio/") == true) {
                    audioTrackIndex = i
                    inputFormat = format
                    Log.d(TAG, getString(R.string.log_audio_track_found, i.toString(), inputFormat.toString()))
                    break
                }
            }

            if (audioTrackIndex == -1 || inputFormat == null) {
                Log.e(TAG, getString(R.string.log_no_audio_track_found_uri, audioUri.toString()))
                return emptyList()
            }

            extractor.selectTrack(audioTrackIndex)
            val mimeType = inputFormat.getString(MediaFormat.KEY_MIME) ?: run {
                Log.e(TAG, getString(R.string.log_mime_type_null_for_audio_track))
                return emptyList()
            }
            Log.d(TAG, getString(R.string.log_selected_audio_track_mime, audioTrackIndex.toString(), mimeType))

            codec = MediaCodec.createDecoderByType(mimeType)
            Log.d(TAG, getString(R.string.log_mediacodec_decoder_created, mimeType))
            codec.configure(inputFormat, null, null, 0)
            codec.start()
            Log.d(TAG, getString(R.string.log_mediacodec_configured_started))

            val bufferInfo = MediaCodec.BufferInfo()
            var endOfInput = false
            var endOfOutput = false

            val audioDurationUsFromFormat = if (inputFormat.containsKey(MediaFormat.KEY_DURATION)) {
                inputFormat.getLong(MediaFormat.KEY_DURATION)
            } else { 0L }
            Log.d(TAG, getString(R.string.log_duration_from_mediaformat_us, audioDurationUsFromFormat.toString()))

            val audioDurationMs = getAudioDuration(audioUri) ?: 0L
            val finalAudioDurationUs = if (audioDurationUsFromFormat > 0) audioDurationUsFromFormat else audioDurationMs * 1000
            Log.d(TAG, getString(R.string.log_final_effective_duration_us, finalAudioDurationUs.toString()))

            val sampleRate = if (inputFormat.containsKey(MediaFormat.KEY_SAMPLE_RATE)) {
                inputFormat.getInteger(MediaFormat.KEY_SAMPLE_RATE)
            } else {
                Log.w(TAG, getString(R.string.log_samplerate_not_in_format_defaulting))
                44100
            }
            Log.d(TAG, getString(R.string.log_samplerate_info, sampleRate.toString()))

            val totalExpectedSamplesInFile = if (finalAudioDurationUs > 0 && sampleRate > 0) (finalAudioDurationUs * sampleRate / 1_000_000L) else 0L
            Log.d(TAG, getString(R.string.log_total_expected_samples_in_file, totalExpectedSamplesInFile.toString()))

            val pcmSamplesPerWaveformPoint = if (totalExpectedSamplesInFile > 0 && targetSamples > 0) {
                (totalExpectedSamplesInFile / targetSamples).coerceAtLeast(1L)
            } else {
                (sampleRate * 0.02).toLong().coerceAtLeast(1L)
            }
            Log.d(TAG, getString(R.string.log_pcm_samples_per_waveform_point, pcmSamplesPerWaveformPoint.toString()))

            var currentPcmSamplesInChunk: Long = 0
            var peakAmplitudeInChunk = 0
            val timeoutUs: Long = 10000
            var totalPcmSamplesProcessed: Long = 0
            var inputBufferDequeuedCount = 0
            var outputBufferDequeuedCount = 0
            var iterations = 0

            val maxIterationsSafetyFactor = if (totalExpectedSamplesInFile > 0) 2 else 500
            val maxIterations = (totalExpectedSamplesInFile / pcmSamplesPerWaveformPoint.coerceAtLeast(1) * maxIterationsSafetyFactor)
                .coerceAtLeast((targetSamples * 400L))
            Log.d(TAG, getString(R.string.log_max_iterations_safety_break, maxIterations.toString()))


            mainLoop@ while (!endOfOutput && rawAmplitudes.size < targetSamples && iterations < maxIterations && currentCoroutineContext().isActive) {
                iterations++

                if (iterations % 5000 == 0) Log.d(TAG, getString(R.string.log_main_loop_iteration_status, iterations.toString(), rawAmplitudes.size.toString(), endOfInput.toString(), endOfOutput.toString()))

                if (!endOfInput) {
                    try {
                        val inputBufferId = codec.dequeueInputBuffer(timeoutUs)
                        if (inputBufferId >= 0) {
                            inputBufferDequeuedCount++
                            val inputBuffer = codec.getInputBuffer(inputBufferId)
                            if (inputBuffer != null) {
                                val sampleSize = extractor.readSampleData(inputBuffer, 0)
                                if (sampleSize < 0) {
                                    codec.queueInputBuffer(inputBufferId, 0, 0, 0L, MediaCodec.BUFFER_FLAG_END_OF_STREAM)
                                    endOfInput = true
                                    Log.d(TAG, getString(R.string.log_eos_sent_to_decoder, inputBufferDequeuedCount.toString()))
                                } else if (sampleSize > 0) {
                                    codec.queueInputBuffer(inputBufferId, 0, sampleSize, extractor.sampleTime, 0)
                                    extractor.advance()
                                } else {
                                    codec.queueInputBuffer(inputBufferId, 0, 0, extractor.sampleTime, 0)
                                }
                            } else { Log.w(TAG, getString(R.string.log_getinputbuffer_returned_null, inputBufferId.toString()))}
                        }
                    } catch (e: MediaCodec.CodecException) {
                        Log.e(TAG, getString(R.string.log_codecexception_input_processing, e.message.toString(), e.isTransient.toString(), e.isRecoverable.toString()), e)
                        if (!e.isRecoverable) break@mainLoop
                    } catch (e: IllegalStateException) {
                        Log.e(TAG, getString(R.string.log_illegalstateexception_input_processing, e.message.toString()), e)
                        break@mainLoop
                    } catch (e: Exception) {
                        Log.e(TAG, getString(R.string.log_unexpected_exception_input_processing, e.message.toString()), e)
                        break@mainLoop
                    }
                }

                var outputBufferId: Int
                try {
                    outputBufferId = codec.dequeueOutputBuffer(bufferInfo, timeoutUs)
                } catch (e: MediaCodec.CodecException) {
                    Log.e(TAG, getString(R.string.log_codecexception_dequeueoutputbuffer, e.message.toString(), e.isTransient.toString(), e.isRecoverable.toString()), e)
                    if (!e.isRecoverable) break@mainLoop
                    continue@mainLoop
                } catch (e: IllegalStateException) {
                    Log.e(TAG, getString(R.string.log_illegalstateexception_dequeueoutputbuffer, e.message.toString()), e)
                    break@mainLoop
                } catch (e: Exception) {
                    Log.e(TAG, getString(R.string.log_unexpected_exception_dequeueoutputbuffer, e.message.toString()), e)
                    break@mainLoop
                }


                when (outputBufferId) {
                    MediaCodec.INFO_OUTPUT_FORMAT_CHANGED -> {
                        val newFormat = codec.outputFormat
                        Log.i(TAG, getString(R.string.log_decoder_output_format_changed, newFormat.toString()))
                    }
                    MediaCodec.INFO_TRY_AGAIN_LATER -> { /* Log.v(TAG, "dequeueOutputBuffer timed out"); */ }
                    MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED -> { Log.d(TAG, getString(R.string.log_output_buffers_changed_deprecated)) }
                    else -> {
                        if (outputBufferId >= 0) {
                            outputBufferDequeuedCount++
                            if (bufferInfo.flags and MediaCodec.BUFFER_FLAG_END_OF_STREAM != 0) {
                                Log.d(TAG, getString(R.string.log_eos_flag_received_output, outputBufferDequeuedCount.toString()))
                                endOfOutput = true
                            }
                            if (bufferInfo.size > 0) {
                                val outputBuffer = codec.getOutputBuffer(outputBufferId)
                                if (outputBuffer != null) {
                                    outputBuffer.order(ByteOrder.nativeOrder())
                                    val shortBuffer = outputBuffer.asShortBuffer()

                                    while (shortBuffer.hasRemaining() && rawAmplitudes.size < targetSamples) {
                                        val sample = shortBuffer.get().toInt()
                                        peakAmplitudeInChunk = max(peakAmplitudeInChunk, abs(sample))
                                        currentPcmSamplesInChunk++
                                        totalPcmSamplesProcessed++

                                        if (currentPcmSamplesInChunk >= pcmSamplesPerWaveformPoint) {
                                            rawAmplitudes.add(peakAmplitudeInChunk)
                                            peakAmplitudeInChunk = 0
                                            currentPcmSamplesInChunk = 0
                                            if (rawAmplitudes.size >= targetSamples) {
                                                Log.d(TAG, getString(R.string.log_target_samples_waveform_reached, targetSamples.toString()))
                                                break@mainLoop
                                            }
                                        }
                                    }
                                    outputBuffer.clear()
                                } else { Log.w(TAG, getString(R.string.log_getoutputbuffer_returned_null, outputBufferId.toString())) }
                            }
                            codec.releaseOutputBuffer(outputBufferId, false)
                        } else {
                            Log.w(TAG, getString(R.string.log_dequeueoutputbuffer_unexpected_index, outputBufferId.toString()))
                        }
                    }
                }
            }

            if (peakAmplitudeInChunk > 0 && rawAmplitudes.size < targetSamples) {
                rawAmplitudes.add(peakAmplitudeInChunk)
                Log.d(TAG, getString(R.string.log_added_final_peak_amplitude, peakAmplitudeInChunk.toString(), rawAmplitudes.size.toString()))
            }
            Log.i(TAG, getString(R.string.log_finished_extraction_loop_status, rawAmplitudes.size.toString(), totalPcmSamplesProcessed.toString(), iterations.toString()))

        } catch (e: FileNotFoundException) {
            Log.e(TAG, getString(R.string.log_filenotfoundexception_amplitude_extraction, audioUri.toString(), e.message.toString()), e)
            rawAmplitudes.clear()
        } catch (e: IOException) {
            Log.e(TAG, getString(R.string.log_ioexception_amplitude_extraction, audioUri.toString(), e.message.toString()), e)
            rawAmplitudes.clear()
        } catch (e: SecurityException) {
            Log.e(TAG, getString(R.string.log_securityexception_amplitude_extraction, audioUri.toString(), e.message.toString()), e)
            rawAmplitudes.clear()
        } catch (e: IllegalStateException) {
            Log.e(TAG, getString(R.string.log_illegalstateexception_amplitude_extraction, audioUri.toString(), e.message.toString()), e)
            rawAmplitudes.clear()
        } catch (e: Exception) {
            Log.e(TAG, getString(R.string.log_critical_error_amplitude_extraction, audioUri.toString(), e.message.toString()), e)
            rawAmplitudes.clear()
        } finally {
            try { pfd?.close() } catch (e: IOException) { Log.e(TAG, getString(R.string.log_error_closing_parcel_file_descriptor), e) }
            try { extractor?.release() } catch (e: Exception) { Log.e(TAG, getString(R.string.log_error_releasing_media_extractor), e) }
            try { codec?.stop(); codec?.release() } catch (e: Exception) { Log.e(TAG, getString(R.string.log_error_stopping_releasing_media_codec), e) }
        }

        if (rawAmplitudes.isEmpty()) {
            return emptyList()
        }
        val maxFoundAmplitude = rawAmplitudes.maxOrNull()?.toFloat() ?: 1f
        if (maxFoundAmplitude == 0f) {
            return rawAmplitudes.map { 0f }
        }
        return rawAmplitudes.map { it.toFloat() / maxFoundAmplitude }
    }


    private fun getFileNameFromUri(uri: Uri): String {
        var fileName = getString(R.string.default_audio_filename)
        try {
            requireContext().contentResolver.query(uri, null, null, null, null)?.use {
                if (it.moveToFirst()) {
                    val nameIndex = it.getColumnIndex(OpenableColumns.DISPLAY_NAME)
                    if (nameIndex != -1) it.getString(nameIndex)?.takeIf { str -> str.isNotEmpty() }?.also { name -> fileName = name }
                }
            }
        } catch (e: SecurityException) {
            Log.e(TAG, getString(R.string.log_security_exception_get_filename, uri.toString(), e.message.toString()), e)
            showSafeToast(getString(R.string.error_accessing_file_permission, uri.lastPathSegment ?: getString(R.string.audio_default_name)))
        } catch (e: Exception) {
            Log.e(TAG, getString(R.string.log_error_get_filename, uri.toString(), e.message.toString()), e)
            showSafeToast(getString(R.string.error_getting_filename, e.localizedMessage ?: getString(R.string.unknown_error)))
        }
        return fileName
    }

    private fun getFileSizeFromUri(uri: Uri): Long {
        var fileSize: Long = 0
        try {
            requireContext().contentResolver.query(uri, null, null, null, null)?.use {
                if (it.moveToFirst()) {
                    val sizeIndex = it.getColumnIndex(OpenableColumns.SIZE)
                    if (sizeIndex != -1) fileSize = it.getLong(sizeIndex)
                }
            }
        } catch (e: SecurityException) {
            Log.e(TAG, getString(R.string.log_security_exception_get_filesize, uri.toString(), e.message.toString()), e)
            showSafeToast(getString(R.string.error_accessing_file_permission, uri.lastPathSegment ?: getString(R.string.audio_default_name)))
        } catch (e: Exception) {
            Log.e(TAG, getString(R.string.log_error_get_filesize, uri.toString(), e.message.toString()), e)
            showSafeToast(getString(R.string.error_getting_filesize, e.localizedMessage ?: getString(R.string.unknown_error)))
        }
        return fileSize
    }

    private fun getAudioDuration(uri: Uri): Long? {
        if (!isAdded) return null
        val retriever = MediaMetadataRetriever()
        return try {
            retriever.setDataSource(requireContext(), uri)
            retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DURATION)?.toLongOrNull()
        } catch (e: IllegalArgumentException) {
            Log.e(TAG, getString(R.string.log_illegalargumentexception_get_duration, e.message.toString()), e)
            null
        } catch (e: RuntimeException) {
            Log.e(TAG, getString(R.string.log_runtimeexception_get_duration, e.message.toString()), e)
            null
        } catch (e: Exception) {
            Log.e(TAG, getString(R.string.log_general_error_get_duration, e.message.toString()), e)
            null
        } finally {
            try { retriever.release() } catch (e: IOException) { Log.e(TAG, getString(R.string.log_error_releasing_media_metadata_retriever), e) }
        }
    }

    private fun initializeExoPlayer(uri: Uri, autoPlay: Boolean) {
        if (!isAdded) return
        try {
            if (exoPlayer == null) {
                exoPlayer = ExoPlayer.Builder(requireContext()).build().apply { addListener(playerListener) }
            }
            val mediaItem = MediaItem.Builder().setUri(uri).setMediaId(uri.toString()).build()
            exoPlayer?.setMediaItem(mediaItem)
            exoPlayer?.seekTo(playbackPosition)
            exoPlayer?.playWhenReady = autoPlay
            applyPlaybackSpeed()
            exoPlayer?.prepare()
            updatePlayerUI()
        } catch (e: IllegalStateException) {
            Log.e(TAG, getString(R.string.log_illegalstateexception_init_exoplayer, e.message.toString()), e)
            showSafeToast(getString(R.string.error_playback_failed) + getString(R.string.error_suffix_invalid_state))
        } catch (e: Exception) {
            Log.e(TAG, getString(R.string.log_general_error_init_exoplayer, e.message.toString()), e)
            showSafeToast(getString(R.string.error_playback_failed) + getString(R.string.error_suffix_unknown_error))
        }
    }

    private fun initializeAndPlayAttachedAudio(uri: Uri, autoPlay: Boolean) {
        initializeExoPlayer(uri, autoPlay)
    }

    private fun pausePlayback() {
        try {
            exoPlayer?.pause()
        } catch (e: IllegalStateException) {
            Log.e(TAG, getString(R.string.log_illegalstateexception_pause_exoplayer, e.message.toString()), e)
        }
    }

    private fun deleteAttachedAudio() {
        waveformGenerationJob?.cancel()
        releasePlayer()
        attachedAudioUri = null
        attachedAudioOriginalName = null
        playbackPosition = 0
        playWhenReady = true
        currentSpeedIndex = 1
        updateUIForNoAudio()
        listener?.onAttachedAudioDeleted()
        Log.i(TAG, getString(R.string.log_attached_audio_deleted))
    }

    private fun updateUIForNoAudio() {
        if (_binding == null) return // Añadido para seguridad
        binding.btnSelectAudioFile.visibility = View.VISIBLE
        binding.waveformContainer.visibility = View.GONE
        binding.tvLoadingWaveformIndicator.visibility = View.GONE
        if(::waveformView.isInitialized) waveformView.clearWaveform()

        binding.attachedAudioPlayerSection.visibility = View.GONE
        binding.tvAttachedAudioInfo.text = ""
        binding.seekBarAttachedAudio.progress = 0
        binding.seekBarAttachedAudio.max = 100
        if (::playbackSpeedStrings.isInitialized) { // Asegurar que esté inicializado
            binding.tvPlaybackSpeedAttached.text = playbackSpeedStrings.getOrElse(currentSpeedIndex) { playbackSpeedStrings[0] }
        }
        binding.tvPlayerTimerAttach?.text = getString(R.string.player_timer_default_ss)
        binding.tvPlayerTimerAttach?.visibility = View.GONE
        binding.seekBarAttachedAudio.visibility = View.GONE
    }

    private fun cyclePlaybackSpeed() {
        currentSpeedIndex = (currentSpeedIndex + 1) % playbackSpeeds.size
        binding.tvPlaybackSpeedAttached.text = playbackSpeedStrings[currentSpeedIndex]
    }

    private fun applyPlaybackSpeed() {
        exoPlayer?.let {
            val currentSpeedValue = playbackSpeeds[currentSpeedIndex]
            it.playbackParameters = PlaybackParameters(currentSpeedValue)
        }
    }

    private val playerListener = object : Player.Listener {
        override fun onIsPlayingChanged(isPlaying: Boolean) {
            updatePlayerUI()
            if (isPlaying) {
                if (::runnableUpdateSeekBar.isInitialized) seekBarUpdateHandler.post(runnableUpdateSeekBar)
            } else {
                if (::runnableUpdateSeekBar.isInitialized) seekBarUpdateHandler.removeCallbacks(runnableUpdateSeekBar)
                if (::waveformView.isInitialized && exoPlayer != null && (exoPlayer?.duration ?: 0L) > 0L) {
                    waveformView.updatePlaybackIndicator(exoPlayer!!.currentPosition, exoPlayer!!.duration)
                }
            }
        }

        override fun onPlaybackStateChanged(playbackState: Int) {
            updatePlayerUI()
            if (playbackState == Player.STATE_ENDED) {
                exoPlayer?.seekTo(0)
                exoPlayer?.playWhenReady = false
                if (::waveformView.isInitialized && exoPlayer != null && (exoPlayer?.duration ?: 0L) > 0L) {
                    waveformView.updatePlaybackIndicator(0L, exoPlayer!!.duration)
                }
            }
        }

        override fun onPlayerError(error: PlaybackException) {
            if (!isAdded) return
            val errorMessage = getString(R.string.error_playback_failed_specific, error.localizedMessage ?: error.errorCodeName)
            Log.e(TAG, getString(R.string.log_exoplayer_error, error.errorCodeName, error.localizedMessage.toString()), error)
            showAlertDialog(getString(R.string.error_dialog_title), errorMessage)
            updatePlayerUI()
        }
    }

    private fun formatPlayerTimeSeconds(milliseconds: Long): String {
        if (milliseconds < 0) return "00:00"
        val totalSeconds = TimeUnit.MILLISECONDS.toSeconds(milliseconds.coerceAtLeast(0))
        val minutes = TimeUnit.SECONDS.toMinutes(totalSeconds)
        val seconds = totalSeconds - TimeUnit.MINUTES.toSeconds(minutes)
        return String.format(Locale.getDefault(), "%02d:%02d", minutes, seconds)
    }

    private fun updatePlayerTimerDisplay() {
        if (_binding == null || exoPlayer == null) {
            _binding?.tvPlayerTimerAttach?.text = getString(R.string.player_timer_default_ss) // Usar _binding seguro
            return
        }
        val currentPos = exoPlayer?.currentPosition ?: 0
        val totalDur = exoPlayer?.duration ?: 0

        val currentFormatted = formatPlayerTimeSeconds(currentPos)
        val totalFormatted = formatPlayerTimeSeconds(if (totalDur > 0 && totalDur != com.google.android.exoplayer2.C.TIME_UNSET) totalDur else 0)

        binding.tvPlayerTimerAttach?.text = "$currentFormatted / $totalFormatted"
    }

    private fun updatePlayerUI() {
        if (_binding == null) return

        val isPlayerActuallyReady = exoPlayer != null &&
                exoPlayer?.playbackState != Player.STATE_IDLE &&
                exoPlayer?.playbackState != Player.STATE_BUFFERING &&
                (exoPlayer?.duration ?: 0) > 0 &&
                exoPlayer?.duration != com.google.android.exoplayer2.C.TIME_UNSET

        val isPlaying = exoPlayer?.isPlaying ?: false

        binding.btnPlayAttachedAudio.visibility = if (isPlaying) View.GONE else View.VISIBLE
        binding.btnPauseAttachedAudio.visibility = if (isPlaying) View.VISIBLE else View.GONE

        binding.btnPlayAttachedAudio.isEnabled = isPlayerActuallyReady && !isPlaying
        binding.btnPauseAttachedAudio.isEnabled = isPlayerActuallyReady && isPlaying
        binding.tvPlaybackSpeedAttached.isEnabled = isPlayerActuallyReady

        if (isPlayerActuallyReady) {
            binding.seekBarAttachedAudio.visibility = View.VISIBLE
            binding.tvPlayerTimerAttach?.visibility = View.VISIBLE
            updatePlayerTimerDisplay()
            val duration = exoPlayer!!.duration
            binding.seekBarAttachedAudio.max = duration.toInt()
            binding.seekBarAttachedAudio.progress = exoPlayer!!.currentPosition.toInt()
        } else {
            binding.seekBarAttachedAudio.visibility = View.GONE
            binding.tvPlayerTimerAttach?.text = getString(R.string.player_timer_default_ss)
            binding.tvPlayerTimerAttach?.visibility = if (attachedAudioUri != null) View.VISIBLE else View.GONE
            binding.seekBarAttachedAudio.progress = 0
            binding.seekBarAttachedAudio.max = 100
        }
        if (::playbackSpeedStrings.isInitialized && playbackSpeedStrings.isNotEmpty()) {
            binding.tvPlaybackSpeedAttached.text = playbackSpeedStrings.getOrElse(currentSpeedIndex) { playbackSpeedStrings[0] }
        }
    }

    private fun initializeSeekBarUpdater() {
        runnableUpdateSeekBar = object : Runnable {
            override fun run() {
                exoPlayer?.let { player ->
                    if (player.isPlaying && view != null && isAdded) {
                        val currentPosition = player.currentPosition
                        val duration = player.duration
                        if (_binding != null) { // Comprobar _binding antes de usarlo
                            binding.seekBarAttachedAudio.progress = currentPosition.toInt()
                            updatePlayerTimerDisplay()
                        }

                        if (::waveformView.isInitialized && duration > 0) {
                            waveformView.updatePlaybackIndicator(currentPosition, duration)
                        }
                        seekBarUpdateHandler.postDelayed(this, 200)
                    }
                }
            }
        }
    }

    override fun onResume() {
        super.onResume()
        if (attachedAudioUri != null) {
            if (exoPlayer == null) {
                initializeExoPlayer(attachedAudioUri!!, playWhenReady)
            } else {
                exoPlayer?.seekTo(playbackPosition)
                if (playWhenReady && exoPlayer?.playbackState != Player.STATE_ENDED) {
                    exoPlayer?.play()
                }
            }
            updatePlayerUI()
        }
    }

    private fun releasePlayer() {
        if (::runnableUpdateSeekBar.isInitialized) seekBarUpdateHandler.removeCallbacks(runnableUpdateSeekBar)
        try {
            exoPlayer?.release()
        } catch (e: Exception) {
            Log.e(TAG, getString(R.string.log_error_releasing_exoplayer), e)
        }
        exoPlayer = null
    }

    override fun onDestroyView() {
        super.onDestroyView()
        waveformGenerationJob?.cancel()
        releasePlayer()
        currentToast?.cancel()
        _binding = null
    }

    override fun onDetach() {
        super.onDetach()
        listener = null
    }

    fun getAttachedAudioUri(): Uri? = attachedAudioUri
    fun getAttachedAudioOriginalName(): String? = attachedAudioOriginalName

    fun resetState() {
        deleteAttachedAudio()
    }

    private fun showSafeToast(message: String, duration: Int = Toast.LENGTH_SHORT) {
        if(isAdded && context != null) {
            currentToast?.cancel()
            currentToast = Toast.makeText(requireContext(), message, duration)
            currentToast?.show()
        }
    }

    private fun showAlertDialog(title: String, message: String) {
        if (!isAdded) return
        AlertDialog.Builder(requireContext())
            .setTitle(title)
            .setMessage(message)
            .setPositiveButton(getString(R.string.dialog_ok), null)
            .show()
    }

    override fun onWaveformSeek(progressRatio: Float) {
        if (!isAdded || exoPlayer == null || (exoPlayer?.duration ?: 0L) <= 0L || _binding == null) {
            return
        }

        val duration = exoPlayer!!.duration
        val newPosition = (progressRatio * duration).toLong()

        try {
            exoPlayer?.seekTo(newPosition)
            waveformView.updatePlaybackIndicator(newPosition, duration)
            binding.seekBarAttachedAudio.progress = newPosition.toInt()
            updatePlayerTimerDisplay()
        } catch (e: IllegalStateException) {
            Log.e(TAG, getString(R.string.log_illegalstateexception_waveform_seek, e.message.toString()), e)
        }
    }
}


===== Archivo: app\src\main\java\com\example\mexicoparanormal\AudioRecordingService.kt =====


package com.example.mexicoparanormal

import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.Service
import android.content.Context
import android.content.Intent
import android.media.AudioFormat
import android.media.AudioRecord
import android.media.MediaRecorder
import android.os.Build
import android.os.IBinder
import android.util.Log
import androidx.core.app.NotificationCompat
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.cancel
import kotlinx.coroutines.launch
import java.io.File
import java.io.FileOutputStream
import java.io.IOException
import java.nio.ByteBuffer
import java.nio.ByteOrder

class AudioRecordingService : Service() {

    private var audioRecord: AudioRecord? = null
    private var isRecording = false
    private var recordingJob: Job? = null
    private val serviceScope = CoroutineScope(Dispatchers.IO)

    private lateinit var notificationManager: NotificationManager

    companion object {
        private const val LOG_TAG = "AudioRecordingService"
        private const val NOTIFICATION_CHANNEL_ID = "AudioRecordingChannel"
        private const val NOTIFICATION_ID = 101

        // Parámetros de audio (ajustar según tus necesidades)
        private const val SAMPLE_RATE = 44100 // Hz
        private const val CHANNEL_CONFIG = AudioFormat.CHANNEL_IN_MONO
        private const val AUDIO_FORMAT = AudioFormat.ENCODING_PCM_16BIT

        // Acciones para Intents
        const val ACTION_START_RECORDING = "com.example.mexicoparanormal.START_RECORDING"
        const val ACTION_STOP_RECORDING = "com.example.mexicoparanormal.STOP_RECORDING"
        const val EXTRA_FILE_PATH = "file_path"
    }

    override fun onCreate() {
        super.onCreate()
        Log.d(LOG_TAG, "Servicio de grabación de audio creado.")
        notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        createNotificationChannel()
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        Log.d(LOG_TAG, "onStartCommand: ${intent?.action}")
        when (intent?.action) {
            ACTION_START_RECORDING -> {
                val filePath = intent.getStringExtra(EXTRA_FILE_PATH)
                if (filePath != null) {
                    startRecording(filePath)
                } else {
                    Log.e(LOG_TAG, "Ruta de archivo no proporcionada para iniciar grabación.")
                    stopSelf()
                }
            }
            ACTION_STOP_RECORDING -> {
                stopRecording()
            }
        }
        return START_NOT_STICKY // El servicio no se reinicia si el sistema lo mata.
    }

    override fun onDestroy() {
        super.onDestroy()
        stopRecording() // Asegurarse de detener la grabación al destruir el servicio
        serviceScope.cancel() // Cancelar todas las corrutinas
        Log.d(LOG_TAG, "Servicio de grabación de audio destruido.")
    }

    override fun onBind(intent: Intent?): IBinder? {
        return null // Este servicio no se enlaza con componentes, es un servicio iniciado.
    }

    private fun createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val serviceChannel = NotificationChannel(
                NOTIFICATION_CHANNEL_ID,
                "Grabación de Audio en Segundo Plano",
                NotificationManager.IMPORTANCE_LOW
            )
            notificationManager.createNotificationChannel(serviceChannel)
        }
    }

    private fun getNotification(): Notification {
        // En un escenario real, deberías tener un PendingIntent para abrir tu actividad
        // principal cuando se toca la notificación.
        val notificationIntent = Intent(this, RecordAudioFragment::class.java) // O tu actividad principal
        val pendingIntent = android.app.PendingIntent.getActivity(
            this,
            0,
            notificationIntent,
            android.app.PendingIntent.FLAG_IMMUTABLE
        )

        return NotificationCompat.Builder(this, NOTIFICATION_CHANNEL_ID)
            .setContentTitle("Grabando Audio")
            .setContentText("El audio se está grabando en segundo plano.")
            .setSmallIcon(R.drawable.ic_audio_waves) // Asegúrate de tener este ícono o uno similar
            .setContentIntent(pendingIntent)
            .setOngoing(true) // Hace que la notificación no se pueda descartar
            .build()
    }

    private fun startRecording(filePath: String) {
        if (isRecording) {
            Log.d(LOG_TAG, "Ya se está grabando.")
            return
        }

        val minBufferSize = AudioRecord.getMinBufferSize(SAMPLE_RATE, CHANNEL_CONFIG, AUDIO_FORMAT)
        if (minBufferSize == AudioRecord.ERROR_BAD_VALUE || minBufferSize == AudioRecord.ERROR) {
            Log.e(LOG_TAG, "Parámetros de audio no válidos o error al obtener el tamaño mínimo del buffer.")
            return
        }

        try {
            audioRecord = AudioRecord(
                MediaRecorder.AudioSource.MIC,
                SAMPLE_RATE,
                CHANNEL_CONFIG,
                AUDIO_FORMAT,
                minBufferSize
            )

            if (audioRecord?.state != AudioRecord.STATE_INITIALIZED) {
                Log.e(LOG_TAG, "AudioRecord no se pudo inicializar. Verifique permisos o hardware.")
                return
            }

            // Iniciar el servicio en primer plano para evitar que Android lo mate
            startForeground(NOTIFICATION_ID, getNotification())

            isRecording = true
            audioRecord?.startRecording()
            Log.d(LOG_TAG, "Grabación iniciada en: $filePath")

            recordingJob = serviceScope.launch {
                val buffer = ByteArray(minBufferSize)
                var fos: FileOutputStream? = null
                try {
                    val outputFile = File(filePath)
                    if (!outputFile.exists()) {
                        outputFile.createNewFile()
                    }
                    fos = FileOutputStream(outputFile)

                    while (isRecording) {
                        val bytesRead = audioRecord?.read(buffer, 0, buffer.size) ?: 0
                        if (bytesRead > 0) {
                            fos.write(buffer, 0, bytesRead)
                            // Aquí podrías enviar los datos al WaveformView a través de un Broadcast
                            // o una interfaz si fuera necesario actualizarlo en tiempo real.
                        }
                    }
                } catch (e: IOException) {
                    Log.e(LOG_TAG, "Error de escritura de archivo durante la grabación: ${e.message}")
                } finally {
                    fos?.close()
                    Log.d(LOG_TAG, "Archivo de grabación cerrado.")
                }
            }
        } catch (e: SecurityException) {
            Log.e(LOG_TAG, "Permiso de micrófono denegado: ${e.message}")
            stopSelf() // Detener el servicio si no hay permiso
        } catch (e: Exception) {
            Log.e(LOG_TAG, "Error inesperado al iniciar la grabación: ${e.message}")
            stopSelf()
        }
    }

    private fun stopRecording() {
        if (!isRecording) {
            Log.d(LOG_TAG, "No hay grabación activa para detener.")
            return
        }
        isRecording = false
        recordingJob?.cancel() // Cancelar la corrutina de grabación
        audioRecord?.apply {
            if (state == AudioRecord.STATE_INITIALIZED) {
                stop()
                release()
            }
        }
        audioRecord = null
        stopForeground(true) // Eliminar la notificación del servicio en primer plano
        Log.d(LOG_TAG, "Grabación detenida.")
        stopSelf() // Detener el servicio completamente
    }
}


===== Archivo: app\src\main\java\com\example\mexicoparanormal\DashboardItem.kt =====


package com.example.mexicoparanormal

import androidx.annotation.DrawableRes

data class DashboardItem(
    @DrawableRes val iconResId: Int,
    val title: String
)


===== Archivo: app\src\main\java\com\example\mexicoparanormal\DialogCustomDatePicker.kt =====


package com.example.mexicoparanormal

import android.app.AlertDialog
import android.app.Dialog
import android.content.Context
import android.os.Bundle
import android.util.Log
import android.widget.Button
import android.widget.NumberPicker
import android.widget.TextView
import androidx.fragment.app.DialogFragment
import java.util.*

class DialogCustomDatePicker : DialogFragment() {

    interface OnDateSelectedListener {
        fun onDateSelected(day: Int, month: Int, year: Int)
    }

    private var listener: OnDateSelectedListener? = null
    private var initialDay: Int = 0
    private var initialMonth: Int = 0 // 0-11 (Enero es 0)
    private var initialYear: Int = 0
    private var minYearArg: Int = 1500 // Año mínimo por defecto
    private var maxYearArg: Int = Calendar.getInstance().get(Calendar.YEAR) // Año máximo por defecto (año actual)
    private var dialogTitle: String? = null

    companion object {
        private const val ARG_INITIAL_DAY = "initial_day"
        private const val ARG_INITIAL_MONTH = "initial_month"
        private const val ARG_INITIAL_YEAR = "initial_year"
        private const val ARG_MIN_YEAR = "min_year"
        private const val ARG_MAX_YEAR = "max_year"
        private const val ARG_DIALOG_TITLE = "dialog_title"
        private const val TAG = "DialogCustomDatePicker" // Etiqueta para logs

        /**
         * Crea una nueva instancia de DialogCustomDatePicker.
         *
         * @param initialDay El día inicial a mostrar (1-31).
         * @param initialMonth El mes inicial a mostrar (0-11, donde 0 es Enero).
         * @param initialYear El año inicial a mostrar.
         * @param minYear El año mínimo seleccionable.
         * @param maxYear El año máximo seleccionable.
         * @param title Un título opcional para el diálogo.
         * @return Una nueva instancia de DialogCustomDatePicker.
         */
        fun newInstance(
            initialDay: Int,
            initialMonth: Int, // 0-11
            initialYear: Int,
            minYear: Int,
            maxYear: Int = Calendar.getInstance().get(Calendar.YEAR), // Año máximo por defecto es el actual
            title: String? = null
        ): DialogCustomDatePicker {
            val fragment = DialogCustomDatePicker()
            val args = Bundle().apply {
                putInt(ARG_INITIAL_DAY, initialDay)
                putInt(ARG_INITIAL_MONTH, initialMonth)
                putInt(ARG_INITIAL_YEAR, initialYear)
                putInt(ARG_MIN_YEAR, minYear)
                putInt(ARG_MAX_YEAR, maxYear)
                title?.let { putString(ARG_DIALOG_TITLE, it) }
            }
            fragment.arguments = args
            return fragment
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        arguments?.let {
            val cal = Calendar.getInstance()
            initialDay = it.getInt(ARG_INITIAL_DAY, cal.get(Calendar.DAY_OF_MONTH))
            initialMonth = it.getInt(ARG_INITIAL_MONTH, cal.get(Calendar.MONTH)) // Mes es 0-11
            initialYear = it.getInt(ARG_INITIAL_YEAR, cal.get(Calendar.YEAR))
            minYearArg = it.getInt(ARG_MIN_YEAR)
            maxYearArg = it.getInt(ARG_MAX_YEAR, cal.get(Calendar.YEAR)) // Asegurar que maxYear tenga un valor por defecto
            dialogTitle = it.getString(ARG_DIALOG_TITLE)
        }
        Log.d(TAG, "onCreate: initialDay=$initialDay, initialMonth=$initialMonth, initialYear=$initialYear, minYear=$minYearArg, maxYear=$maxYearArg, title=$dialogTitle")
    }

    override fun onAttach(context: Context) {
        super.onAttach(context)
        listener = targetFragment as? OnDateSelectedListener ?: context as? OnDateSelectedListener
        if (listener == null) {
            throw RuntimeException(getString(R.string.error_listener_not_implemented_datepicker, context.toString()))
        }
    }

    override fun onDetach() {
        super.onDetach()
        listener = null
    }

    override fun onCreateDialog(savedInstanceState: Bundle?): Dialog {
        val builder = AlertDialog.Builder(requireActivity())
        val view = layoutInflater.inflate(R.layout.dialog_custom_date_picker, null)

        val dialogTitleTextView: TextView = view.findViewById(R.id.dialogTitleTextView)
        val yearPicker: NumberPicker = view.findViewById(R.id.numberPickerYear)
        val monthPicker: NumberPicker = view.findViewById(R.id.numberPickerMonth)
        val dayPicker: NumberPicker = view.findViewById(R.id.numberPickerDay)
        val buttonCancel: Button = view.findViewById(R.id.buttonCancel)
        val buttonAccept: Button = view.findViewById(R.id.buttonAccept)

        // Establecer título del diálogo
        dialogTitleTextView.text = dialogTitle ?: getString(R.string.dialog_title_select_exact_date) // Título por defecto si es nulo

        val calendar = Calendar.getInstance() // Para referencia de fecha actual
        val currentYear = calendar.get(Calendar.YEAR)
        val currentMonth = calendar.get(Calendar.MONTH) // 0-11
        val currentDay = calendar.get(Calendar.DAY_OF_MONTH)

        // Configurar YearPicker
        yearPicker.minValue = minYearArg
        yearPicker.maxValue = maxYearArg // Usar el maxYearArg pasado
        yearPicker.value = initialYear.coerceIn(minYearArg, maxYearArg)

        // Configurar MonthPicker
        // Ya tienes un array de meses en strings.xml (short_months), pero NumberPicker los necesita como String[]
        // Si R.array.short_months no existe, créalo o usa el siguiente:
        val months = arrayOf(
            getString(R.string.month_jan_short), getString(R.string.month_feb_short), getString(R.string.month_mar_short),
            getString(R.string.month_apr_short), getString(R.string.month_may_short), getString(R.string.month_jun_short),
            getString(R.string.month_jul_short), getString(R.string.month_aug_short), getString(R.string.month_sep_short),
            getString(R.string.month_oct_short), getString(R.string.month_nov_short), getString(R.string.month_dec_short)
        )
        monthPicker.minValue = 0 // Enero
        monthPicker.maxValue = 11 // Diciembre
        monthPicker.displayedValues = months

        // Función para actualizar los rangos de mes y día basados en el año y mes seleccionados
        fun updatePickers(selectedYear: Int, selectedMonth: Int) {
            // Actualizar rango de MonthPicker
            val maxMonthForSelectedYear = if (selectedYear == currentYear) currentMonth else 11
            monthPicker.maxValue = maxMonthForSelectedYear
            monthPicker.value = selectedMonth.coerceIn(0, maxMonthForSelectedYear) // Asegurar que el valor actual sea válido

            // Actualizar rango de DayPicker
            val tempCalendar = Calendar.getInstance().apply {
                set(Calendar.YEAR, selectedYear)
                // Usar el valor potencialmente ajustado de monthPicker.value para el cálculo de días en el mes
                set(Calendar.MONTH, monthPicker.value)
                set(Calendar.DAY_OF_MONTH, 1) // Establecer al primer día para obtener el máximo real de días
            }
            var maxDayForSelectedMonth = tempCalendar.getActualMaximum(Calendar.DAY_OF_MONTH)

            if (selectedYear == currentYear && monthPicker.value == currentMonth) {
                maxDayForSelectedMonth = currentDay // Limitar al día actual si es el mes y año actual
            }
            dayPicker.minValue = 1
            dayPicker.maxValue = maxDayForSelectedMonth
            // Ajustar el valor de dayPicker después de que su rango se haya actualizado
            dayPicker.value = dayPicker.value.coerceIn(1, maxDayForSelectedMonth)
        }

        // Configuración inicial de los pickers
        // Ajustar initialMonth basado en initialYear relativo al currentYear
        val initialMaxMonth = if (initialYear == currentYear) currentMonth else 11
        monthPicker.value = initialMonth.coerceIn(0, initialMaxMonth)

        // Llamar a updatePickers para establecer rangos iniciales y ajustar valores
        updatePickers(yearPicker.value, monthPicker.value)

        // Ajustar initialDay después de que el rango de dayPicker haya sido establecido por la primera llamada a updatePickers
        dayPicker.value = initialDay.coerceIn(1, dayPicker.maxValue)


        // Listener para cuando cambie el año o el mes
        val valueChangeListener = NumberPicker.OnValueChangeListener { _, _, _ ->
            updatePickers(yearPicker.value, monthPicker.value)
        }

        yearPicker.setOnValueChangedListener(valueChangeListener)
        monthPicker.setOnValueChangedListener(valueChangeListener)

        buttonAccept.setOnClickListener {
            val selectedDay = dayPicker.value
            val selectedMonth = monthPicker.value // Esto es 0-11
            val selectedYear = yearPicker.value
            listener?.onDateSelected(selectedDay, selectedMonth, selectedYear)
            dismiss()
        }

        buttonCancel.setOnClickListener { dismiss() }

        builder.setView(view)
        return builder.create()
    }
}


===== Archivo: app\src\main\java\com\example\mexicoparanormal\EditProfileActivity.kt =====


package com.example.mexicoparanormal

import android.content.Intent // NUEVO: Para Intent
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.graphics.Matrix
import androidx.exifinterface.media.ExifInterface
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.util.Log
import android.widget.ArrayAdapter
import android.widget.Toast
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import com.bumptech.glide.Glide
import com.example.mexicoparanormal.databinding.ActivityEditProfileBinding
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.firestore.FirebaseFirestore
import com.cloudinary.android.MediaManager
import com.cloudinary.android.callback.ErrorInfo
import com.cloudinary.android.callback.UploadCallback
import java.util.HashMap
import android.view.View
import androidx.activity.OnBackPressedCallback
import java.io.ByteArrayOutputStream
import java.io.InputStream
import java.io.IOException
import java.io.FileNotFoundException
import java.util.Locale
import kotlin.math.roundToInt
import androidx.core.net.toUri
import androidx.core.graphics.scale

class EditProfileActivity : AppCompatActivity() {

    private lateinit var binding: ActivityEditProfileBinding
    private lateinit var auth: FirebaseAuth
    private lateinit var firestore: FirebaseFirestore
    private var selectedImageUri: Uri? = null
    private lateinit var locationsArray: Array<String>
    private var originalUsername: String? = null
    private var isUsernameInitiallyEmptyOrNull: Boolean = true

    private var isFirstTimeSetup: Boolean = false
    private var hasSavedUsernameDuringFirstTime: Boolean = false
    private var isSubmitting: Boolean = false

    private var selectedLatitude: Double? = null
    private var selectedLongitude: Double? = null
    private var selectedCityName: String? = null

    private val pickImageResultLauncher = registerForActivityResult(
        ActivityResultContracts.GetContent()
    ) { uri: Uri? ->
        if (uri != null) {
            selectedImageUri = uri
            Glide.with(this)
                .load(uri)
                .circleCrop()
                .into(binding.imageProfilePicture)
            Toast.makeText(this, getString(R.string.image_selection_successful), Toast.LENGTH_SHORT).show()
        } else {
            Toast.makeText(this, getString(R.string.image_selection_cancelled), Toast.LENGTH_SHORT).show()
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityEditProfileBinding.inflate(layoutInflater)
        setContentView(binding.root)

        isFirstTimeSetup = intent.getBooleanExtra("IS_FIRST_TIME_SETUP", false)
        hasSavedUsernameDuringFirstTime = savedInstanceState?.getBoolean("hasSavedUsernameDuringFirstTime", false) ?: false

        auth = FirebaseAuth.getInstance()
        firestore = FirebaseFirestore.getInstance()
        locationsArray = resources.getStringArray(R.array.locations_array)

        setupLocationSpinner()

        binding.btnBackEditProfile.setOnClickListener { handleBackPressedLogic() }
        binding.btnCancelEdit.setOnClickListener { handleCancelOrFinish() }
        binding.btnSaveProfile.setOnClickListener { validateAndSaveProfileChanges() }
        binding.profilePictureContainer.setOnClickListener { selectProfilePicture() }

        if (savedInstanceState != null) {
            onRestoreInstanceState(savedInstanceState)
        }
        loadUserProfileData()

        onBackPressedDispatcher.addCallback(this, object : OnBackPressedCallback(true) {
            override fun handleOnBackPressed() {
                handleBackPressedLogic()
            }
        })
    }

    private fun handleBackPressedLogic() {
        if (isFirstTimeSetup && !hasSavedUsernameDuringFirstTime) {
            Toast.makeText(this, getString(R.string.username_setup_must_complete_username), Toast.LENGTH_LONG).show()
        } else if (isFirstTimeSetup && hasSavedUsernameDuringFirstTime) {
            navigateToMainActivity()
        }
        else {
            finish()
        }
    }

    private fun handleCancelOrFinish() {
        if (isFirstTimeSetup && hasSavedUsernameDuringFirstTime) {
            navigateToMainActivity()
        } else if (!isFirstTimeSetup) { // Solo finaliza si no es setup inicial, o si ya se completó el username en setup
            finish()
        }
        // Si es isFirstTimeSetup y !hasSavedUsernameDuringFirstTime, el botón cancelar está oculto.
    }

    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        outState.putBoolean("hasSavedUsernameDuringFirstTime", hasSavedUsernameDuringFirstTime)
        selectedImageUri?.let { outState.putString("selectedImageUri", it.toString()) }
        selectedLatitude?.let { outState.putDouble("selectedLatitude", it) }
        selectedLongitude?.let { outState.putDouble("selectedLongitude", it) }
        outState.putString("selectedCityName", selectedCityName)
    }

    override fun onRestoreInstanceState(savedInstanceState: Bundle) {
        super.onRestoreInstanceState(savedInstanceState)
        hasSavedUsernameDuringFirstTime = savedInstanceState.getBoolean("hasSavedUsernameDuringFirstTime", false)
        selectedImageUri = savedInstanceState.getString("selectedImageUri")?.toUri()
        if(savedInstanceState.containsKey("selectedLatitude")) selectedLatitude = savedInstanceState.getDouble("selectedLatitude")
        if(savedInstanceState.containsKey("selectedLongitude")) selectedLongitude = savedInstanceState.getDouble("selectedLongitude")
        selectedCityName = savedInstanceState.getString("selectedCityName")

        if (selectedImageUri != null) {
            Glide.with(this).load(selectedImageUri).circleCrop().into(binding.imageProfilePicture)
        }
    }

    private fun setupLocationSpinner() {
        val locationAdapter = ArrayAdapter(this, R.layout.spinner_item, locationsArray)
        locationAdapter.setDropDownViewResource(R.layout.spinner_dropdown_item)
        binding.spinnerLocationEditProfile.adapter = locationAdapter
    }

    private fun selectProfilePicture() {
        pickImageResultLauncher.launch("image/*")
    }

    private fun loadUserProfileData() {
        val currentUser = auth.currentUser
        if (currentUser != null) {
            setUiEnabled(false) // Deshabilitar UI mientras carga
            binding.textViewUsernamePermanentInfo.visibility = View.GONE // Ocultar inicialmente

            firestore.collection(getString(R.string.firestore_collection_users)).document(currentUser.uid).get()
                .addOnSuccessListener { document ->
                    setUiEnabled(true) // Habilitar UI después de cargar
                    if (document.exists()) {
                        originalUsername = document.getString(getString(R.string.firestore_field_username))
                        binding.editTextUsername.setText(originalUsername)
                        isUsernameInitiallyEmptyOrNull = originalUsername.isNullOrEmpty()

                        if (!isUsernameInitiallyEmptyOrNull) {
                            binding.editTextUsername.isEnabled = false
                            binding.editTextUsername.isFocusable = false
                            binding.editTextUsername.isFocusableInTouchMode = false
                            binding.textViewUsernamePermanentInfo.text = getString(R.string.username_already_set_info)
                            binding.textViewUsernamePermanentInfo.visibility = View.VISIBLE
                            binding.btnCancelEdit.visibility = View.VISIBLE
                            hasSavedUsernameDuringFirstTime = true // Asumir que si ya tiene username, el setup inicial (si lo hubo) se completó
                        } else {
                            binding.editTextUsername.isEnabled = true
                            binding.editTextUsername.isFocusableInTouchMode = true
                            if (isFirstTimeSetup) { // Y es la primera configuración
                                binding.textViewUsernamePermanentInfo.text = getString(R.string.username_setup_info)
                                binding.textViewUsernamePermanentInfo.visibility = View.VISIBLE
                                binding.btnCancelEdit.visibility = View.GONE
                            } else { // No es setup inicial, pero no tiene username
                                binding.textViewUsernamePermanentInfo.visibility = View.GONE
                                binding.btnCancelEdit.visibility = View.VISIBLE
                            }
                        }
                        // ... (lógica para location y profileImageUrl)
                        val locationFromFirestore = document.getString(getString(R.string.firestore_field_location))
                        if (!locationFromFirestore.isNullOrEmpty()) {
                            val position = locationsArray.indexOf(locationFromFirestore)
                            if (position >= 0) {
                                binding.spinnerLocationEditProfile.setSelection(position)
                            } else {
                                binding.spinnerLocationEditProfile.setSelection(0)
                            }
                        } else {
                            binding.spinnerLocationEditProfile.setSelection(0)
                        }

                        val profileImageUrl = document.getString(getString(R.string.firestore_field_profileImageUrl))
                        if (!profileImageUrl.isNullOrEmpty()) {
                            Glide.with(this@EditProfileActivity)
                                .load(profileImageUrl)
                                .circleCrop()
                                .error(R.drawable.ic_perfil)
                                .into(binding.imageProfilePicture)
                        } else {
                            binding.imageProfilePicture.setImageResource(R.drawable.ic_perfil)
                        }

                    } else { // Documento no existe
                        isUsernameInitiallyEmptyOrNull = true
                        binding.editTextUsername.isEnabled = true
                        binding.editTextUsername.isFocusableInTouchMode = true
                        if (isFirstTimeSetup) {
                            binding.textViewUsernamePermanentInfo.text = getString(R.string.username_setup_info)
                            binding.textViewUsernamePermanentInfo.visibility = View.VISIBLE
                            binding.btnCancelEdit.visibility = View.GONE
                        } else {
                            binding.textViewUsernamePermanentInfo.visibility = View.GONE
                            binding.btnCancelEdit.visibility = View.VISIBLE
                        }
                        binding.imageProfilePicture.setImageResource(R.drawable.ic_perfil)
                        binding.spinnerLocationEditProfile.setSelection(0)
                    }
                }
                .addOnFailureListener { e ->
                    setUiEnabled(true) // Habilitar UI en caso de error
                    Log.e(TAG_EDIT_PROFILE, getString(R.string.log_error_loading_user_data), e)
                    Toast.makeText(this, getString(R.string.error_loading_data_generic, e.message), Toast.LENGTH_SHORT).show()
                    isUsernameInitiallyEmptyOrNull = true
                    binding.editTextUsername.isEnabled = true
                    if (isFirstTimeSetup) {
                        binding.textViewUsernamePermanentInfo.text = getString(R.string.username_setup_info)
                        binding.textViewUsernamePermanentInfo.visibility = View.VISIBLE
                        binding.btnCancelEdit.visibility = View.GONE
                    } else {
                        binding.textViewUsernamePermanentInfo.visibility = View.GONE
                        binding.btnCancelEdit.visibility = View.VISIBLE
                    }
                }
        } else {
            Toast.makeText(this, getString(R.string.error_user_not_authenticated_profile), Toast.LENGTH_SHORT).show()
            finish()
        }
    }

    private fun validateAndSaveProfileChanges() {
        if (isSubmitting) return
        setUiEnabled(false) // Deshabilitar UI al iniciar proceso
        isSubmitting = true

        val newUsername = binding.editTextUsername.text.toString().trim()
        val selectedLocationFromSpinner = binding.spinnerLocationEditProfile.selectedItem.toString()

        if (isUsernameInitiallyEmptyOrNull && newUsername.isEmpty()) {
            binding.textInputLayoutUsername.error = getString(R.string.username_cannot_be_empty_on_first_set)
            setUiEnabled(true); isSubmitting = false; return
        } else {
            binding.textInputLayoutUsername.error = null
        }

        if (isUsernameInitiallyEmptyOrNull && newUsername.isNotEmpty()) {
            if (newUsername.length < 3 || newUsername.length > 20) {
                binding.textInputLayoutUsername.error = getString(R.string.error_username_length)
                setUiEnabled(true); isSubmitting = false; return
            }
            if (!newUsername.matches(Regex("^[a-zA-Z0-9_ñÑ]+$"))) { // Permitir ñÑ
                binding.textInputLayoutUsername.error = getString(R.string.error_username_invalid_chars)
                setUiEnabled(true); isSubmitting = false; return
            }
        }

        val locationToSave = if (selectedLocationFromSpinner != locationsArray[0] && selectedLocationFromSpinner != getString(R.string.location_unknown_spinner_value)) {
            selectedLocationFromSpinner
        } else {
            ""
        }

        val currentUser = auth.currentUser ?: run {
            setUiEnabled(true); isSubmitting = false; return
        }
        val userId = currentUser.uid

        if (isUsernameInitiallyEmptyOrNull && newUsername.isNotEmpty()) {
            checkUsernameUniquenessAndProceed(userId, newUsername, locationToSave, selectedImageUri)
        } else {
            val usernameToSaveFinal = if (!isUsernameInitiallyEmptyOrNull) originalUsername ?: "" else newUsername
            proceedWithSaving(userId, usernameToSaveFinal, locationToSave, selectedImageUri)
        }
    }

    private fun checkUsernameUniquenessAndProceed(userId: String, newUsername: String, location: String, imageUri: Uri?) {
        val normalizedUsername = newUsername.lowercase(Locale.ROOT)
        firestore.collection(getString(R.string.firestore_collection_users))
            .whereEqualTo(getString(R.string.firestore_field_usernameNormalized), normalizedUsername)
            .limit(1)
            .get()
            .addOnSuccessListener { documents ->
                if (documents.isEmpty) {
                    showPermanentUsernameConfirmationDialog(userId, newUsername, location, imageUri)
                } else {
                    binding.textInputLayoutUsername.error = getString(R.string.error_username_taken)
                    setUiEnabled(true); isSubmitting = false
                }
            }
            .addOnFailureListener { e ->
                Log.e(TAG_EDIT_PROFILE, getString(R.string.log_error_verifying_username_uniqueness), e)
                Toast.makeText(this, getString(R.string.error_verifying_username, e.message), Toast.LENGTH_SHORT).show()
                setUiEnabled(true); isSubmitting = false
            }
    }

    private fun showPermanentUsernameConfirmationDialog(userId: String, username: String, location: String, imageUri: Uri?) {
        AlertDialog.Builder(this)
            .setTitle(getString(R.string.username_permanent_dialog_title))
            .setMessage(getString(R.string.username_permanent_dialog_message, username))
            .setPositiveButton(getString(R.string.accept)) { _, _ ->
                proceedWithSaving(userId, username, location, imageUri)
            }
            .setNegativeButton(getString(R.string.cancelar)) { _, _ ->
                setUiEnabled(true); isSubmitting = false
            }
            .setCancelable(false)
            .show()
    }

    private fun proceedWithSaving(userId: String, username: String, location: String, imageUri: Uri?) {
        if (imageUri == null && !isSubmitting) { // Solo si NO hay imagen que subir y no se está subiendo
            setUiEnabled(false) // Asegurarse de deshabilitar la UI para la escritura en Firestore
            isSubmitting = true
        }
        // Si hay imageUri, uploadImageToCloudinary se encargará del estado de isSubmitting y setUiEnabled

        if (imageUri != null) {
            uploadImageToCloudinary(userId, imageUri) { imageUrl -> // El callback de onSuccess/onError de Cloudinary reactivará la UI
                updateUserProfileInFirestore(userId, username, location, imageUrl)
            }
        } else {
            updateUserProfileInFirestore(userId, username, location, null)
        }
    }

    private fun updateUserProfileInFirestore(userId: String, username: String, location: String, newImageUrl: String?) {
        val updates = hashMapOf<String, Any>()
        val usernameWasInitiallyEmpty = isUsernameInitiallyEmptyOrNull
        val usernameIsBeingSetForTheFirstTime = usernameWasInitiallyEmpty && username.isNotEmpty()

        if (usernameIsBeingSetForTheFirstTime) {
            updates[getString(R.string.firestore_field_username)] = username
            updates[getString(R.string.firestore_field_usernameNormalized)] = username.lowercase(Locale.ROOT)
        } else if (!usernameWasInitiallyEmpty && originalUsername != null && originalUsername!!.isNotEmpty()) {
            updates[getString(R.string.firestore_field_username)] = originalUsername!!
            updates[getString(R.string.firestore_field_usernameNormalized)] = originalUsername!!.lowercase(Locale.ROOT)
        }

        updates[getString(R.string.firestore_field_location)] = location
        newImageUrl?.let {
            updates[getString(R.string.firestore_field_profileImageUrl)] = it
        }

        if (updates.isEmpty()) {
            Toast.makeText(this, getString(R.string.info_no_changes_to_save), Toast.LENGTH_SHORT).show()
            setUiEnabled(true); isSubmitting = false; return
        }

        firestore.collection(getString(R.string.firestore_collection_users)).document(userId).update(updates)
            .addOnSuccessListener {
                Toast.makeText(this, getString(R.string.success_profile_updated), Toast.LENGTH_SHORT).show()
                if (isFirstTimeSetup && usernameIsBeingSetForTheFirstTime) {
                    hasSavedUsernameDuringFirstTime = true
                    // En la Opción B, después de guardar el username por primera vez, navegamos a MainActivity
                    navigateToMainActivity()
                } else {
                    setUiEnabled(true)
                    isSubmitting = false
                    finish() // Finalizar si no era el setup inicial del username
                }
            }
            .addOnFailureListener { e ->
                Toast.makeText(this, getString(R.string.error_saving_profile_firestore, e.message), Toast.LENGTH_SHORT).show()
                setUiEnabled(true); isSubmitting = false
            }
    }

    private fun navigateToMainActivity() {
        val intent = Intent(this, MainActivity::class.java).apply {
            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
            putExtra("PROFILE_SETUP_COMPLETED", true) // Flag opcional para MainActivity
        }
        startActivity(intent)
        finish() // Finalizar EditProfileActivity
    }

    private fun setUiEnabled(enabled: Boolean) {
        binding.btnSaveProfile.isEnabled = enabled
        binding.editTextUsername.isEnabled = enabled && isUsernameInitiallyEmptyOrNull && !hasSavedUsernameDuringFirstTime
        binding.spinnerLocationEditProfile.isEnabled = enabled
        binding.profilePictureContainer.isClickable = enabled
        binding.btnBackEditProfile.isEnabled = !(isFirstTimeSetup && !hasSavedUsernameDuringFirstTime && enabled)

        if (isFirstTimeSetup && !hasSavedUsernameDuringFirstTime) {
            binding.btnCancelEdit.visibility = View.GONE
        } else {
            binding.btnCancelEdit.visibility = View.VISIBLE
            binding.btnCancelEdit.isEnabled = enabled
        }
    }

    // ... (funciones resizeBitmapKeepingAspectRatio, compressImageToWebP, uploadImageToCloudinary) ...
    // Mantén estas funciones como las tenías, asegurándote de manejar el UI (setUiEnabled(true); isSubmitting = false;)
    // en los callbacks de error de uploadImageToCloudinary si la subida de imagen falla ANTES de llamar a updateUserProfileInFirestore.

    private fun resizeBitmapKeepingAspectRatio(bitmap: Bitmap, maxSideLength: Int): Bitmap {
        val currentWidth = bitmap.width
        val currentHeight = bitmap.height
        if (currentWidth <= maxSideLength && currentHeight <= maxSideLength) {
            return bitmap
        }
        val ratio = currentWidth.toFloat() / currentHeight.toFloat()
        var newWidth: Int
        var newHeight: Int
        if (currentWidth > currentHeight) {
            newWidth = maxSideLength
            newHeight = (maxSideLength / ratio).roundToInt()
        } else {
            newHeight = maxSideLength
            newWidth = (maxSideLength * ratio).roundToInt()
        }
        if (newWidth <= 0) newWidth = 1
        if (newHeight <= 0) newHeight = 1
        return bitmap.scale(newWidth, newHeight, true) // Usar KTX
    }

    private fun compressImageToWebP(uri: Uri, quality: Int, maxSideLength: Int): ByteArray? {
        var inputStream: InputStream? = null
        var exifInputStream: InputStream? = null
        try {
            inputStream = contentResolver.openInputStream(uri) ?: throw FileNotFoundException(getString(R.string.error_inputstream_null_for_uri, uri.toString()))
            val originalBitmap = BitmapFactory.decodeStream(inputStream)
                ?: throw IOException(getString(R.string.error_failed_decode_bitmap_from_uri, uri.toString()))

            exifInputStream = contentResolver.openInputStream(uri) ?: throw FileNotFoundException(getString(R.string.error_exif_inputstream_null_for_uri, uri.toString()))
            val exif = ExifInterface(exifInputStream)
            val orientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL)

            val matrix = Matrix()
            when (orientation) {
                ExifInterface.ORIENTATION_ROTATE_90 -> matrix.postRotate(90f)
                ExifInterface.ORIENTATION_ROTATE_180 -> matrix.postRotate(180f)
                ExifInterface.ORIENTATION_ROTATE_270 -> matrix.postRotate(270f)
                ExifInterface.ORIENTATION_FLIP_HORIZONTAL -> matrix.postScale(-1f, 1f)
                ExifInterface.ORIENTATION_FLIP_VERTICAL -> matrix.postScale(1f, -1f)
                ExifInterface.ORIENTATION_TRANSPOSE -> { matrix.postRotate(90f); matrix.postScale(-1f, 1f) }
                ExifInterface.ORIENTATION_TRANSVERSE -> { matrix.postRotate(-90f); matrix.postScale(-1f, 1f) }
            }
            val rotatedBitmap = Bitmap.createBitmap(originalBitmap, 0, 0, originalBitmap.width, originalBitmap.height, matrix, true)
            if (originalBitmap != rotatedBitmap) {
                originalBitmap.recycle()
            }

            val resizedBitmap = resizeBitmapKeepingAspectRatio(rotatedBitmap, maxSideLength)
            if (rotatedBitmap != resizedBitmap) {
                rotatedBitmap.recycle()
            }

            ByteArrayOutputStream().use { outputStream ->
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
                    resizedBitmap.compress(Bitmap.CompressFormat.WEBP_LOSSY, quality, outputStream)
                } else {
                    @Suppress("DEPRECATION")
                    resizedBitmap.compress(Bitmap.CompressFormat.WEBP, quality, outputStream)
                }
                resizedBitmap.recycle()
                return outputStream.toByteArray()
            }
        } catch (fnfe: FileNotFoundException) {
            Log.e(TAG_EDIT_PROFILE, getString(R.string.log_error_file_not_found_compress_webp, uri.toString()), fnfe)
            Toast.makeText(this, getString(R.string.error_file_not_found_for_compression, uri.lastPathSegment ?: getString(R.string.selected_image_default_name)), Toast.LENGTH_SHORT).show()
            return null
        } catch (ioe: IOException) {
            Log.e(TAG_EDIT_PROFILE, getString(R.string.log_error_io_compress_webp, uri.toString()), ioe)
            Toast.makeText(this, getString(R.string.error_io_compressing_image), Toast.LENGTH_SHORT).show()
            return null
        } catch (e: Exception) {
            Log.e(TAG_EDIT_PROFILE, getString(R.string.log_error_unexpected_compress_webp, uri.toString()), e)
            Toast.makeText(this, getString(R.string.error_unknown_compressing_image), Toast.LENGTH_SHORT).show()
            return null
        } finally {
            try {
                inputStream?.close()
                exifInputStream?.close()
            } catch (ioe: IOException) {
                Log.e(TAG_EDIT_PROFILE, getString(R.string.log_error_closing_streams_compress_webp_uri, uri.toString()), ioe)
            }
        }
    }

    private fun uploadImageToCloudinary(userId: String, imageUri: Uri, onSuccess: (String) -> Unit) {
        val imageBytes = compressImageToWebP(imageUri, 70, 640) ?: run {
            Toast.makeText(this@EditProfileActivity, getString(R.string.error_compressing_image_generic), Toast.LENGTH_SHORT).show()
            setUiEnabled(true)
            isSubmitting = false
            // Es crucial manejar el error aquí para que no se quede "colgado" esperando la URL de la imagen
            // Llamar a updateUserProfileInFirestore con null para newImageUrl
            val usernameToSave = if (isUsernameInitiallyEmptyOrNull) binding.editTextUsername.text.toString().trim() else originalUsername ?: ""
            val locationToSave = if (binding.spinnerLocationEditProfile.selectedItemPosition > 0 && binding.spinnerLocationEditProfile.selectedItem.toString() != getString(R.string.location_unknown_spinner_value) ) binding.spinnerLocationEditProfile.selectedItem.toString() else ""
            updateUserProfileInFirestore(userId, usernameToSave, locationToSave, null)
            return
        }

        val options: HashMap<String, Any> = HashMap()
        options[getString(R.string.cloudinary_option_folder)] = getString(R.string.cloudinary_folder_profile_pictures, userId)
        options[getString(R.string.cloudinary_option_public_id)] = getString(R.string.cloudinary_public_id_profile_image)
        options[getString(R.string.cloudinary_option_overwrite)] = true

        MediaManager.get().upload(imageBytes)
            .option(getString(R.string.cloudinary_option_resource_type), getString(R.string.cloudinary_resource_type_image))
            .options(options)
            .callback(object : UploadCallback {
                override fun onStart(requestId: String?) { /* No-op */ }
                override fun onProgress(requestId: String?, bytes: Long, totalBytes: Long) { /* No-op */ }
                override fun onSuccess(requestId: String?, resultData: MutableMap<Any?, Any?>?) {
                    val imageUrl = resultData?.get(getString(R.string.cloudinary_result_secure_url)) as? String
                    if (imageUrl != null) {
                        onSuccess(imageUrl) // Esto llamará a updateUserProfileInFirestore con la URL
                    } else {
                        Toast.makeText(this@EditProfileActivity, getString(R.string.error_getting_cloudinary_url), Toast.LENGTH_SHORT).show()
                        val usernameToSave = if (isUsernameInitiallyEmptyOrNull) binding.editTextUsername.text.toString().trim() else originalUsername ?: ""
                        val locationToSave = if (binding.spinnerLocationEditProfile.selectedItemPosition > 0 && binding.spinnerLocationEditProfile.selectedItem.toString() != getString(R.string.location_unknown_spinner_value) ) binding.spinnerLocationEditProfile.selectedItem.toString() else ""
                        updateUserProfileInFirestore(userId, usernameToSave, locationToSave, null) // Guardar sin la imagen
                    }
                }
                override fun onError(requestId: String?, error: ErrorInfo?) {
                    Toast.makeText(this@EditProfileActivity, getString(R.string.error_uploading_image_cloudinary, error?.description), Toast.LENGTH_SHORT).show()
                    val usernameToSave = if (isUsernameInitiallyEmptyOrNull) binding.editTextUsername.text.toString().trim() else originalUsername ?: ""
                    val locationToSave = if (binding.spinnerLocationEditProfile.selectedItemPosition > 0 && binding.spinnerLocationEditProfile.selectedItem.toString() != getString(R.string.location_unknown_spinner_value) ) binding.spinnerLocationEditProfile.selectedItem.toString() else ""
                    updateUserProfileInFirestore(userId, usernameToSave, locationToSave, null) // Guardar sin la imagen
                }
                override fun onReschedule(requestId: String?, error: ErrorInfo?) {
                    Toast.makeText(this@EditProfileActivity, "La subida de imagen fue re-programada. Intentando guardar sin imagen.", Toast.LENGTH_SHORT).show()
                    val usernameToSave = if (isUsernameInitiallyEmptyOrNull) binding.editTextUsername.text.toString().trim() else originalUsername ?: ""
                    val locationToSave = if (binding.spinnerLocationEditProfile.selectedItemPosition > 0 && binding.spinnerLocationEditProfile.selectedItem.toString() != getString(R.string.location_unknown_spinner_value) ) binding.spinnerLocationEditProfile.selectedItem.toString() else ""
                    updateUserProfileInFirestore(userId, usernameToSave, locationToSave, null)
                }
            })
            .dispatch()
    }

    companion object {
        private const val TAG_EDIT_PROFILE = "EditProfileActivity"
    }
}


===== Archivo: app\src\main\java\com\example\mexicoparanormal\ImageViewerActivity.kt =====


package com.example.mexicoparanormal

import android.os.Bundle
import android.util.Log
import android.view.View
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import com.bumptech.glide.Glide
import com.example.mexicoparanormal.databinding.ActivityImageViewerBinding // Asegúrate que el nombre del binding es correcto
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.firestore.FirebaseFirestore
import java.text.SimpleDateFormat
import java.util.Locale

class ImageViewerActivity : AppCompatActivity() {

    private lateinit var binding: ActivityImageViewerBinding
    private lateinit var firestore: FirebaseFirestore
    private var imageDocumentId: String? = null // O imageUrl si es lo que usas para cargar
    private var isPendingReview: Boolean = false

    companion object {
        private const val TAG = "ImageViewerActivity" // Etiqueta para logs
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityImageViewerBinding.inflate(layoutInflater) // Usa el nombre correcto de tu clase de Binding
        setContentView(binding.root)

        firestore = FirebaseFirestore.getInstance()

        imageDocumentId = intent.getStringExtra("IMAGE_ID") // O "IMAGE_URL"
        isPendingReview = intent.getBooleanExtra("IS_PENDING_REVIEW", false)

        // Asume que tienes un botón de regreso con este ID o similar
        binding.btnBackImageViewer.setOnClickListener {
            finish()
        }

        if (imageDocumentId == null) {
            Toast.makeText(this, getString(R.string.content_not_found), Toast.LENGTH_LONG).show()
            finish()
            return
        }

        setupUIForPendingStatus()
        loadImageData()
    }

    private fun setupUIForPendingStatus() {
        if (isPendingReview) {
            // Asume que tienes un TextView con este ID en tu activity_image_viewer.xml
            binding.textViewPendingReviewStatusImage.visibility = View.VISIBLE
            binding.textViewPendingReviewStatusImage.text = getString(R.string.status_pending_review_message) // Reutilizamos el string

            // Ocultar o deshabilitar elementos de interacción (ajusta a tus IDs reales)
            binding.interactionLayoutImage.visibility = View.GONE       // ID Corregido
            // ... y otros
        } else {
            binding.textViewPendingReviewStatusImage.visibility = View.GONE
            // Asegurar visibilidad de interacciones
            binding.interactionLayoutImage.visibility = View.VISIBLE   // ID Corregido
        }
    }

    private fun loadImageData() {
        val collectionPath = if (isPendingReview) getString(R.string.firestore_collection_images_pending) else getString(R.string.firestore_collection_images_approved)

        imageDocumentId?.let { id ->
            firestore.collection(collectionPath).document(id)
                .get()
                .addOnSuccessListener { document ->
                    if (document != null && document.exists()) {
                        val title = document.getString(getString(R.string.firestore_field_title)) ?: getString(R.string.title_not_available)
                        binding.imageTitleTextViewer.text = title
                        binding.screenTitleImageViewer.text = title // Actualiza también el título de la pantalla

                        val imageUrl = document.getString(getString(R.string.firestore_field_imageUrl))
                        if (!imageUrl.isNullOrEmpty()) {
                            Glide.with(this)
                                .load(imageUrl)
                                .placeholder(R.drawable.placeholder_image)
                                .error(R.drawable.placeholder_image)
                                .into(binding.imageViewerView)
                        } else {
                            binding.imageViewerView.setImageResource(R.drawable.placeholder_image) // Imagen por defecto si no hay URL
                            Toast.makeText(this, getString(R.string.error_image_url_not_found), Toast.LENGTH_SHORT).show()
                        }

                        binding.imageAuthorTextViewer.text = getString(R.string.author_format, document.getString(getString(R.string.firestore_field_authorUsername)) ?: getString(R.string.unknown_user))
                        val timestamp = document.getTimestamp(getString(R.string.firestore_field_timestamp))?.toDate()
                        if (timestamp != null) {
                            val sdf = SimpleDateFormat(getString(R.string.date_format_dd_mm_yyyy_hh_mm), Locale.getDefault())
                            binding.imageDateTextViewer.text = getString(R.string.date_format_viewer, sdf.format(timestamp))
                        } else {
                            binding.imageDateTextViewer.text = getString(R.string.date_format_viewer, getString(R.string.date_type_unknown))
                        }
                        binding.imageDescriptionTextViewer.text = document.getString(getString(R.string.firestore_field_description)) ?: ""
                        binding.imageLocationTextViewer.text = document.getString(getString(R.string.firestore_field_location)) ?: getString(R.string.location_unknown)

                    } else {
                        Log.d(TAG, getString(R.string.log_document_not_found, collectionPath, id))
                        Toast.makeText(this, getString(R.string.content_not_found), Toast.LENGTH_LONG).show()
                        finish()
                    }
                }
                .addOnFailureListener { exception ->
                    Log.e(TAG, getString(R.string.log_error_loading_image_data), exception)
                    Toast.makeText(this, getString(R.string.error_loading_content), Toast.LENGTH_LONG).show()
                    finish()
                }
        }
    }
}


===== Archivo: app\src\main\java\com\example\mexicoparanormal\MainActivity.kt =====


package com.example.mexicoparanormal

import android.annotation.SuppressLint
import android.content.Context
import android.content.Intent
import android.os.Bundle
import android.util.Log
import android.view.View
import android.view.inputmethod.EditorInfo
import android.widget.EditText
import android.widget.FrameLayout
import android.widget.LinearLayout // Importar LinearLayout
import android.widget.ProgressBar
import android.widget.TextView // Importar TextView si vas a acceder al texto de los chips
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.constraintlayout.widget.ConstraintLayout
import androidx.core.app.ActivityOptionsCompat
import androidx.credentials.Credential
import androidx.credentials.CredentialManager
import androidx.credentials.CustomCredential
import androidx.credentials.GetCredentialRequest
import androidx.credentials.exceptions.GetCredentialCancellationException
import androidx.credentials.exceptions.GetCredentialException
import androidx.lifecycle.lifecycleScope
import com.google.android.libraries.identity.googleid.GetGoogleIdOption
import com.google.android.libraries.identity.googleid.GoogleIdTokenCredential
import com.google.android.libraries.identity.googleid.GoogleIdTokenParsingException
import com.google.android.material.button.MaterialButton
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.auth.FirebaseUser
import com.google.firebase.auth.GoogleAuthProvider
import com.google.firebase.firestore.FieldValue
import com.google.firebase.firestore.FirebaseFirestore
import kotlinx.coroutines.launch

class MainActivity : AppCompatActivity() {

    private lateinit var auth: FirebaseAuth
    private lateinit var credentialManager: CredentialManager
    private lateinit var firestore: FirebaseFirestore
    private val tag = "MainActivity"

    // NUEVO: Referencias a vistas para habilitar/deshabilitar y ProgressBar
    private lateinit var mainActivityProgressBar: ProgressBar
    private lateinit var searchButton: FrameLayout
    private lateinit var editTextSearch: EditText
    private lateinit var recentContainer: ConstraintLayout
    private lateinit var favoritesContainer: ConstraintLayout
    private lateinit var placesContainer: ConstraintLayout
    private lateinit var mapContainer: ConstraintLayout
    private lateinit var chipFotos: LinearLayout // Cambiado de Chip a LinearLayout
    private lateinit var chipVideos: LinearLayout // Cambiado de Chip a LinearLayout
    private lateinit var chipRelatos: LinearLayout // Cambiado de Chip a LinearLayout
    private lateinit var categoriesChipGroup: LinearLayout // Cambiado de com.google.android.material.chip.ChipGroup a LinearLayout
    private lateinit var dashboardGrid: ConstraintLayout


    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        auth = FirebaseAuth.getInstance()
        firestore = FirebaseFirestore.getInstance()
        credentialManager = CredentialManager.create(this)

        // Inicializar vistas
        mainActivityProgressBar = findViewById(R.id.mainActivityProgressBar)
        searchButton = findViewById(R.id.touch_container)
        editTextSearch = findViewById(R.id.editTextSearch)
        recentContainer = findViewById(R.id.recent_container)
        favoritesContainer = findViewById(R.id.favorites_container)
        placesContainer = findViewById(R.id.places_container)
        mapContainer = findViewById(R.id.map_container)
        chipFotos = findViewById(R.id.custom_chip_fotos) // Corregido el ID
        chipVideos = findViewById(R.id.custom_chip_videos) // Corregido el ID
        chipRelatos = findViewById(R.id.custom_chip_relatos) // Corregido el ID
        categoriesChipGroup = findViewById(R.id.categories_chip_group) // Corregido el tipo
        dashboardGrid = findViewById(R.id.dashboard_grid)


        searchButton.setOnClickListener {
            performSearch(editTextSearch.text.toString())
        }

        editTextSearch.setOnEditorActionListener { _, actionId, _ ->
            if (actionId == EditorInfo.IME_ACTION_SEARCH) {
                performSearch(editTextSearch.text.toString())
                true
            } else {
                false
            }
        }

        listOf(recentContainer, favoritesContainer, placesContainer, mapContainer).forEach { container ->
            container.setOnClickListener {
                Toast.makeText(this, getString(R.string.accessing_section, container.contentDescription), Toast.LENGTH_SHORT).show()
            }
        }

        listOf(chipFotos, chipVideos, chipRelatos).forEach { linearLayoutChip ->
            linearLayoutChip.setOnClickListener {
                // Para obtener el texto de un LinearLayout que actúa como chip, accedemos a su TextView hijo
                val textView = linearLayoutChip.findViewById<TextView>(0) // El ID 0 no es lo ideal, aquí necesitas el ID del TextView dentro de cada custom_chip
                // Para obtener el texto, la forma más robusta es que cada LinearLayout tenga un contentDescription, o acceder a un TextView anidado si tienen IDs.
                // Como tus TextViews no tienen IDs, asumimos que son el primer TextView dentro del LinearLayout.
                val chipText = if (linearLayoutChip.childCount > 0 && linearLayoutChip.getChildAt(0) is TextView) {
                    (linearLayoutChip.getChildAt(0) as TextView).text.toString()
                } else {
                    linearLayoutChip.contentDescription?.toString() ?: "categoría desconocida"
                }
                Toast.makeText(this, getString(R.string.filtering_by, chipText), Toast.LENGTH_SHORT).show()
            }
        }
        // updateUIBasedOnLoginStatus se llamará en onStart
    }

    private fun signIn() {
        Log.d(tag, getString(R.string.log_attempting_sign_in_credential_manager))
        mainActivityProgressBar.visibility = View.VISIBLE
        setMainInteractionEnabled(false) // Deshabilitar UI mientras se loguea

        lifecycleScope.launch {
            val googleIdOption = GetGoogleIdOption.Builder()
                .setServerClientId(getString(R.string.default_web_client_id))
                .setFilterByAuthorizedAccounts(false)
                .build()

            val request = GetCredentialRequest.Builder()
                .addCredentialOption(googleIdOption)
                .build()

            try {
                val result = credentialManager.getCredential(this@MainActivity, request)
                // No ocultar ProgressBar aquí, handleSignInResult lo hará
                handleSignInResult(result.credential)
            } catch (e: GetCredentialException) {
                mainActivityProgressBar.visibility = View.GONE
                setMainInteractionEnabled(true) // Reactivar para que pueda reintentar
                Log.e(tag, getString(R.string.log_error_sign_in_credential_manager, e.message), e)
                if (e is GetCredentialCancellationException) {
                    Log.w(tag, getString(R.string.log_sign_in_cancelled_by_user))
                    Toast.makeText(this@MainActivity, getString(R.string.error_sign_in_cancelled), Toast.LENGTH_SHORT).show()
                } else {
                    Toast.makeText(this@MainActivity, getString(R.string.error_sign_in_generic, e.localizedMessage), Toast.LENGTH_LONG).show()
                }
                updateUIBasedOnLoginStatus(null) // Actualizar UI al estado de no logueado
            }
        }
    }

    private fun handleSignInResult(credential: Credential) {
        // El ProgressBar sigue visible aquí
        when (credential) {
            is GoogleIdTokenCredential -> {
                Log.d(tag, getString(R.string.log_googleidtokencredential_obtained))
                firebaseAuthWithGoogle(credential)
            }
            is CustomCredential -> {
                try {
                    val googleCredential = GoogleIdTokenCredential.createFrom(credential.data)
                    Log.d(tag, getString(R.string.log_customcredential_converted_to_google))
                    firebaseAuthWithGoogle(googleCredential)
                } catch (e: GoogleIdTokenParsingException) {
                    mainActivityProgressBar.visibility = View.GONE
                    setMainInteractionEnabled(true)
                    Log.e(tag, getString(R.string.log_error_parsing_customcredential), e)
                    Toast.makeText(this, getString(R.string.error_procesar_credencial_google), Toast.LENGTH_SHORT).show()
                    updateUIBasedOnLoginStatus(null)
                }
            }
            else -> {
                mainActivityProgressBar.visibility = View.GONE
                setMainInteractionEnabled(true)
                Log.e(tag, getString(R.string.log_unsupported_credential_type, credential.type))
                Toast.makeText(this, getString(R.string.tipo_credencial_no_soportado), Toast.LENGTH_SHORT).show()
                updateUIBasedOnLoginStatus(null)
            }
        }
    }

    private fun firebaseAuthWithGoogle(credential: GoogleIdTokenCredential) {
        // El ProgressBar sigue visible
        val firebaseCredential = GoogleAuthProvider.getCredential(credential.idToken, null)
        auth.signInWithCredential(firebaseCredential)
            .addOnCompleteListener(this) { task ->
                // No ocultar ProgressBar aquí directamente, checkAndCreateUserProfile lo hará
                if (task.isSuccessful) {
                    Log.i(tag, getString(R.string.log_firebase_auth_successful))
                    val firebaseUser = auth.currentUser
                    firebaseUser?.let { user ->
                        checkAndCreateUserProfile(user)
                    } ?: run {
                        mainActivityProgressBar.visibility = View.GONE
                        setMainInteractionEnabled(true)
                        Log.e(tag, getString(R.string.log_error_firebase_user_null_after_success))
                        Toast.makeText(this, getString(R.string.error_internal_user_not_available), Toast.LENGTH_SHORT).show()
                        updateUIBasedOnLoginStatus(null)
                    }
                } else {
                    mainActivityProgressBar.visibility = View.GONE
                    setMainInteractionEnabled(true)
                    Log.e(tag, getString(R.string.log_error_firebase_auth, task.exception?.message), task.exception)
                    Toast.makeText(this, getString(R.string.error_authentication_generic, task.exception?.localizedMessage), Toast.LENGTH_LONG).show()
                    updateUIBasedOnLoginStatus(null)
                }
            }
    }

    private fun checkAndCreateUserProfile(firebaseUser: FirebaseUser) {
        val userId = firebaseUser.uid
        val userDocumentRef = firestore.collection(getString(R.string.firestore_collection_users)).document(userId)

        // ProgressBar ya debería estar visible desde el flujo de login
        if (mainActivityProgressBar.visibility == View.GONE) { // Por si acaso
            mainActivityProgressBar.visibility = View.VISIBLE
        }
        setMainInteractionEnabled(false) // Deshabilitar interacción mientras se verifica

        userDocumentRef.get()
            .addOnCompleteListener { documentTask ->
                mainActivityProgressBar.visibility = View.GONE // Ocultar aquí después de la operación de Firestore

                if (documentTask.isSuccessful) {
                    val document = documentTask.result
                    val usernameInDb = document?.getString(getString(R.string.firestore_field_username))

                    if (document == null || !document.exists()) {
                        Log.i(tag, getString(R.string.log_user_document_not_exists_creating, userId))
                        val userData = hashMapOf(
                            getString(R.string.firestore_field_userId) to firebaseUser.uid,
                            getString(R.string.firestore_field_username) to "",
                            getString(R.string.firestore_field_usernameNormalized) to "",
                            getString(R.string.firestore_field_profileImageUrl) to (firebaseUser.photoUrl?.toString() ?: ""),
                            getString(R.string.firestore_field_email) to (firebaseUser.email ?: ""),
                            getString(R.string.firestore_field_displayNameFromGoogle) to (firebaseUser.displayName ?: ""),
                            getString(R.string.firestore_field_location) to "",
                            getString(R.string.firestore_field_role) to getString(R.string.user_role_default),
                            getString(R.string.firestore_field_isBanned) to false,
                            getString(R.string.firestore_field_registrationDate) to FieldValue.serverTimestamp()
                        )
                        userDocumentRef.set(userData)
                            .addOnSuccessListener {
                                Log.i(tag, getString(R.string.log_user_document_created_firestore, userId))
                                redirectToEditProfileForFirstTimeSetup() // Esto llamará a finish()
                            }
                            .addOnFailureListener { e ->
                                setMainInteractionEnabled(true) // Reactivar si falla
                                Log.e(tag, getString(R.string.log_error_creating_user_document_firestore, userId), e)
                                Toast.makeText(this, getString(R.string.error_creating_user_profile), Toast.LENGTH_SHORT).show()
                                updateUIBasedOnLoginStatus(null)
                            }
                    } else if (usernameInDb.isNullOrEmpty()) {
                        Log.i(tag, "Usuario $userId existe pero no tiene username. Redirigiendo a configuración.")
                        redirectToEditProfileForFirstTimeSetup() // Esto llamará a finish()
                    }
                    else {
                        Log.i(tag, getString(R.string.log_user_document_exists_firestore, userId))
                        updateUIBasedOnLoginStatus(firebaseUser) // Esto habilitará la UI
                    }
                } else {
                    setMainInteractionEnabled(true) // Reactivar si falla
                    Log.e(tag, getString(R.string.log_error_verifying_user_document_firestore, userId), documentTask.exception)
                    Toast.makeText(this, getString(R.string.error_verifying_existing_profile), Toast.LENGTH_SHORT).show()
                    updateUIBasedOnLoginStatus(null)
                }
            }
    }

    private fun redirectToEditProfileForFirstTimeSetup() {
        Toast.makeText(this, getString(R.string.toast_complete_profile_setup), Toast.LENGTH_LONG).show()
        val intent = Intent(this@MainActivity, EditProfileActivity::class.java)
        intent.putExtra("IS_FIRST_TIME_SETUP", true)
        startActivity(intent)
        finish() // Finalizar MainActivity
    }


    @SuppressLint("SetTextI18n")
    private fun updateUIBasedOnLoginStatus(firebaseUser: FirebaseUser?) {
        val btn = findViewById<MaterialButton>(R.id.btn_iniciar_sesion)
        mainActivityProgressBar.visibility = View.GONE

        if (firebaseUser != null) {
            // Como MainActivity se reinicia después del setup, aquí asumimos que si hay firebaseUser, el perfil está completo.
            // La verificación de username vacío que antes estaba aquí ya no es necesaria porque
            // si el username está vacío, MainActivity se cierra y se lanza EditProfileActivity.
            // Al volver, esta función se llamará con un perfil ya configurado (o debería).

            mainActivityProgressBar.visibility = View.VISIBLE // Mostrar mientras se carga el rol
            setMainInteractionEnabled(false) // Deshabilitar mientras se carga el rol

            firestore.collection(getString(R.string.firestore_collection_users)).document(firebaseUser.uid).get()
                .addOnSuccessListener { documentSnapshot ->
                    mainActivityProgressBar.visibility = View.GONE
                    setMainInteractionEnabled(true) // Habilitar UI una vez cargado el rol

                    if (documentSnapshot.exists()) {
                        val userRole = documentSnapshot.getString(getString(R.string.firestore_field_role))
                        if (userRole == getString(R.string.user_role_admin)) {
                            btn.text = getString(R.string.admin_panel_button_text)
                            btn.setOnClickListener {
                                val intent = Intent(this, AdminProfileActivity::class.java)
                                startActivity(intent)
                            }
                        } else {
                            btn.text = getString(R.string.ir_al_perfil)
                            btn.setOnClickListener {
                                val intent = Intent(this, UserProfileActivity::class.java)
                                startActivity(intent)
                            }
                        }
                    } else {
                        // Este caso es improbable si el flujo de setup funciona y MainActivity se reinicia
                        Log.w(tag, "Documento de usuario no encontrado para ${firebaseUser.uid} después de supuesto setup. Forzando setup.")
                        btn.text = getString(R.string.button_complete_profile)
                        btn.setOnClickListener {
                            redirectToEditProfileForFirstTimeSetup() // Volver a intentar el setup
                        }
                        setMainInteractionEnabled(false)
                    }
                }
                .addOnFailureListener { e ->
                    mainActivityProgressBar.visibility = View.GONE
                    setMainInteractionEnabled(true) // Habilitar UI en caso de error
                    Log.e(tag, getString(R.string.log_error_getting_user_role, firebaseUser.uid), e)
                    btn.text = getString(R.string.ir_al_perfil) // Fallback
                    btn.setOnClickListener {
                        val intent = Intent(this, UserProfileActivity::class.java)
                        startActivity(intent)
                    }
                }
        } else { // Usuario no logueado
            btn.text = getString(R.string.iniciar_sesion)
            btn.setOnClickListener {
                mainActivityProgressBar.visibility = View.VISIBLE // Mostrar al iniciar el proceso de login
                setMainInteractionEnabled(false)
                signIn()
            }
            setMainInteractionEnabled(false) // UI principal deshabilitada si no hay sesión
        }
    }

    private fun setMainInteractionEnabled(enabled: Boolean) {
        editTextSearch.isEnabled = enabled
        searchButton.isClickable = enabled
        recentContainer.isClickable = enabled
        favoritesContainer.isClickable = enabled
        placesContainer.isClickable = enabled
        mapContainer.isClickable = enabled
        chipFotos.isEnabled = enabled
        chipVideos.isEnabled = enabled
        chipRelatos.isEnabled = enabled

        val alphaValue = if (enabled) 1.0f else 0.5f
        editTextSearch.alpha = alphaValue
        searchButton.alpha = alphaValue
        dashboardGrid.alpha = alphaValue
        categoriesChipGroup.alpha = alphaValue

        // El botón de login/perfil tiene su propia lógica de habilitación en updateUIBasedOnLoginStatus
    }


    @Suppress("DEPRECATION")
    private fun isActivityRunning(activityClassName: String): Boolean {
        val activityManager = getSystemService(Context.ACTIVITY_SERVICE) as android.app.ActivityManager
        val tasks = activityManager.getRunningTasks(1)
        if (tasks.isNotEmpty()) {
            val topActivity = tasks[0].topActivity
            return topActivity?.className == activityClassName
        }
        return false
    }


    private fun performSearch(query: String) {
        if (query.isBlank()) {
            Toast.makeText(this, getString(R.string.error_search_term_empty), Toast.LENGTH_SHORT).show()
            return
        }
        val intent = Intent(this, SearchResultsActivity::class.java).apply {
            putExtra(getString(R.string.intent_extra_search_query), query.trim())
        }
        val options = ActivityOptionsCompat.makeCustomAnimation(
            this, R.anim.slide_in_right, R.anim.slide_out_left
        )
        startActivity(intent, options.toBundle())
    }

    override fun onStart() {
        super.onStart()
        // Con Opción B, MainActivity se reinicia. Simplemente actualiza basado en el estado actual.
        updateUIBasedOnLoginStatus(auth.currentUser)
    }

    override fun onNewIntent(intent: Intent?) {
        super.onNewIntent(intent)
        setIntent(intent) // Actualizar el intent de la actividad con el nuevo que la reinició
        // Aquí puedes verificar si hay algún extra del intent que indique que se completó el setup
        // y actualizar la UI en consecuencia, aunque onStart ya debería hacerlo.
        val profileJustCompleted = intent?.getBooleanExtra("PROFILE_SETUP_COMPLETED", false) ?: false
        if (profileJustCompleted) {
            Log.d(tag, "Perfil completado, actualizando UI de MainActivity.")
            updateUIBasedOnLoginStatus(auth.currentUser)
        }
    }
}


===== Archivo: app\src\main\java\com\example\mexicoparanormal\MapsActivity.kt =====


package com.example.mexicoparanormal

import android.app.Activity
import android.content.Intent
import android.content.pm.ApplicationInfo
import android.content.pm.PackageManager
import android.graphics.Color
import android.location.Address
import android.location.Geocoder
import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.util.Log
import android.widget.Button
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import com.google.android.gms.maps.CameraUpdateFactory
import com.google.android.gms.maps.GoogleMap
import com.google.android.gms.maps.OnMapReadyCallback
import com.google.android.gms.maps.SupportMapFragment
import com.google.android.gms.maps.model.LatLng
import com.google.android.gms.maps.model.LatLngBounds
import com.google.android.gms.maps.model.Marker
import com.google.android.gms.maps.model.MarkerOptions
import com.google.android.libraries.places.api.Places
import com.google.maps.android.PolyUtil
import com.google.maps.android.data.geojson.GeoJsonLayer
import com.google.maps.android.data.geojson.GeoJsonMultiPolygon
import com.google.maps.android.data.geojson.GeoJsonPolygon
import org.json.JSONObject
import java.io.BufferedReader
import java.io.IOException
import java.io.InputStreamReader
import java.text.Normalizer
import java.util.*
import java.util.regex.Pattern

class MapsActivity : AppCompatActivity(), OnMapReadyCallback {

    private lateinit var mMap: GoogleMap
    private var latitudeSelected: Double? = null
    private var longitudeSelected: Double? = null
    private var estadoSeleccionadoKey: String? = null
    private var estadoSeleccionadoOriginal: String? = null
    private var latitudExistente: Double = 0.0
    private var longitudExistente: Double = 0.0
    private var selectedCityName: String? = null
    private var mapsSdkApiKey: String? = null
    private var geoJsonLayer: GeoJsonLayer? = null
    private var estadoBounds: LatLngBounds? = null
    private var currentMarker: Marker? = null
    private var isEditingExistingLocation: Boolean = false
    private var isMapReadyAndLaidOut = false
    private var isInitialZoomToStateDone = false
    private var isProgrammaticAnimationInProgress = false

    private val plusCodePattern = Pattern.compile("^[A-Z0-9]{2,}\\+[A-Z0-9]{2,}", Pattern.CASE_INSENSITIVE)
    private val primarilyNumericPattern = Pattern.compile("^\\d+[\\s\\S]*$")
    private val genericRoadNamePatterns = listOf(
        Pattern.compile("^vía sin nombre$", Pattern.CASE_INSENSITIVE),
        Pattern.compile("^unnamed road$", Pattern.CASE_INSENSITIVE)
        // Puedes añadir más patrones genéricos si los identificas
    )

    companion object {
        private const val TAG = "MapsActivity" // Etiqueta para logs
    }

    private val stateGeoJsonMap = mapOf(
        "aguascalientes" to R.raw.aguascalientes,
        "baja_california" to R.raw.baja_california,
        "baja_california_sur" to R.raw.baja_california_sur,
        "campeche" to R.raw.campeche,
        "coahuila" to R.raw.coahuila,
        "colima" to R.raw.colima,
        "chiapas" to R.raw.chiapas,
        "chihuahua" to R.raw.chihuahua,
        "ciudad_de_mexico" to R.raw.ciudad_de_mexico,
        "durango" to R.raw.durango,
        "guanajuato" to R.raw.guanajuato,
        "guerrero" to R.raw.guerrero,
        "hidalgo" to R.raw.hidalgo,
        "jalisco" to R.raw.jalisco,
        "estado_de_mexico" to R.raw.estado_de_mexico,
        "michoacan" to R.raw.michoacan,
        "morelos" to R.raw.morelos,
        "nayarit" to R.raw.nayarit,
        "nuevo_leon" to R.raw.nuevo_leon,
        "oaxaca" to R.raw.oaxaca,
        "puebla" to R.raw.puebla,
        "queretaro" to R.raw.queretaro,
        "quintana_roo" to R.raw.quintana_roo,
        "san_luis_potosi" to R.raw.san_luis_potosi,
        "sinaloa" to R.raw.sinaloa,
        "sonora" to R.raw.sonora,
        "tabasco" to R.raw.tabasco,
        "tamaulipas" to R.raw.tamaulipas,
        "tlaxcala" to R.raw.tlaxcala,
        "veracruz" to R.raw.veracruz,
        "yucatan" to R.raw.yucatan,
        "zacatecas" to R.raw.zacatecas
    )

    private fun normalizeStateNameForKey(name: String?): String? {
        if (name == null) return null
        var tempName = name.lowercase(Locale.getDefault())
        tempName = tempName.replace('á', 'a')
            .replace('é', 'e')
            .replace('í', 'i')
            .replace('ó', 'o')
            .replace('ú', 'u')
            .replace('ñ', 'n')
        val normalized = Normalizer.normalize(tempName, Normalizer.Form.NFD)
            .replace("\\p{InCombiningDiacriticalMarks}+".toRegex(), "")
        return normalized.replace(' ', '_')
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_maps)

        try {
            val appInfo: ApplicationInfo = packageManager.getApplicationInfo(packageName, PackageManager.GET_META_DATA)
            val bundle = appInfo.metaData
            mapsSdkApiKey = bundle.getString(getString(R.string.meta_data_google_geo_api_key))
            if (mapsSdkApiKey.isNullOrEmpty()) {
                Log.e(TAG, getString(R.string.log_error_maps_sdk_api_key_not_found))
            }
        } catch (e: PackageManager.NameNotFoundException) {
            Log.e(TAG, getString(R.string.log_error_getting_api_key_from_manifest), e)
        }

        if (!mapsSdkApiKey.isNullOrEmpty() && !Places.isInitialized()) {
            Places.initialize(applicationContext, mapsSdkApiKey!!)
        }

        estadoSeleccionadoOriginal = intent.getStringExtra(getString(R.string.intent_extra_selected_state))
        estadoSeleccionadoKey = normalizeStateNameForKey(estadoSeleccionadoOriginal)
        Log.i(TAG, getString(R.string.log_oncreate_state_info, estadoSeleccionadoOriginal, estadoSeleccionadoKey))

        latitudExistente = intent.getDoubleExtra(getString(R.string.intent_extra_latitude), 0.0)
        longitudExistente = intent.getDoubleExtra(getString(R.string.intent_extra_longitude), 0.0)
        isEditingExistingLocation = (latitudExistente != 0.0 && longitudExistente != 0.0)

        findViewById<Button>(R.id.btnBackMap).setOnClickListener {
            setResult(Activity.RESULT_CANCELED)
            finish()
        }

        val mapFragment = supportFragmentManager.findFragmentById(R.id.mapView) as SupportMapFragment
        mapFragment.getMapAsync(this)
    }

    override fun onMapReady(googleMap: GoogleMap) {
        mMap = googleMap
        mMap.uiSettings.isZoomControlsEnabled = true
        mMap.uiSettings.isZoomGesturesEnabled = true
        mMap.uiSettings.isScrollGesturesEnabled = true
        mMap.uiSettings.isRotateGesturesEnabled = true


        mMap.setOnPoiClickListener { poi ->
            Log.d(TAG, getString(R.string.log_poi_clicked_ignoring, poi.name))
        }

        val mexicoVistaGeneral = LatLng(23.6345, -102.5528) // Coordenadas para vista general de México
        mMap.moveCamera(CameraUpdateFactory.newLatLngZoom(mexicoVistaGeneral, 4.5f))

        loadEstadoGeoJson()

        mMap.setOnMapLoadedCallback {
            isMapReadyAndLaidOut = true
            Log.d(TAG, getString(R.string.log_onmaploadedcallback_map_fully_loaded))

            if (estadoBounds != null && estadoSeleccionadoKey != null) {
                Log.d(TAG, getString(R.string.log_onmaploadedcallback_state_has_bounds_animating, estadoSeleccionadoKey))
                isProgrammaticAnimationInProgress = true
                mMap.animateCamera(CameraUpdateFactory.newLatLngBounds(estadoBounds!!, 100), 1000, object : GoogleMap.CancelableCallback {
                    override fun onFinish() {
                        Log.d(TAG, getString(R.string.log_onmaploadedcallback_animation_to_state_bounds_finished))
                        isInitialZoomToStateDone = true
                        if (isEditingExistingLocation) {
                            val ubicacionExistente = LatLng(latitudExistente, longitudExistente)
                            Log.d(TAG, getString(R.string.log_onmaploadedcallback_editing_animating_to_existing_location, ubicacionExistente.toString()))
                            mMap.animateCamera(CameraUpdateFactory.newLatLngZoom(ubicacionExistente, 15f), 800, object : GoogleMap.CancelableCallback {
                                override fun onFinish() { isProgrammaticAnimationInProgress = false }
                                override fun onCancel() { isProgrammaticAnimationInProgress = false }
                            })
                        } else {
                            isProgrammaticAnimationInProgress = false
                        }
                    }
                    override fun onCancel() {
                        Log.d(TAG, getString(R.string.log_onmaploadedcallback_animation_to_state_bounds_cancelled))
                        isInitialZoomToStateDone = true
                        if (isEditingExistingLocation) {
                            val ubicacionExistente = LatLng(latitudExistente, longitudExistente)
                            mMap.moveCamera(CameraUpdateFactory.newLatLngZoom(ubicacionExistente, 14f))
                        }
                        isProgrammaticAnimationInProgress = false
                    }
                })
            } else if (isEditingExistingLocation) {
                val ubicacionExistente = LatLng(latitudExistente, longitudExistente)
                Log.d(TAG, getString(R.string.log_onmaploadedcallback_editing_no_state_bounds_animating_directly, ubicacionExistente.toString()))
                isProgrammaticAnimationInProgress = true
                mMap.animateCamera(CameraUpdateFactory.newLatLngZoom(ubicacionExistente, 14f), 800, object: GoogleMap.CancelableCallback{
                    override fun onFinish() { isProgrammaticAnimationInProgress = false }
                    override fun onCancel() { isProgrammaticAnimationInProgress = false }
                })
            }

            if (isEditingExistingLocation) {
                val ubicacionExistente = LatLng(latitudExistente, longitudExistente)
                currentMarker?.remove()
                currentMarker = mMap.addMarker(MarkerOptions().position(ubicacionExistente).title(getString(R.string.current_location)))
                getPlaceNameUsingGeocoder(ubicacionExistente)
            }
        }

        mMap.setOnMapClickListener { latLng ->
            if (isProgrammaticAnimationInProgress) {
                Log.d(TAG, getString(R.string.log_click_ignored_animation_in_progress))
                return@setOnMapClickListener
            }
            Log.d(TAG, getString(R.string.log_map_clicked_at_state, latLng.toString(), estadoSeleccionadoKey.toString()))

            // Detener cualquier animación de cámara que el usuario haya iniciado con gestos
            // Esto es para evitar que un "doble toque para zoom" interfiera con la colocación del marcador.
            mMap.stopAnimation()

            if (isPointInSelectedState(latLng)) {
                Log.i(TAG, getString(R.string.log_point_inside_state_placing_marker))
                currentMarker?.remove()
                currentMarker = mMap.addMarker(
                    MarkerOptions()
                        .position(latLng)
                        .title(getString(R.string.selected_location))
                )
                latitudeSelected = latLng.latitude
                longitudeSelected = latLng.longitude
                getPlaceNameUsingGeocoder(latLng)
            } else {
                Log.w(TAG, getString(R.string.log_point_outside_state_showing_toast))
                val estadoParaMostrar = estadoSeleccionadoOriginal ?: getString(R.string.default_state_name)
                Toast.makeText(this, getString(R.string.error_select_location_within_state, estadoParaMostrar), Toast.LENGTH_LONG).show()
            }
        }

        findViewById<Button>(R.id.btnConfirmLocation).setOnClickListener {
            if (latitudeSelected != null && longitudeSelected != null) {
                val resultIntent = Intent().apply {
                    putExtra(getString(R.string.intent_extra_latitude_result), latitudeSelected)
                    putExtra(getString(R.string.intent_extra_longitude_result), longitudeSelected)
                    putExtra(getString(R.string.intent_extra_cityname_result), selectedCityName ?: "")
                }
                setResult(Activity.RESULT_OK, resultIntent)
                finish()
            } else {
                Toast.makeText(this, getString(R.string.error_select_location_first), Toast.LENGTH_SHORT).show()
            }
        }
    }

    private fun loadEstadoGeoJson() {
        val currentEstadoKeyParaBusqueda = estadoSeleccionadoKey
        Log.i(TAG, getString(R.string.log_loadestadogeojson_search_key, currentEstadoKeyParaBusqueda.toString()))

        if (currentEstadoKeyParaBusqueda == null) {
            Log.w(TAG, getString(R.string.log_loadestadogeojson_no_state_selected))
            isInitialZoomToStateDone = true // Marcar como hecho si no hay estado para cargar
            return
        }

        geoJsonLayer?.removeLayerFromMap() // Limpiar capa anterior
        estadoBounds = null // Resetear bounds

        val geoJsonFileId = stateGeoJsonMap[currentEstadoKeyParaBusqueda]
        if (geoJsonFileId == null) {
            Log.e(TAG, getString(R.string.log_loadestadogeojson_no_geojson_id_found, currentEstadoKeyParaBusqueda, estadoSeleccionadoOriginal.toString()))
            Toast.makeText(this, getString(R.string.error_geojson_not_found_for_state, estadoSeleccionadoOriginal ?: currentEstadoKeyParaBusqueda), Toast.LENGTH_LONG).show()
            isInitialZoomToStateDone = true
            return
        }
        Log.d(TAG, getString(R.string.log_loadestadogeojson_using_file_id, geoJsonFileId.toString(), currentEstadoKeyParaBusqueda))

        try {
            val inputStream = resources.openRawResource(geoJsonFileId)
            val reader = BufferedReader(InputStreamReader(inputStream))
            val geoJsonString = reader.readText()
            inputStream.close()

            val geoJsonObject = JSONObject(geoJsonString)
            geoJsonLayer = GeoJsonLayer(mMap, geoJsonObject)

            // Estilo del polígono
            val polygonStyle = geoJsonLayer!!.defaultPolygonStyle
            polygonStyle.fillColor = Color.TRANSPARENT // Relleno transparente
            polygonStyle.strokeColor = ContextCompat.getColor(this, R.color.map_polygon_stroke) // Color del borde
            polygonStyle.strokeWidth = 3f // Ancho del borde
            polygonStyle.isClickable = false // No interactuable

            geoJsonLayer!!.addLayerToMap()
            Log.i(TAG, getString(R.string.log_loadestadogeojson_layer_added, currentEstadoKeyParaBusqueda))

            // Calcular bounds
            val boundsBuilder = LatLngBounds.Builder()
            var hasGeometries = false
            for (feature in geoJsonLayer!!.features) {
                if (feature.geometry is GeoJsonPolygon || feature.geometry is GeoJsonMultiPolygon) hasGeometries = true
                feature.geometry?.let { geom ->
                    when (geom) {
                        is GeoJsonPolygon -> geom.coordinates.forEach { path -> path.forEach { latLng -> boundsBuilder.include(latLng) } }
                        is GeoJsonMultiPolygon -> geom.polygons.forEach { poly -> poly.coordinates.forEach { path -> path.forEach { latLng -> boundsBuilder.include(latLng) } } }
                        // Añadir otros tipos de geometría si es necesario
                    }
                }
            }

            if (hasGeometries) {
                try {
                    estadoBounds = boundsBuilder.build()
                    Log.d(TAG, getString(R.string.log_loadestadogeojson_bounds_calculated, currentEstadoKeyParaBusqueda, estadoBounds.toString()))
                } catch (e: IllegalStateException) { // Puede ocurrir si no hay puntos en el builder
                    Log.e(TAG, getString(R.string.log_loadestadogeojson_could_not_build_bounds, currentEstadoKeyParaBusqueda), e)
                    estadoBounds = null
                }
            } else {
                Log.w(TAG, getString(R.string.log_loadestadogeojson_no_geometries_for_bounds, currentEstadoKeyParaBusqueda))
                estadoBounds = null
            }

        } catch (e: Exception) {
            Log.e(TAG, getString(R.string.log_loadestadogeojson_error_loading_parsing, currentEstadoKeyParaBusqueda), e)
            Toast.makeText(this, getString(R.string.error_loading_state_boundary, estadoSeleccionadoOriginal ?: currentEstadoKeyParaBusqueda), Toast.LENGTH_LONG).show()
            estadoBounds = null // Asegurar que bounds es nulo en caso de error
        }
        // Marcar como hecho solo si no estamos editando, ya que la edición tiene su propio flujo de zoom
        if (!isEditingExistingLocation) {
            isInitialZoomToStateDone = true
        }
    }

    private fun checkPolygon(polygon: GeoJsonPolygon, point: LatLng): Boolean {
        // Comprobar si el punto está dentro del límite exterior
        if (polygon.coordinates.isNotEmpty()) {
            val outerBoundary = polygon.coordinates[0] // El primer elemento es el límite exterior
            if (PolyUtil.containsLocation(point, outerBoundary, true)) {
                // Comprobar si el punto está dentro de algún agujero (límite interior)
                var inHole = false
                for (i in 1 until polygon.coordinates.size) { // Iterar sobre los agujeros
                    if (PolyUtil.containsLocation(point, polygon.coordinates[i], true)) {
                        inHole = true
                        break
                    }
                }
                if (!inHole) return true // Está en el exterior pero no en un agujero
            }
        }
        return false
    }

    private fun isPointInSelectedState(point: LatLng): Boolean {
        val currentKey = estadoSeleccionadoKey
        Log.d(TAG, getString(R.string.log_ispointinselectedstate_checking_point, point.toString(), currentKey.toString()))

        if (currentKey == null) {
            Log.i(TAG, getString(R.string.log_ispointinselectedstate_no_state_selected_allowing_click))
            return true // Si no hay estado seleccionado, se permite (vista general de México)
        }
        if (geoJsonLayer == null) {
            Log.w(TAG, getString(R.string.log_ispointinselectedstate_geojsonlayer_null, currentKey))
            return false // Si la capa no está cargada, el punto se considera fuera
        }

        for (feature in geoJsonLayer!!.features) {
            when (val geometry = feature.geometry) {
                is GeoJsonPolygon -> {
                    if (checkPolygon(geometry, point)) {
                        Log.i(TAG, getString(R.string.log_ispointinselectedstate_point_inside_geojsonpolygon, currentKey))
                        return true
                    }
                }
                is GeoJsonMultiPolygon -> {
                    for (polygon in geometry.polygons) {
                        if (checkPolygon(polygon, point)) {
                            Log.i(TAG, getString(R.string.log_ispointinselectedstate_point_inside_multipolygon, currentKey))
                            return true
                        }
                    }
                }
                // Considerar otros tipos de geometría si es necesario
            }
        }
        Log.i(TAG, getString(R.string.log_ispointinselectedstate_point_outside_all_polygons, point.toString(), currentKey))
        return false
    }

    private fun getPlaceNameUsingGeocoder(latLng: LatLng) {
        if (!Geocoder.isPresent()) {
            Log.e(TAG, getString(R.string.log_geocoder_not_present))
            Toast.makeText(this, getString(R.string.geocoding_no_service_available), Toast.LENGTH_SHORT).show()
            selectedCityName = "${String.format(Locale.US, "%.4f", latLng.latitude)}, ${String.format(Locale.US, "%.4f", latLng.longitude)}"
            updateMarkerTitle(latLng, selectedCityName)
            return
        }

        val geocoder = Geocoder(this, Locale.getDefault())
        var bestPlaceName: String? = null
        try {
            val addresses: List<Address>? = geocoder.getFromLocation(latLng.latitude, latLng.longitude, 1) // Obtener solo 1 resultado

            if (addresses != null && addresses.isNotEmpty()) {
                val address = addresses[0]
                Log.d(TAG, getString(R.string.log_geocoder_full_address, address.toString()))

                val featureName = address.featureName // Nombre del POI, parque, edificio, etc.
                val premises = address.premises // Número de edificio, nombre del edificio si es un POI
                val thoroughfare = address.thoroughfare // Nombre de la calle
                val subLocality = address.subLocality // Colonia, barrio
                val locality = address.locality // Ciudad
                val subAdminArea = address.subAdminArea // Municipio, delegación
                val fullAddressLine = if (address.maxAddressLineIndex >= 0) address.getAddressLine(0) else null


                // Lógica de priorización para nombres de lugar
                // 1. Feature Name (si es descriptivo y no un código/número/calle)
                if (!featureName.isNullOrEmpty() &&
                    !plusCodePattern.matcher(featureName).find() && // No es un Plus Code
                    !primarilyNumericPattern.matcher(featureName).find() && // No es principalmente numérico
                    !genericRoadNamePatterns.any { it.matcher(featureName).matches() } && // No es un nombre de calle genérico
                    featureName.length > 3) { // Un nombre de POI suele tener más de 3 caracteres
                    bestPlaceName = featureName
                }
                // 2. Premises (si es descriptivo y no un código)
                if (bestPlaceName.isNullOrEmpty() && !premises.isNullOrEmpty() && !plusCodePattern.matcher(premises).find()) {
                    bestPlaceName = premises
                }
                // 3. SubLocality (Colonia/Barrio, puede ser un parque)
                if (bestPlaceName.isNullOrEmpty() && !subLocality.isNullOrEmpty()) {
                    bestPlaceName = subLocality
                }
                // 4. Locality (Ciudad)
                if (bestPlaceName.isNullOrEmpty() && !locality.isNullOrEmpty()) {
                    bestPlaceName = locality
                }
                // 5. Thoroughfare (Calle) - solo si no es genérica y no tenemos nada mejor
                if (bestPlaceName.isNullOrEmpty() && !thoroughfare.isNullOrEmpty() && !genericRoadNamePatterns.any { it.matcher(thoroughfare).matches() }) {
                    bestPlaceName = thoroughfare
                    // Si featureName es un número de casa y thoroughfare es la calle, combinarlos
                    if (!featureName.isNullOrEmpty() && featureName != thoroughfare && primarilyNumericPattern.matcher(featureName).find()) {
                        bestPlaceName = "$featureName $thoroughfare" // Ej: "123 Calle Principal"
                    }
                }
                // 6. SubAdminArea (Municipio/Delegación)
                if (bestPlaceName.isNullOrEmpty() && !subAdminArea.isNullOrEmpty()){
                    bestPlaceName = subAdminArea
                }

                // Fallback si todo lo anterior falla o da un Plus Code
                if (bestPlaceName.isNullOrEmpty() || plusCodePattern.matcher(bestPlaceName).matches()) {
                    if (!fullAddressLine.isNullOrEmpty() && !plusCodePattern.matcher(fullAddressLine).find()){
                        bestPlaceName = fullAddressLine // Usar la primera línea de dirección si es mejor
                    }
                }

                // Construcción final del nombre: POI/Colonia, Ciudad
                if (!bestPlaceName.isNullOrEmpty() && !locality.isNullOrEmpty() &&
                    bestPlaceName.lowercase(Locale.getDefault()) != locality.lowercase(Locale.getDefault()) && // No son lo mismo
                    (subAdminArea == null || bestPlaceName.lowercase(Locale.getDefault()) != subAdminArea.lowercase(Locale.getDefault())) && // No es el municipio
                    !bestPlaceName.contains(locality, ignoreCase = true) && // Evitar duplicados "Ciudad, Ciudad"
                    !locality.contains(bestPlaceName, ignoreCase = true) // Evitar duplicados "Parque X, Parque X"
                ) {
                    selectedCityName = "$bestPlaceName, $locality"
                } else {
                    selectedCityName = bestPlaceName // Si bestPlaceName ya es la ciudad o es lo único que tenemos
                }

                Log.d(TAG, getString(R.string.log_geocoder_constructed_name, selectedCityName.toString()))
            } else {
                Log.w(TAG, getString(R.string.log_geocoder_no_address_found))
                selectedCityName = getString(R.string.no_address_found_for_coordinates)
            }
        } catch (e: IOException) {
            Log.e(TAG, getString(R.string.log_geocoder_service_error), e)
            selectedCityName = getString(R.string.geocoding_service_error)
        } catch (e: IllegalArgumentException) { // Para lat/lng inválidos
            Log.e(TAG, getString(R.string.log_geocoder_invalid_argument), e)
            selectedCityName = getString(R.string.geocoding_invalid_coordinates)
        }

        // Fallback final si selectedCityName sigue siendo nulo o vacío
        if (selectedCityName.isNullOrBlank()){
            selectedCityName = "${String.format(Locale.US, "%.4f", latLng.latitude)}, ${String.format(Locale.US, "%.4f", latLng.longitude)}"
        }
        updateMarkerTitle(latLng, selectedCityName)
    }

    // Esta función ya no es necesaria ya que el zoom se hace a los bounds del GeoJSON o a la ubicación existente.
    // private fun obtenerCoordenadasPorEstado(estadoKey: String?): LatLng { ... }

    private fun updateMarkerTitle(latLng: LatLng, title: String?) {
        // Handler para asegurar que se ejecuta en el hilo principal si es necesario (aunque Geocoder ya debería)
        // No es estrictamente necesario aquí si getPlaceNameUsingGeocoder ya se llama desde un hilo UI o usa runOnUiThread.
        updateMarkerTitleInternal(latLng, title)
    }

    private fun updateMarkerTitleInternal(latLng: LatLng, title: String?) {
        currentMarker?.title = title ?: "${String.format(Locale.US, "%.4f", latLng.latitude)}, ${String.format(Locale.US, "%.4f", latLng.longitude)}"
        currentMarker?.showInfoWindow() // Mostrar la ventana de información actualizada
    }
}


===== Archivo: app\src\main\java\com\example\mexicoparanormal\MexicoParanormalApplication.kt =====


package com.example.mexicoparanormal

import android.app.Application
import android.util.Log
import com.cloudinary.android.MediaManager
import com.google.firebase.FirebaseApp // Importación para FirebaseApp
import com.google.firebase.appcheck.FirebaseAppCheck // Importación para FirebaseAppCheck
import com.google.firebase.appcheck.playintegrity.PlayIntegrityAppCheckProviderFactory // Importación para Play Integrity

class MexicoParanormalApplication : Application() {

    companion object {
        private const val TAG = "MexicoParanormalApp" // Etiqueta para logs de esta clase
    }

    override fun onCreate() {
        super.onCreate()

        // Inicializar Firebase primero (si no lo has hecho explícitamente antes aquí)
        FirebaseApp.initializeApp(this)
        Log.d(TAG, getString(R.string.log_info_firebase_app_initialized))

        // Inicializar Firebase App Check con Play Integrity
        val firebaseAppCheck = FirebaseAppCheck.getInstance()
        firebaseAppCheck.installAppCheckProviderFactory(
            PlayIntegrityAppCheckProviderFactory.getInstance()
        )
        Log.d(TAG, getString(R.string.log_info_firebase_app_check_initialized))

        // *** Inicializar Cloudinary UNA SOLA VEZ al iniciar la aplicación ***
        val config: HashMap<String, String> = HashMap()
        config["cloud_name"] = "di7wukxez" // Cloud Name - Mantener como está (valor de configuración)
        config["api_key"] = "838494638475872" // API Key - Mantener como está (valor de configuración)
        config["api_secret"] = "Kxw3tI8oL-GNGV9t3_VXwYVPx28" // API Secret - Mantener como está (valor de configuración)

        try {
            MediaManager.init(this, config)
            Log.d(TAG, getString(R.string.log_info_cloudinary_initialized_successfully))
        } catch (e: Exception) {
            Log.e(TAG, getString(R.string.log_error_cloudinary_initialization), e)
            // Considera qué hacer si la inicialización falla críticamente al inicio
            // Podrías querer mostrar un error persistente o deshabilitar funcionalidades que dependan de Cloudinary.
        }
        // *** Fin Inicialización Cloudinary ***

        // Aquí puedes añadir inicializaciones de otras librerías globales si las tienes
    }
}


===== Archivo: app\src\main\java\com\example\mexicoparanormal\PendingUploadsActivity.kt =====


package com.example.mexicoparanormal

import android.content.Intent
import android.os.Bundle
import android.util.Log
import android.view.View
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.recyclerview.widget.LinearLayoutManager
import com.example.mexicoparanormal.databinding.ActivityPendingUploadsBinding
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.Query
import com.google.firebase.firestore.QuerySnapshot
import com.google.android.gms.tasks.Tasks

class PendingUploadsActivity : AppCompatActivity() {

    private lateinit var binding: ActivityPendingUploadsBinding
    private lateinit var auth: FirebaseAuth
    private lateinit var firestore: FirebaseFirestore
    private lateinit var pendingUploadsAdapter: PendingUploadsAdapter // Se inicializa en setupRecyclerView
    private val pendingItemsList = mutableListOf<PendingListItem>() // Se usa para construir la lista antes de pasarla al adapter

    companion object {
        private const val TAG = "PendingUploadsActivity" // Etiqueta para logs
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityPendingUploadsBinding.inflate(layoutInflater)
        setContentView(binding.root)

        auth = FirebaseAuth.getInstance()
        firestore = FirebaseFirestore.getInstance()

        setupRecyclerView()
        binding.btnBackPendingUploads.setOnClickListener {
            finish() // Regresar a la actividad anterior
        }

        loadPendingUploads()
    }

    private fun setupRecyclerView() {
        // Corregido: Se eliminó pendingItemsList del constructor del adaptador
        pendingUploadsAdapter = PendingUploadsAdapter(this) { submissionItem ->
            // Manejar clic en el ítem: Navegar a la actividad de visualización apropiada
            when (submissionItem.type) { // submissionItem.type debería resolverse ahora
                PendingContentType.STORY -> {
                    val intent = Intent(this, RelatoViewerActivity::class.java)
                    intent.putExtra(getString(R.string.intent_extra_story_id), submissionItem.id)
                    intent.putExtra(getString(R.string.intent_extra_is_pending_review), true)
                    startActivity(intent)
                }
                PendingContentType.IMAGE -> {
                    val intent = Intent(this, ImageViewerActivity::class.java)
                    intent.putExtra(getString(R.string.intent_extra_image_id), submissionItem.id)
                    intent.putExtra(getString(R.string.intent_extra_is_pending_review), true)
                    startActivity(intent)
                }
                PendingContentType.VIDEO -> {
                    val intent = Intent(this, VideoViewerActivity::class.java)
                    intent.putExtra(getString(R.string.intent_extra_video_id), submissionItem.id)
                    intent.putExtra(getString(R.string.intent_extra_is_pending_review), true)
                    startActivity(intent)
                }
            }
        }
        binding.recyclerViewPendingUploads.apply {
            layoutManager = LinearLayoutManager(this@PendingUploadsActivity)
            adapter = pendingUploadsAdapter
        }
    }

    private fun loadPendingUploads() {
        val currentUser = auth.currentUser
        if (currentUser == null) {
            Toast.makeText(this, getString(R.string.error_user_not_authenticated), Toast.LENGTH_SHORT).show()
            binding.textViewNoPendingUploads.text = getString(R.string.no_pending_uploads_message)
            binding.textViewNoPendingUploads.visibility = View.VISIBLE
            binding.recyclerViewPendingUploads.visibility = View.GONE
            pendingUploadsAdapter.submitList(emptyList()) // Enviar lista vacía si no hay usuario
            return
        }
        val userId = currentUser.uid

        binding.textViewNoPendingUploads.visibility = View.GONE // Ocultar inicialmente
        // Podrías mostrar un ProgressBar aquí
        // binding.progressBarPending.visibility = View.VISIBLE

        val storiesTask = firestore.collection(getString(R.string.firestore_collection_stories_pending))
            .whereEqualTo(getString(R.string.firestore_field_userId), userId)
            .orderBy(getString(R.string.firestore_field_timestamp), Query.Direction.DESCENDING)
            .get()

        val imagesTask = firestore.collection(getString(R.string.firestore_collection_images_pending))
            .whereEqualTo(getString(R.string.firestore_field_userId), userId)
            .orderBy(getString(R.string.firestore_field_timestamp), Query.Direction.DESCENDING)
            .get()

        val videosTask = firestore.collection(getString(R.string.firestore_collection_videos_pending))
            .whereEqualTo(getString(R.string.firestore_field_userId), userId)
            .orderBy(getString(R.string.firestore_field_timestamp), Query.Direction.DESCENDING)
            .get()

        Tasks.whenAllSuccess<QuerySnapshot>(storiesTask, imagesTask, videosTask)
            .addOnSuccessListener { results ->
                pendingItemsList.clear() // Limpiar la lista mutable local antes de reconstruirla
                var hasContent = false

                val storiesSnapshot = results[0]
                if (!storiesSnapshot.isEmpty) {
                    hasContent = true
                    pendingItemsList.add(PendingListItem.HeaderItem(getString(R.string.section_header_pending_stories)))
                    for (document in storiesSnapshot.documents) {
                        pendingItemsList.add(PendingListItem.SubmissionItem(
                            id = document.id,
                            title = document.getString(getString(R.string.firestore_field_title)) ?: getString(R.string.title_not_available),
                            submissionTimestamp = document.getTimestamp(getString(R.string.firestore_field_timestamp))?.toDate()?.time ?: 0L,
                            type = PendingContentType.STORY,
                            contentUrl = document.getString(getString(R.string.firestore_field_imageUrl)) // Para miniatura si el relato tiene imagen
                        ))
                    }
                }

                val imagesSnapshot = results[1]
                if (!imagesSnapshot.isEmpty) {
                    hasContent = true
                    pendingItemsList.add(PendingListItem.HeaderItem(getString(R.string.section_header_pending_images)))
                    for (document in imagesSnapshot.documents) {
                        pendingItemsList.add(PendingListItem.SubmissionItem(
                            id = document.id,
                            title = document.getString(getString(R.string.firestore_field_title)) ?: getString(R.string.title_not_available),
                            submissionTimestamp = document.getTimestamp(getString(R.string.firestore_field_timestamp))?.toDate()?.time ?: 0L,
                            type = PendingContentType.IMAGE,
                            contentUrl = document.getString(getString(R.string.firestore_field_imageUrl))
                        ))
                    }
                }

                val videosSnapshot = results[2]
                if (!videosSnapshot.isEmpty) {
                    hasContent = true
                    pendingItemsList.add(PendingListItem.HeaderItem(getString(R.string.section_header_pending_videos)))
                    for (document in videosSnapshot.documents) {
                        pendingItemsList.add(PendingListItem.SubmissionItem(
                            id = document.id,
                            title = document.getString(getString(R.string.firestore_field_title)) ?: getString(R.string.title_not_available),
                            submissionTimestamp = document.getTimestamp(getString(R.string.firestore_field_timestamp))?.toDate()?.time ?: 0L,
                            type = PendingContentType.VIDEO,
                            contentUrl = document.getString(getString(R.string.firestore_field_complementaryImageUrl)) // Para miniatura de video
                        ))
                    }
                }

                // binding.progressBarPending.visibility = View.GONE // Ocultar ProgressBar
                if (hasContent) {
                    pendingUploadsAdapter.submitList(pendingItemsList.toList()) // Usar submitList y pasar una copia de la lista
                    binding.recyclerViewPendingUploads.visibility = View.VISIBLE
                    binding.textViewNoPendingUploads.visibility = View.GONE
                } else {
                    pendingUploadsAdapter.submitList(emptyList()) // Enviar lista vacía
                    binding.recyclerViewPendingUploads.visibility = View.GONE
                    binding.textViewNoPendingUploads.text = getString(R.string.no_pending_uploads_message)
                    binding.textViewNoPendingUploads.visibility = View.VISIBLE
                }
            }
            .addOnFailureListener { e ->
                // binding.progressBarPending.visibility = View.GONE // Ocultar ProgressBar
                Log.e(TAG, getString(R.string.log_error_loading_pending_uploads), e)
                Toast.makeText(this, getString(R.string.error_loading_pending_uploads_with_message, e.message), Toast.LENGTH_LONG).show()
                binding.textViewNoPendingUploads.text = getString(R.string.error_loading_pending_uploads)
                binding.textViewNoPendingUploads.visibility = View.VISIBLE
                binding.recyclerViewPendingUploads.visibility = View.GONE
                pendingUploadsAdapter.submitList(emptyList()) // Enviar lista vacía en caso de error
            }
    }
}


===== Archivo: app\src\main\java\com\example\mexicoparanormal\PendingUploadsAdapter.kt =====


package com.example.mexicoparanormal

import android.content.Context
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageView
import android.widget.TextView
import androidx.recyclerview.widget.DiffUtil
import androidx.recyclerview.widget.ListAdapter
import androidx.recyclerview.widget.RecyclerView
import com.bumptech.glide.Glide // Asegúrate de tener Glide si decides usarlo para miniaturas
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale

// Modelos de datos para el adaptador (pueden estar en archivos separados)
enum class PendingContentType {
    STORY, IMAGE, VIDEO
}

sealed class PendingListItem {
    data class HeaderItem(val title: String) : PendingListItem()
    data class SubmissionItem(
        val id: String,
        val title: String,
        val submissionTimestamp: Long,
        val type: PendingContentType,
        val contentUrl: String? = null // Para miniatura de imagen/video o URL de imagen de relato
    ) : PendingListItem()
}
// Fin de Modelos de datos


class PendingUploadsAdapter(
    private val context: Context,
    private val onItemClick: (PendingListItem.SubmissionItem) -> Unit
) : ListAdapter<PendingListItem, RecyclerView.ViewHolder>(PendingDiffCallback()) {

    private val dateFormat = SimpleDateFormat(context.getString(R.string.date_format_dd_mm_yyyy_hh_mm), Locale.getDefault())

    companion object {
        private const val TYPE_HEADER = 0
        private const val TYPE_ITEM = 1
    }

    override fun getItemViewType(position: Int): Int {
        return when (getItem(position)) { // Usar getItem() de ListAdapter
            is PendingListItem.HeaderItem -> TYPE_HEADER
            is PendingListItem.SubmissionItem -> TYPE_ITEM
            null -> throw IllegalStateException(context.getString(R.string.error_item_at_position_null, position)) // ListAdapter puede tener nulls temporalmente durante diffing
        }
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {
        return when (viewType) {
            TYPE_HEADER -> {
                val view = LayoutInflater.from(parent.context)
                    .inflate(R.layout.list_item_section_header, parent, false)
                HeaderViewHolder(view)
            }
            TYPE_ITEM -> {
                val view = LayoutInflater.from(parent.context)
                    .inflate(R.layout.list_item_pending_upload, parent, false)
                ItemViewHolder(view)
            }
            else -> throw IllegalArgumentException(context.getString(R.string.error_invalid_view_type, viewType))
        }
    }

    override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {
        val currentItem = getItem(position) // Usar getItem() de ListAdapter
        currentItem?.let { // Manejar posible nulidad aunque raro en onBindViewHolder
            when (it) {
                is PendingListItem.HeaderItem -> (holder as HeaderViewHolder).bind(it)
                is PendingListItem.SubmissionItem -> (holder as ItemViewHolder).bind(it, onItemClick)
            }
        }
    }

    // Ya no se necesita updateData, ListAdapter usa submitList()

    // ViewHolder para los encabezados de sección
    class HeaderViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
        private val headerTitle: TextView = itemView.findViewById(R.id.textViewSectionHeader)
        fun bind(headerItem: PendingListItem.HeaderItem) {
            headerTitle.text = headerItem.title
        }
    }

    // ViewHolder para los ítems de envío pendiente
    inner class ItemViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
        private val itemTypeIcon: ImageView = itemView.findViewById(R.id.imageViewItemTypeIcon)
        private val itemTitle: TextView = itemView.findViewById(R.id.textViewItemTitle)
        private val itemDate: TextView = itemView.findViewById(R.id.textViewItemSubmissionDate)
        // private val itemThumbnail: ImageView = itemView.findViewById(R.id.imageViewItemThumbnail) // Descomentar si añades miniaturas

        fun bind(submissionItem: PendingListItem.SubmissionItem, clickListener: (PendingListItem.SubmissionItem) -> Unit) {
            itemTitle.text = submissionItem.title
            itemDate.text = context.getString(R.string.submission_date_format, dateFormat.format(Date(submissionItem.submissionTimestamp)))

            when (submissionItem.type) {
                PendingContentType.STORY -> {
                    itemTypeIcon.setImageResource(R.drawable.ic_book)
                    // Opcional: Cargar miniatura si es un relato con imagen
                    // submissionItem.contentUrl?.let { url ->
                    //     Glide.with(context).load(url).placeholder(R.drawable.ic_book).into(itemThumbnail)
                    //     itemThumbnail.visibility = View.VISIBLE
                    // } ?: run { itemThumbnail.visibility = View.GONE }
                }
                PendingContentType.IMAGE -> {
                    itemTypeIcon.setImageResource(R.drawable.ic_photo)
                    // Opcional: Cargar miniatura de la imagen
                    // submissionItem.contentUrl?.let { url ->
                    //     Glide.with(context).load(url).placeholder(R.drawable.ic_photo).into(itemThumbnail)
                    //     itemThumbnail.visibility = View.VISIBLE
                    // } ?: run { itemThumbnail.visibility = View.GONE }
                }
                PendingContentType.VIDEO -> {
                    itemTypeIcon.setImageResource(R.drawable.ic_video)
                    // Opcional: Cargar miniatura del video (complementaryImageUrl)
                    // submissionItem.contentUrl?.let { url ->
                    //     Glide.with(context).load(url).placeholder(R.drawable.ic_video).into(itemThumbnail)
                    //     itemThumbnail.visibility = View.VISIBLE
                    // } ?: run { itemThumbnail.visibility = View.GONE }
                }
            }

            itemView.setOnClickListener {
                clickListener(submissionItem)
            }
        }
    }
}

// DiffUtil.ItemCallback para PendingListItem
class PendingDiffCallback : DiffUtil.ItemCallback<PendingListItem>() {
    override fun areItemsTheSame(oldItem: PendingListItem, newItem: PendingListItem): Boolean {
        return when {
            oldItem is PendingListItem.HeaderItem && newItem is PendingListItem.HeaderItem ->
                oldItem.title == newItem.title // Comparar por título para encabezados
            oldItem is PendingListItem.SubmissionItem && newItem is PendingListItem.SubmissionItem ->
                oldItem.id == newItem.id // Comparar por ID único para ítems de envío
            else -> false // Tipos diferentes no son el mismo ítem
        }
    }

    override fun areContentsTheSame(oldItem: PendingListItem, newItem: PendingListItem): Boolean {
        // Para data classes, la comparación por igualdad (==) verifica todas las propiedades.
        return oldItem == newItem
    }
}


===== Archivo: app\src\main\java\com\example\mexicoparanormal\RecordAudioFragment.kt =====


package com.example.mexicoparanormal

import android.Manifest
import android.annotation.SuppressLint
import android.content.ContentValues
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.media.AudioFormat // Para decodificación PCM
import android.media.MediaCodec // Para decodificación y CODIFICACIÓN
import android.media.MediaCodecInfo
import android.media.MediaExtractor // Para decodificación
import android.media.MediaFormat as AndroidMediaFormat // Alias para MediaFormat de Android
import android.media.MediaMetadataRetriever
import android.media.MediaMuxer // Para escribir el archivo M4A
import android.media.MediaRecorder
import android.media.MediaScannerConnection
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.os.Environment
import android.os.Handler
import android.os.Looper
import android.os.StatFs
import android.provider.MediaStore
import android.provider.Settings
import android.util.Log
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.AdapterView
import android.widget.ArrayAdapter
import android.widget.SeekBar
import android.widget.Toast
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AlertDialog
import androidx.core.content.ContextCompat
import androidx.core.net.toUri
import androidx.fragment.app.Fragment
import androidx.lifecycle.lifecycleScope
import com.example.mexicoparanormal.databinding.FragmentRecordAudioBinding
import com.google.android.exoplayer2.ExoPlayer
import com.google.android.exoplayer2.MediaItem
import com.google.android.exoplayer2.PlaybackException
import com.google.android.exoplayer2.PlaybackParameters
import com.google.android.exoplayer2.Player
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.currentCoroutineContext
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.File
import java.io.FileInputStream
import java.io.FileOutputStream
import java.io.IOException
import java.nio.ByteBuffer
import java.nio.ByteOrder
import java.nio.FloatBuffer
import java.nio.ShortBuffer
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale
import java.util.Optional // Importado para Optional<OnnxValue>
import java.util.concurrent.TimeUnit
import kotlin.math.abs
import kotlin.math.cos
import kotlin.math.floor
import kotlin.math.min
import kotlin.math.roundToInt


import ai.onnxruntime.OrtEnvironment
import ai.onnxruntime.OrtSession
import ai.onnxruntime.OrtLoggingLevel
import ai.onnxruntime.OnnxTensor
import ai.onnxruntime.OnnxValue // Importar OnnxValue
import ai.onnxruntime.OrtSession.Result as OrtResult // Alias para el Resultado de ONNX
import ai.onnxruntime.OrtException // Importar OrtException para errores de ONNX

@Suppress("DEPRECATION") // Para MediaRecorder en APIs antiguas
class RecordAudioFragment : Fragment() {

    private var _binding: FragmentRecordAudioBinding? = null
    private val binding get() = _binding!!

    private var mediaRecorder: MediaRecorder? = null
    private var audioFile: File? = null // Archivo M4A original grabado
    private var processedAudioFile: File? = null // Archivo M4A final (potencialmente procesado por IA)
    private var currentRecordingState: RecordingState = RecordingState.IDLE
    private var selectedAudioSourceType: AudioSourceType = AudioSourceType.MIC_NORMAL

    private var exoPlayer: ExoPlayer? = null
    private var currentPlayableAudioUri: Uri? = null
    private var currentPlayableAudioOriginalName: String? = null

    private val playbackSpeeds = floatArrayOf(0.5f, 1.0f, 1.5f, 2.0f)
    private lateinit var playbackSpeedStrings: Array<String> // Se inicializa en onViewCreated
    private var currentSpeedIndex = 1 // Índice para 1.0x

    private var playerPlaybackPosition: Long = 0
    private var playerPlayWhenReady: Boolean = true

    private var recordingChronometer: Long = 0L
    private val recordingTimerHandler = Handler(Looper.getMainLooper())
    private lateinit var recordingTimerRunnable: Runnable
    private val MAX_RECORDING_DURATION_MS: Long = 20 * 60 * 1000 // 20 minutos
    private val ESTIMATED_MAX_RECORDING_SIZE_BYTES: Long = 25 * 1024 * 1024 // Estimación conservadora para M4A/AAC
    private val STORAGE_MARGIN_BYTES: Long = 30 * 1024 * 1024 // Margen extra para archivos temporales PCM

    private val seekBarUpdateHandler = Handler(Looper.getMainLooper())
    private lateinit var runnableUpdateSeekBar: Runnable

    private var currentToast: Toast? = null

    private lateinit var waveformView: WaveformView
    private val amplitudeUpdateHandler = Handler(Looper.getMainLooper())
    private lateinit var amplitudeUpdater: Runnable
    private val AMPLITUDE_UPDATE_INTERVAL_MS: Long = 100

    // Relacionado con ONNX Runtime
    private var ortEnvironment: OrtEnvironment? = null
    private var encSession: OrtSession? = null
    private var dfDecSession: OrtSession? = null
    private var erbDecSession: OrtSession? = null

    // Nombres de archivo para modelos ONNX (constantes internas)
    private val ENC_MODEL_FILE_NAME = "enc.onnx"
    private val DF_DEC_MODEL_FILE_NAME = "df_dec.onnx"
    private val ERB_DEC_MODEL_FILE_NAME = "erb_dec.onnx"

    // Nombres de archivo para archivos temporales (constantes internas)
    private val DECODED_AUDIO_FOR_AI_FILENAME = "decoded_audio_for_ai.pcm"
    private val FINAL_PCM_FOR_ONNX_INPUT_FILENAME = "final_pcm_for_onnx_input.pcm"
    private val ONNX_PROCESSED_AUDIO_OUTPUT_FILENAME = "onnx_processed_audio_output.pcm"
    private val IA_PROCESSED_FILENAME_PREFIX = "IA_processed_"


    private var isAiFeatureNoticeShown = false
    private var aiProcessingJob: Job? = null

    // Constantes para el procesamiento de audio IA
    private val TARGET_SAMPLE_RATE_HZ = 48000 // Frecuencia de muestreo objetivo para la IA y la salida
    private val TARGET_CHANNEL_COUNT = 1 // Mono
    private val TARGET_AUDIO_ENCODING_ANDROID = AudioFormat.ENCODING_PCM_16BIT // PCM 16-bit para procesamiento

    // Parámetros STFT (del config.ini de DeepFilterNet)
    private val DFN_STFT_FFT_SIZE = 960
    private val DFN_STFT_HOP_SIZE = 480 // Este es el importante para calcular el número de tramas (S)

    private val AAC_MIME_TYPE = "audio/mp4a-latm"
    private val AAC_BIT_RATE = 128000 // Bitrate para la codificación AAC


    interface AudioRecordListener {
        fun onAudioRecorded(uri: Uri?, originalFileName: String?)
        fun onRecordingStateChanged(isRecording: Boolean)
        fun onAudioDeleted()
    }
    private var listener: AudioRecordListener? = null

    private enum class RecordingState {
        IDLE, RECORDING, PAUSED, STOPPED, AI_PROCESSING
    }

    private enum class AudioSourceType {
        MIC_NORMAL,
        MIC_AI_ENHANCED
        // Futuro: MIC_VOICE_OPTIMIZED, SYSTEM_AUDIO (Audio del sistema)
    }

    private val requestRecordAudioPermissionLauncher =
        registerForActivityResult(ActivityResultContracts.RequestPermission()) { isGranted: Boolean ->
            if (isGranted) {
                startRecordingFlow()
            } else {
                if (!shouldShowRequestPermissionRationale(Manifest.permission.RECORD_AUDIO) && currentRecordingState != RecordingState.IDLE) {
                    showSafeToast(getString(R.string.error_mic_permission_denied_permanently), Toast.LENGTH_LONG)
                    promptToOpenSettings()
                } else {
                    showSafeToast(getString(R.string.error_mic_permission_denied), Toast.LENGTH_LONG)
                }
                updateUI()
            }
        }

    private val requestWriteStoragePermissionLauncher =
        registerForActivityResult(ActivityResultContracts.RequestPermission()) { isGranted: Boolean ->
            if (isGranted) {
                currentPlayableAudioUri?.let { uri ->
                    val nameToSave = currentPlayableAudioOriginalName ?: getString(R.string.default_filename_unknown_m4a)
                    saveAudioToPublicMusicDirectory(uri, nameToSave)
                }
            } else {
                showSafeToast(getString(R.string.error_write_permission_denied_for_saving))
            }
        }

    override fun onAttach(context: Context) {
        super.onAttach(context)
        listener = context as? AudioRecordListener ?: throw ClassCastException(getString(R.string.error_listener_not_implemented_audiorecord, context.toString()))
    }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        _binding = FragmentRecordAudioBinding.inflate(inflater, container, false)
        waveformView = binding.waveformView
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        setupPlaybackSpeedStrings()
        setupAudioSourceSpinner()
        setupClickListeners()
        initializeRecordingTimerRunnable()
        initializeAmplitudeUpdater()
        initializeSeekBarUpdaterPlayer()
        initializeOnnxRuntime() // Carga los modelos ONNX

        // Restaurar estado si existe
        savedInstanceState?.let {
            currentRecordingState = RecordingState.valueOf(it.getString("recordingState", RecordingState.IDLE.name))
            selectedAudioSourceType = AudioSourceType.valueOf(it.getString("selectedAudioSourceType", AudioSourceType.MIC_NORMAL.name))
            recordingChronometer = it.getLong("recordingChronometer", 0L)
            it.getString("audioFilePath")?.let { path -> audioFile = File(path) }
            it.getString("processedAudioFilePath")?.let { path -> processedAudioFile = File(path) }
            it.getString("currentPlayableAudioUri")?.let { uriString -> currentPlayableAudioUri = uriString.toUri() }
            currentPlayableAudioOriginalName = it.getString("currentPlayableAudioOriginalName")
            playerPlaybackPosition = it.getLong("playerPlaybackPosition", 0L)
            playerPlayWhenReady = it.getBoolean("playerPlayWhenReady", true)
            currentSpeedIndex = it.getInt("currentSpeedIndex", 1)
            isAiFeatureNoticeShown = it.getBoolean("isAiFeatureNoticeShown", false)
        }
        updateUI() // Actualizar UI basado en el estado (restaurado o inicial)
    }

    private fun loadOnnxModel(modelFileName: String): OrtSession? {
        if (context == null || ortEnvironment == null) {
            Log.e(TAG_RECORD_AUDIO, getString(R.string.log_error_load_onnx_context_null, modelFileName))
            return null
        }
        return try {
            val modelFileInCache = File(requireContext().cacheDir, modelFileName)
            if (!modelFileInCache.exists()) {
                requireContext().assets.open(modelFileName).use { inputStream ->
                    FileOutputStream(modelFileInCache).use { outputStream ->
                        inputStream.copyTo(outputStream)
                    }
                }
                Log.d(TAG_RECORD_AUDIO, getString(R.string.log_info_onnx_model_copied_to_cache, modelFileName, modelFileInCache.absolutePath))
            } else {
                Log.d(TAG_RECORD_AUDIO, getString(R.string.log_info_onnx_model_exists_in_cache, modelFileName, modelFileInCache.absolutePath))
            }
            ortEnvironment!!.createSession(modelFileInCache.absolutePath, OrtSession.SessionOptions())
        } catch (e: IOException) {
            Log.e(TAG_RECORD_AUDIO, getString(R.string.log_error_onnx_ioexception, modelFileName), e)
            null
        } catch (e: OrtException) {
            Log.e(TAG_RECORD_AUDIO, getString(R.string.log_error_onnx_ortexception, modelFileName), e)
            null
        } catch (e: Exception) {
            Log.e(TAG_RECORD_AUDIO, getString(R.string.log_error_onnx_unexpected, modelFileName), e)
            null
        }
    }

    private fun initializeOnnxRuntime() {
        if (!isAdded || context == null) return
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                ortEnvironment = OrtEnvironment.getEnvironment(OrtLoggingLevel.ORT_LOGGING_LEVEL_WARNING)
                encSession = loadOnnxModel(ENC_MODEL_FILE_NAME)
                dfDecSession = loadOnnxModel(DF_DEC_MODEL_FILE_NAME)
                erbDecSession = loadOnnxModel(ERB_DEC_MODEL_FILE_NAME)

                withContext(Dispatchers.Main) {
                    if (!isAdded) return@withContext
                    if (encSession != null && dfDecSession != null && erbDecSession != null) {
                        Log.i(TAG_RECORD_AUDIO, getString(R.string.log_info_onnx_models_loaded_successfully))
                    } else {
                        Log.e(TAG_RECORD_AUDIO, getString(R.string.log_error_onnx_failed_to_load_models))
                        showSafeToast(getString(R.string.error_critical_ai_initialization), Toast.LENGTH_LONG)
                    }
                }
            } catch (e: OrtException) {
                Log.e(TAG_RECORD_AUDIO, getString(R.string.log_error_onnx_ortexception_init), e)
                withContext(Dispatchers.Main) { if (isAdded) showSafeToast(getString(R.string.error_critical_ai_initialization_ort), Toast.LENGTH_LONG) }
            } catch (e: Exception) {
                Log.e(TAG_RECORD_AUDIO, getString(R.string.log_error_onnx_critical_init), e)
                withContext(Dispatchers.Main) { if (isAdded) showSafeToast(getString(R.string.error_critical_ai_initialization), Toast.LENGTH_LONG) }
            }
        }
    }


    override fun onResume() {
        super.onResume()
        if (currentPlayableAudioUri != null && currentRecordingState != RecordingState.AI_PROCESSING) {
            if (exoPlayer == null) {
                initializePlayer(currentPlayableAudioUri!!)
            } else {
                exoPlayer?.seekTo(playerPlaybackPosition)
                if (playerPlayWhenReady && exoPlayer?.playbackState != Player.STATE_ENDED) {
                    exoPlayer?.play()
                }
            }
            updatePlayerUI()
        } else if (currentRecordingState != RecordingState.AI_PROCESSING) {
            updateUI()
            if(::waveformView.isInitialized) waveformView.clearWaveform()
        }

        if (currentRecordingState == RecordingState.RECORDING) {
            amplitudeUpdateHandler.post(amplitudeUpdater)
        }
    }

    override fun onPause() {
        super.onPause()
        currentToast?.cancel()

        if (::runnableUpdateSeekBar.isInitialized) {
            seekBarUpdateHandler.removeCallbacks(runnableUpdateSeekBar)
        }

        exoPlayer?.let {
            playerPlaybackPosition = it.currentPosition
            playerPlayWhenReady = it.playWhenReady
            it.pause()
        }

        if (currentRecordingState == RecordingState.RECORDING) {
            amplitudeUpdateHandler.removeCallbacks(amplitudeUpdater)
        }
    }

    override fun onStop() {
        super.onStop()
        if ((currentRecordingState == RecordingState.RECORDING || currentRecordingState == RecordingState.PAUSED) && mediaRecorder != null) {
            amplitudeUpdateHandler.removeCallbacks(amplitudeUpdater)
            stopRecordingFlow(bySystem = true, message = getString(R.string.info_recording_stopped_due_to_app_state))
        }
    }

    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        outState.putString("recordingState", currentRecordingState.name)
        outState.putString("selectedAudioSourceType", selectedAudioSourceType.name)
        outState.putLong("recordingChronometer", recordingChronometer)
        audioFile?.absolutePath?.let { outState.putString("audioFilePath", it) }
        processedAudioFile?.absolutePath?.let { outState.putString("processedAudioFilePath", it) }
        currentPlayableAudioUri?.toString()?.let { outState.putString("currentPlayableAudioUri", it) }
        outState.putString("currentPlayableAudioOriginalName", currentPlayableAudioOriginalName)
        exoPlayer?.let {
            outState.putLong("playerPlaybackPosition", it.currentPosition)
            outState.putBoolean("playerPlayWhenReady", it.playWhenReady)
        }
        outState.putInt("currentSpeedIndex", currentSpeedIndex)
        outState.putBoolean("isAiFeatureNoticeShown", isAiFeatureNoticeShown)
    }

    override fun onDestroyView() {
        super.onDestroyView()
        recordingTimerHandler.removeCallbacks(recordingTimerRunnable)
        amplitudeUpdateHandler.removeCallbacks(amplitudeUpdater)
        releaseMediaRecorder()
        releasePlayer()
        aiProcessingJob?.cancel()

        try {
            encSession?.close()
            dfDecSession?.close()
            erbDecSession?.close()
            ortEnvironment?.close()
            Log.d(TAG_RECORD_AUDIO, getString(R.string.log_onnx_resources_closed_successfully))
        } catch (e: Exception) {
            Log.e(TAG_RECORD_AUDIO, getString(R.string.log_onnx_resources_error_closing), e)
        }
        encSession = null
        dfDecSession = null
        erbDecSession = null
        ortEnvironment = null

        currentToast?.cancel()
        _binding = null
    }

    override fun onDetach() {
        super.onDetach()
        listener = null
    }

    private fun showSafeToast(message: String, duration: Int = Toast.LENGTH_SHORT) {
        if(isAdded && context != null) {
            currentToast?.cancel()
            currentToast = Toast.makeText(requireContext(), message, duration)
            currentToast?.show()
        }
    }

    private fun showAlertDialog(title: String, message: String) {
        if (!isAdded) return
        AlertDialog.Builder(requireContext())
            .setTitle(title)
            .setMessage(message)
            .setPositiveButton(getString(R.string.dialog_ok), null)
            .show()
    }

    private fun promptToOpenSettings() {
        if (!isAdded) return
        AlertDialog.Builder(requireContext())
            .setTitle(getString(R.string.permission_dialog_title))
            .setMessage(getString(R.string.error_mic_permission_denied_permanently_prompt))
            .setPositiveButton(getString(R.string.action_open_settings)) { _, _ ->
                val intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS).apply {
                    data = Uri.fromParts("package", requireActivity().packageName, null)
                }
                startActivity(intent)
            }
            .setNegativeButton(getString(R.string.cancelar), null)
            .show()
    }

    private fun setupPlaybackSpeedStrings() {
        // Los valores como "0.5x" se mantienen, "1x" se obtiene de resources
        playbackSpeedStrings = arrayOf("0.5x", getString(R.string.text_playback_speed_1x), "1.5x", "2x")
    }

    private fun setupAudioSourceSpinner() {
        val sources = listOf(
            getString(R.string.audio_source_mic),
            getString(R.string.audio_source_mic_ai)
        )
        val adapter = ArrayAdapter(requireContext(), R.layout.spinner_item, sources).apply {
            setDropDownViewResource(R.layout.spinner_dropdown_item)
        }
        binding.spinnerAudioSource.adapter = adapter
        binding.spinnerAudioSource.setSelection(0) // Por defecto Micrófono Clásico

        binding.spinnerAudioSource.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
            override fun onItemSelected(parent: AdapterView<*>?, view: View?, position: Int, id: Long) {
                selectedAudioSourceType = when (position) {
                    1 -> AudioSourceType.MIC_AI_ENHANCED
                    else -> AudioSourceType.MIC_NORMAL
                }
                Log.d(TAG_RECORD_AUDIO, getString(R.string.log_audio_source_selected, selectedAudioSourceType.name))

                if (selectedAudioSourceType == AudioSourceType.MIC_AI_ENHANCED && !isAiFeatureNoticeShown && isAdded) {
                    if (encSession == null || dfDecSession == null || erbDecSession == null) {
                        showAlertDialog(getString(R.string.audio_source_mic_ai), getString(R.string.error_critical_ai_initialization))
                    } else {
                        AlertDialog.Builder(requireContext())
                            .setTitle(getString(R.string.audio_source_mic_ai)) // Título para el diálogo de IA
                            .setMessage(getString(R.string.info_ai_feature_experimental))
                            .setPositiveButton(getString(R.string.dialog_ok)) { _, _ -> isAiFeatureNoticeShown = true }
                            .setCancelable(false)
                            .show()
                    }
                }
            }
            override fun onNothingSelected(parent: AdapterView<*>?) {
                selectedAudioSourceType = AudioSourceType.MIC_NORMAL // Volver a por defecto
            }
        }
    }

    private fun setupClickListeners() {
        binding.btnStartStopRecording.setOnClickListener {
            if (currentRecordingState == RecordingState.AI_PROCESSING) {
                showSafeToast(getString(R.string.info_ai_processing_audio))
                return@setOnClickListener
            }

            if (selectedAudioSourceType == AudioSourceType.MIC_AI_ENHANCED && (encSession == null || dfDecSession == null || erbDecSession == null)) {
                showAlertDialog(getString(R.string.audio_source_mic_ai), getString(R.string.error_critical_ai_initialization))
                return@setOnClickListener
            }

            when (currentRecordingState) {
                RecordingState.IDLE, RecordingState.STOPPED -> {
                    when {
                        ContextCompat.checkSelfPermission(requireContext(), Manifest.permission.RECORD_AUDIO) == PackageManager.PERMISSION_GRANTED -> {
                            startRecordingFlow()
                        }
                        shouldShowRequestPermissionRationale(Manifest.permission.RECORD_AUDIO) -> {
                            AlertDialog.Builder(requireContext())
                                .setTitle(getString(R.string.permission_dialog_title))
                                .setMessage(getString(R.string.permission_dialog_mic_rationale))
                                .setPositiveButton(getString(R.string.permission_dialog_grant)) { _, _ ->
                                    requestRecordAudioPermissionLauncher.launch(Manifest.permission.RECORD_AUDIO)
                                }
                                .setNegativeButton(getString(R.string.cancelar), null)
                                .show()
                        }
                        else -> {
                            requestRecordAudioPermissionLauncher.launch(Manifest.permission.RECORD_AUDIO)
                        }
                    }
                }
                RecordingState.RECORDING, RecordingState.PAUSED -> {
                    stopRecordingFlow()
                }
                else -> { /* No hacer nada para AI_PROCESSING aquí, ya se maneja arriba */ }
            }
        }

        binding.btnPauseResumeRecording.setOnClickListener {
            if (currentRecordingState == RecordingState.RECORDING) {
                pauseRecordingFlow()
            } else if (currentRecordingState == RecordingState.PAUSED) {
                resumeRecordingFlow()
            }
        }

        binding.btnPlayRecordedAudio.setOnClickListener { exoPlayer?.play() }
        binding.btnPauseRecordedAudio.setOnClickListener { exoPlayer?.pause() }
        binding.btnDeleteRecordedAudio.setOnClickListener { deleteRecordedAudio() }
        binding.tvPlaybackSpeedRecorded.setOnClickListener { cyclePlaybackSpeed() }

        binding.btnSaveLocalAudio?.setOnClickListener {
            currentPlayableAudioUri?.let { uri ->
                val nameToSave = currentPlayableAudioOriginalName ?: getString(R.string.default_filename_unknown_m4a)
                saveAudioToPublicMusicDirectory(uri, nameToSave)
            } ?: showSafeToast(getString(R.string.info_no_recording_to_save))
        }

        binding.seekBarRecordedAudio.setOnSeekBarChangeListener(object : SeekBar.OnSeekBarChangeListener {
            override fun onProgressChanged(seekBar: SeekBar?, progress: Int, fromUser: Boolean) {
                if (fromUser && exoPlayer != null) {
                    exoPlayer?.seekTo(progress.toLong())
                }
            }
            override fun onStartTrackingTouch(seekBar: SeekBar?) {}
            override fun onStopTrackingTouch(seekBar: SeekBar?) {}
        })
    }

    private fun hasSufficientStorage(requiredBytes: Long): Boolean {
        if (!isAdded) return false
        val cacheDir = requireContext().cacheDir ?: return false // Usar cacheDir que es más seguro
        return try {
            val stat = StatFs(cacheDir.path)
            val availableBytes = stat.availableBlocksLong * stat.blockSizeLong
            availableBytes > (requiredBytes + STORAGE_MARGIN_BYTES) // Margen de seguridad
        } catch (e: IllegalArgumentException) {
            Log.e(TAG_RECORD_AUDIO, getString(R.string.log_error_check_storage_illegal_arg), e)
            false // Asumir que no hay espacio si hay error
        } catch (e: Exception) {
            Log.e(TAG_RECORD_AUDIO, getString(R.string.log_error_check_storage_unexpected), e)
            false
        }
    }

    private fun startRecordingFlow() {
        if (!isAdded) return

        if (!hasSufficientStorage(ESTIMATED_MAX_RECORDING_SIZE_BYTES)) {
            showAlertDialog(getString(R.string.error_insufficient_storage_title), getString(R.string.error_insufficient_storage_message))
            return
        }

        if (currentPlayableAudioUri != null) { // Si ya hay una grabación
            AlertDialog.Builder(requireContext())
                .setTitle(getString(R.string.dialog_confirm_new_recording_title))
                .setMessage(getString(R.string.dialog_confirm_new_recording_message))
                .setPositiveButton(getString(R.string.dialog_yes)) { _, _ ->
                    deleteRecordedAudio(notifyListener = false) // No notificar al listener aún
                    actuallyStartRecording()
                }
                .setNegativeButton(getString(R.string.dialog_no), null)
                .show()
        } else {
            actuallyStartRecording()
        }
    }

    @SuppressLint("NewApi") // Para MediaRecorder(Context)
    private fun actuallyStartRecording() {
        if (!isAdded || context == null) return

        val rawFileName = "${getString(R.string.file_name_prefix)}${SimpleDateFormat(getString(R.string.file_name_date_format), Locale.getDefault()).format(Date())}${getString(R.string.file_extension_m4a)}"
        val cacheDir = requireContext().cacheDir ?: run {
            handleRecordingStartError(getString(R.string.error_cache_dir_unavailable))
            return
        }

        mediaRecorder = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) MediaRecorder(requireContext()) else @Suppress("DEPRECATION") MediaRecorder()

        mediaRecorder?.apply {
            setAudioSource(MediaRecorder.AudioSource.MIC)
            setOutputFormat(MediaRecorder.OutputFormat.MPEG_4) // Contenedor M4A
            setAudioEncoder(MediaRecorder.AudioEncoder.AAC)   // Códec AAC
            setAudioEncodingBitRate(AAC_BIT_RATE)             // Bitrate para AAC
            setAudioChannels(TARGET_CHANNEL_COUNT)            // Mono

            // Intentar establecer la frecuencia de muestreo deseada
            try {
                setAudioSamplingRate(TARGET_SAMPLE_RATE_HZ)
                Log.i(TAG_RECORD_AUDIO, getString(R.string.log_mediarecorder_configured_at_samplerate, TARGET_SAMPLE_RATE_HZ))
            } catch (e: Exception) {
                Log.w(TAG_RECORD_AUDIO, getString(R.string.log_mediarecorder_failed_to_set_samplerate_fallback, TARGET_SAMPLE_RATE_HZ), e)
                setAudioSamplingRate(44100) // Fallback a 44.1kHz si falla
            }

            audioFile = File(cacheDir, rawFileName)
            currentPlayableAudioOriginalName = rawFileName // Guardar nombre original para UI
            setOutputFile(audioFile!!.absolutePath)
            setMaxDuration(MAX_RECORDING_DURATION_MS.toInt() + 1000) // Un pequeño margen

            setOnErrorListener { mr, what, extra ->
                amplitudeUpdateHandler.removeCallbacks(amplitudeUpdater)
                val errorMsg = when(what) {
                    MediaRecorder.MEDIA_RECORDER_ERROR_UNKNOWN -> getString(R.string.error_media_recorder_unknown)
                    MediaRecorder.MEDIA_ERROR_SERVER_DIED -> getString(R.string.error_media_server_died)
                    else -> getString(R.string.error_start_recording_with_code, what, extra)
                }
                Log.e(TAG_RECORD_AUDIO, "MediaRecorder.OnErrorListener: what=$what, extra=$extra, message='$errorMsg'")
                stopRecordingFlow(bySystem = true, message = errorMsg)
            }
            setOnInfoListener { mr, what, extra ->
                if (what == MediaRecorder.MEDIA_RECORDER_INFO_MAX_DURATION_REACHED) {
                    amplitudeUpdateHandler.removeCallbacks(amplitudeUpdater)
                    stopRecordingFlow(bySystem = false, message = getString(R.string.info_max_duration_reached, MAX_RECORDING_DURATION_MS / (60 * 1000)))
                }
            }

            try {
                prepare()
                start()
                currentRecordingState = RecordingState.RECORDING
                recordingChronometer = 0L // Reiniciar cronómetro
                binding.tvRecordingTimer.text = formatDuration(0L, MAX_RECORDING_DURATION_MS, currentRecordingState, true)
                recordingTimerHandler.post(recordingTimerRunnable)
                if(::waveformView.isInitialized) waveformView.clearWaveform() // Limpiar forma de onda
                amplitudeUpdateHandler.post(amplitudeUpdater) // Iniciar actualizador de amplitud
                listener?.onRecordingStateChanged(isRecording = true)
                updateUI()
                showSafeToast(getString(R.string.recording_status_recording))
            } catch (ioe: IOException) {
                Log.e(TAG_RECORD_AUDIO, "IOException durante prepare/start de MediaRecorder.", ioe)
                handleRecordingStartError(getString(R.string.error_media_recorder_prepare_io, ioe.localizedMessage ?: getString(R.string.unknown_error)))
            } catch (ise: IllegalStateException) {
                Log.e(TAG_RECORD_AUDIO, "IllegalStateException durante prepare/start de MediaRecorder.", ise)
                handleRecordingStartError(getString(R.string.error_media_recorder_start_state, ise.localizedMessage ?: getString(R.string.unknown_error)))
            } catch (se: SecurityException) { // Aunque ya se verifica el permiso, por si acaso
                Log.e(TAG_RECORD_AUDIO, "SecurityException durante prepare/start de MediaRecorder.", se)
                handleRecordingStartError(getString(R.string.error_mic_permission_denied) + " (SecurityException)")
            } catch (e: Exception) { // Captura genérica
                Log.e(TAG_RECORD_AUDIO, "Excepción inesperada durante prepare/start de MediaRecorder.", e)
                handleRecordingStartError(getString(R.string.error_start_recording_generic, e.localizedMessage ?: getString(R.string.unknown_error)))
            }
        }
    }

    private fun handleRecordingStartError(errorMessage: String) {
        releaseMediaRecorder()
        amplitudeUpdateHandler.removeCallbacks(amplitudeUpdater)
        currentRecordingState = RecordingState.IDLE
        listener?.onRecordingStateChanged(isRecording = false)
        updateUI()
        showAlertDialog(getString(R.string.error_dialog_title), errorMessage)
    }

    @SuppressLint("NewApi") // Para MediaRecorder.pause/resume
    private fun pauseRecordingFlow() {
        if (currentRecordingState != RecordingState.RECORDING || mediaRecorder == null) return
        try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
                mediaRecorder?.pause()
                currentRecordingState = RecordingState.PAUSED
                recordingTimerHandler.removeCallbacks(recordingTimerRunnable) // Detener cronómetro
                amplitudeUpdateHandler.removeCallbacks(amplitudeUpdater) // Detener actualización de amplitud
                updateUI()
                showSafeToast(getString(R.string.recording_paused_status))
            } else {
                showSafeToast(getString(R.string.error_pause_not_supported))
            }
        } catch (e: IllegalStateException) {
            Log.e(TAG_RECORD_AUDIO, "IllegalStateException al pausar MediaRecorder.", e)
            showSafeToast(getString(R.string.error_pause_recording_specific, e.localizedMessage ?: getString(R.string.unknown_error)))
        } catch (e: Exception) {
            Log.e(TAG_RECORD_AUDIO, "Error inesperado al pausar MediaRecorder.", e)
            showSafeToast(getString(R.string.error_pause_recording_specific, e.localizedMessage ?: getString(R.string.unknown_error)))
        }
    }

    @SuppressLint("NewApi") // Para MediaRecorder.pause/resume
    private fun resumeRecordingFlow() {
        if (currentRecordingState != RecordingState.PAUSED || mediaRecorder == null) return
        try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
                mediaRecorder?.resume()
                currentRecordingState = RecordingState.RECORDING
                recordingTimerHandler.post(recordingTimerRunnable) // Reanudar cronómetro
                amplitudeUpdateHandler.post(amplitudeUpdater) // Reanudar actualización de amplitud
                updateUI()
                showSafeToast(getString(R.string.recording_status_recording)) // Reutilizar string
            }
        } catch (e: IllegalStateException) {
            Log.e(TAG_RECORD_AUDIO, "IllegalStateException al reanudar MediaRecorder.", e)
            showSafeToast(getString(R.string.error_resume_recording_specific, e.localizedMessage ?: getString(R.string.unknown_error)))
        } catch (e: Exception) {
            Log.e(TAG_RECORD_AUDIO, "Error inesperado al reanudar MediaRecorder.", e)
            showSafeToast(getString(R.string.error_resume_recording_specific, e.localizedMessage ?: getString(R.string.unknown_error)))
        }
    }

    private fun stopRecordingFlow(bySystem: Boolean = false, message: String? = null) {
        if (currentRecordingState == RecordingState.IDLE && mediaRecorder == null) return // Ya está detenido o nunca empezó

        val previousState = currentRecordingState
        val finalChronometerValue = recordingChronometer // Guardar valor antes de resetear

        recordingTimerHandler.removeCallbacks(recordingTimerRunnable)
        amplitudeUpdateHandler.removeCallbacks(amplitudeUpdater)

        var stopErrorOccurred = false
        try {
            mediaRecorder?.stop()
        } catch (e: RuntimeException) {
            Log.e(TAG_RECORD_AUDIO, "RuntimeException al detener MediaRecorder.", e)
            stopErrorOccurred = true
        } catch (e: IllegalStateException) {
            Log.e(TAG_RECORD_AUDIO, "IllegalStateException al detener MediaRecorder.", e)
            stopErrorOccurred = true
        } catch (e: Exception) {
            Log.e(TAG_RECORD_AUDIO, "Error inesperado al detener MediaRecorder.", e)
            stopErrorOccurred = true
        } finally {
            releaseMediaRecorder() // Siempre liberar el grabador

            if (stopErrorOccurred) {
                handleStopError(bySystem, message ?: getString(R.string.error_stop_recording_failed_critical))
            } else if (audioFile?.exists() == true && audioFile!!.length() > 0) {
                // El archivo de audio existe y tiene contenido
                val baseFileName = currentPlayableAudioOriginalName ?: audioFile!!.name // Usar nombre original guardado o el del archivo
                if (selectedAudioSourceType == AudioSourceType.MIC_AI_ENHANCED) {
                    processAudioWithAI(audioFile!!, baseFileName, finalChronometerValue, bySystem, message)
                } else {
                    finalizeRecording(audioFile!!, baseFileName, finalChronometerValue, bySystem, message)
                }
            } else {
                // El archivo no existe o está vacío
                handleStopError(bySystem, message ?: getString(R.string.error_no_audio_recorded_after_stop))
            }

            // Notificar al listener solo si estaba grabando o pausado
            if (previousState == RecordingState.RECORDING || previousState == RecordingState.PAUSED) {
                listener?.onRecordingStateChanged(isRecording = false)
            }
        }
    }

    private fun handleStopError(bySystem: Boolean, errorMessage: String) {
        audioFile?.delete(); audioFile = null
        processedAudioFile?.delete(); processedAudioFile = null
        currentPlayableAudioUri = null; currentPlayableAudioOriginalName = null
        recordingChronometer = 0L // Resetear cronómetro
        if(::waveformView.isInitialized) waveformView.clearWaveform()
        currentRecordingState = RecordingState.STOPPED // Cambiar a STOPPED para reflejar el intento de detener
        updateUI()
        if (!bySystem) { // Mostrar error solo si no fue por el sistema (ej. cambio de app)
            listener?.onAudioRecorded(null, null) // Notificar que no hay audio
            showAlertDialog(getString(R.string.error_dialog_title), errorMessage)
        }
    }

    private fun finalizeRecording(finalAudioFileToUse: File, finalFileNameToUse: String?, durationMs: Long, bySystem: Boolean, message: String?) {
        currentPlayableAudioUri = Uri.fromFile(finalAudioFileToUse)
        currentPlayableAudioOriginalName = finalFileNameToUse
        Log.d(TAG_RECORD_AUDIO, getString(R.string.log_finalize_recording_details, currentPlayableAudioUri.toString(), currentPlayableAudioOriginalName, durationMs.toString()))

        if (isAdded) { // Asegurar que el fragmento está añadido
            currentRecordingState = RecordingState.STOPPED
            initializePlayer(currentPlayableAudioUri!!) // Inicializar reproductor con el audio final
            if (!bySystem) { // Notificar al listener solo si no fue una detención por el sistema
                listener?.onAudioRecorded(currentPlayableAudioUri, currentPlayableAudioOriginalName)
            }
            val toastMessage = message ?: if (!bySystem) getString(R.string.status_finished) else null
            toastMessage?.let { showSafeToast(it, Toast.LENGTH_LONG) }

            // Actualizar temporizador para mostrar duración final
            binding.tvRecordingTimer.text = formatDuration(durationMs, 0L, RecordingState.STOPPED, true)
            updateUI()
        } else {
            Log.w(TAG_RECORD_AUDIO, getString(R.string.log_finalize_recording_fragment_not_attached))
        }
    }

    private fun processAudioWithAI(inputFile: File, baseOutputName: String, durationMs: Long, bySystem: Boolean, originalMessage: String?) {
        if (!isAdded || encSession == null || dfDecSession == null || erbDecSession == null) {
            Log.e(TAG_RECORD_AUDIO, getString(R.string.log_process_audio_with_ai_aborted))
            finalizeRecording(inputFile, baseOutputName, durationMs, bySystem, originalMessage ?: getString(R.string.status_finished)) // Usar audio original
            if (isAdded && (encSession == null || dfDecSession == null || erbDecSession == null)) {
                showAlertDialog(getString(R.string.error_dialog_title), getString(R.string.error_critical_ai_initialization_sessions))
            }
            return
        }

        currentRecordingState = RecordingState.AI_PROCESSING
        updateUI()
        showSafeToast(getString(R.string.info_ai_processing_audio), Toast.LENGTH_LONG)

        aiProcessingJob = lifecycleScope.launch {
            Log.d(TAG_RECORD_AUDIO, getString(R.string.log_process_audio_with_ai_starting, inputFile.name))

            val enhancedFile = runAiEnhancement(inputFile) // Esta función es suspend

            withContext(Dispatchers.Main) { // Volver al hilo principal para actualizar UI
                if (!isAdded) return@withContext // Comprobar de nuevo si el fragmento está añadido
                aiProcessingJob = null // Limpiar referencia al job
                if (enhancedFile != null) {
                    processedAudioFile = enhancedFile // Guardar referencia al archivo procesado
                    finalizeRecording(enhancedFile, IA_PROCESSED_FILENAME_PREFIX + baseOutputName, durationMs, bySystem, getString(R.string.info_ai_audio_processed))
                } else {
                    // Si el procesamiento IA falla, usar el archivo original
                    showAlertDialog(getString(R.string.error_dialog_title), getString(R.string.error_ai_processing_failed))
                    finalizeRecording(inputFile, baseOutputName, durationMs, bySystem, originalMessage ?: getString(R.string.status_finished))
                }
            }
        }
    }

    // Estructura de datos para el resultado de la decodificación PCM
    data class PcmAudioData(val file: File, val sampleRate: Int, val channelCount: Int, val bitDepth: Int = 16)

    // Decodifica M4A a PCM crudo
    private suspend fun decodeM4aToPcm(inputFile: File, outputFile: File): PcmAudioData? = withContext(Dispatchers.IO) {
        if (!currentCoroutineContext().isActive || !isAdded || context == null) {
            Log.w(TAG_RECORD_AUDIO, getString(R.string.log_decode_m4a_to_pcm_coroutine_inactive, inputFile.name))
            return@withContext null
        }
        Log.d(TAG_RECORD_AUDIO, getString(R.string.log_decode_m4a_to_pcm_starting, inputFile.name, outputFile.name))

        var extractor: MediaExtractor? = null
        var codec: MediaCodec? = null
        var pcmSampleRate = -1
        var pcmChannelCount = -1
        val timeoutUs = 10000L // 10ms

        try {
            extractor = MediaExtractor()
            extractor.setDataSource(inputFile.absolutePath)

            var trackIndex = -1
            var inputFormat: AndroidMediaFormat? = null
            for (i in 0 until extractor.trackCount) {
                val format = extractor.getTrackFormat(i)
                if (format.getString(AndroidMediaFormat.KEY_MIME)?.startsWith("audio/") == true) {
                    trackIndex = i
                    inputFormat = format
                    break
                }
            }

            if (trackIndex == -1 || inputFormat == null) {
                Log.e(TAG_RECORD_AUDIO, getString(R.string.log_decode_m4a_to_pcm_no_audio_track, inputFile.name))
                return@withContext null
            }

            pcmSampleRate = inputFormat.getInteger(AndroidMediaFormat.KEY_SAMPLE_RATE)
            pcmChannelCount = inputFormat.getInteger(AndroidMediaFormat.KEY_CHANNEL_COUNT)
            Log.i(TAG_RECORD_AUDIO, getString(R.string.log_decode_m4a_to_pcm_input_format, pcmSampleRate.toString(), pcmChannelCount.toString(), inputFile.name))

            extractor.selectTrack(trackIndex)
            val mimeType = inputFormat.getString(AndroidMediaFormat.KEY_MIME)!!
            codec = MediaCodec.createDecoderByType(mimeType)
            codec.configure(inputFormat, null, null, 0)
            codec.start()

            FileOutputStream(outputFile).use { fos ->
                val bufferInfo = MediaCodec.BufferInfo()
                var sawInputEOS = false // Indicador de fin de stream de entrada
                var sawOutputEOS = false // Indicador de fin de stream de salida

                // Bucle de decodificación
                while (!sawOutputEOS && currentCoroutineContext().isActive) {
                    // Alimentar datos al decodificador
                    if (!sawInputEOS) {
                        val inputBufferId = codec.dequeueInputBuffer(timeoutUs)
                        if (inputBufferId >= 0) {
                            val inputBuffer = codec.getInputBuffer(inputBufferId)
                            if (inputBuffer != null) {
                                val sampleSize = extractor.readSampleData(inputBuffer, 0)
                                if (sampleSize < 0) { // Fin del stream
                                    codec.queueInputBuffer(inputBufferId, 0, 0, 0L, MediaCodec.BUFFER_FLAG_END_OF_STREAM)
                                    sawInputEOS = true
                                } else if (sampleSize > 0) {
                                    codec.queueInputBuffer(inputBufferId, 0, sampleSize, extractor.sampleTime, 0)
                                    extractor.advance()
                                } else { // sampleSize == 0, no es EOS pero no hay datos
                                    codec.queueInputBuffer(inputBufferId, 0, 0, extractor.sampleTime, 0)
                                }
                            }
                        }
                    }

                    // Obtener datos decodificados
                    val outputBufferId = codec.dequeueOutputBuffer(bufferInfo, timeoutUs)
                    when (outputBufferId) {
                        MediaCodec.INFO_OUTPUT_FORMAT_CHANGED -> {
                            val newFormat = codec.outputFormat
                            pcmSampleRate = newFormat.getInteger(AndroidMediaFormat.KEY_SAMPLE_RATE)
                            pcmChannelCount = newFormat.getInteger(AndroidMediaFormat.KEY_CHANNEL_COUNT)
                            Log.i(TAG_RECORD_AUDIO, getString(R.string.log_decode_m4a_to_pcm_decoder_output_format_changed, inputFile.name, pcmSampleRate.toString(), pcmChannelCount.toString()))
                        }
                        MediaCodec.INFO_TRY_AGAIN_LATER -> { /* No hacer nada, reintentar */ }
                        else -> {
                            if (outputBufferId >= 0) {
                                if (bufferInfo.flags and MediaCodec.BUFFER_FLAG_END_OF_STREAM != 0) {
                                    sawOutputEOS = true
                                }
                                if (bufferInfo.size > 0) {
                                    val outputBuffer = codec.getOutputBuffer(outputBufferId)
                                    if (outputBuffer != null) {
                                        val pcmChunk = ByteArray(bufferInfo.size)
                                        outputBuffer.get(pcmChunk)
                                        outputBuffer.clear()
                                        fos.write(pcmChunk) // Escribir chunk PCM al archivo de salida
                                    }
                                }
                                codec.releaseOutputBuffer(outputBufferId, false) // Liberar buffer
                            }
                        }
                    }
                }
            }
            Log.i(TAG_RECORD_AUDIO, getString(R.string.log_decode_m4a_to_pcm_completed, inputFile.name, outputFile.absolutePath))
            return@withContext PcmAudioData(outputFile, pcmSampleRate, pcmChannelCount)
        } catch (e: IOException) {
            Log.e(TAG_RECORD_AUDIO, getString(R.string.log_decode_m4a_to_pcm_ioexception, inputFile.name), e)
            outputFile.delete() // Eliminar archivo parcial si falla
            return@withContext null
        } catch (e: IllegalStateException) {
            Log.e(TAG_RECORD_AUDIO, getString(R.string.log_decode_m4a_to_pcm_illegalstate, inputFile.name), e)
            outputFile.delete()
            return@withContext null
        } catch (e: IllegalArgumentException) {
            Log.e(TAG_RECORD_AUDIO, getString(R.string.log_decode_m4a_to_pcm_illegalargument, inputFile.name), e)
            outputFile.delete()
            return@withContext null
        } catch (e: SecurityException) { // Podría ocurrir con MediaDrm o problemas de acceso
            Log.e(TAG_RECORD_AUDIO, getString(R.string.log_decode_m4a_to_pcm_securityexception, inputFile.name), e)
            outputFile.delete()
            return@withContext null
        } catch (e: Exception) { // Captura genérica para errores inesperados
            Log.e(TAG_RECORD_AUDIO, getString(R.string.log_decode_m4a_to_pcm_unexpected_error, inputFile.name), e)
            outputFile.delete()
            return@withContext null
        } finally {
            try { codec?.stop(); codec?.release() } catch (e: Exception) {Log.e(TAG_RECORD_AUDIO, getString(R.string.log_decode_m4a_to_pcm_error_releasing_codec, inputFile.name), e)}
            try { extractor?.release() } catch (e: Exception) {Log.e(TAG_RECORD_AUDIO, getString(R.string.log_decode_m4a_to_pcm_error_releasing_extractor, inputFile.name), e)}
        }
    }

    // Objeto para utilidades de remuestreo y conversión de canales
    object Resampler {
        // Remuestrea audio PCM (solo mono a mono por ahora)
        fun resample(
            context: Context, // <--- AÑADIDO CONTEXTO
            pcmInputData: ByteArray,
            inputSampleRate: Int,
            inputChannelCount: Int,
            targetSampleRate: Int,
            targetChannelCount: Int
        ): ByteArray? {
            Log.d(TAG_RESAMPLER, context.getString(R.string.log_resampler_attempting_resample, inputSampleRate.toString(), inputChannelCount.toString(), targetSampleRate.toString(), targetChannelCount.toString()))
            if (inputChannelCount != 1 || targetChannelCount != 1) {
                Log.e(TAG_RESAMPLER, context.getString(R.string.log_resampler_mono_only, inputChannelCount.toString(), targetChannelCount.toString()))
                return null // Este resampleador simple solo soporta MONO a MONO
            }

            if (inputSampleRate == targetSampleRate) {
                Log.d(TAG_RESAMPLER, context.getString(R.string.log_resampler_rates_identical, inputSampleRate.toString()))
                return pcmInputData // No se necesita remuestreo
            }
            if (pcmInputData.isEmpty()) return ByteArray(0)

            // Convertir bytes a shorts (asumiendo PCM 16-bit Little Endian)
            val inputShorts = ShortArray(pcmInputData.size / 2)
            ByteBuffer.wrap(pcmInputData).order(ByteOrder.LITTLE_ENDIAN).asShortBuffer().get(inputShorts)

            if (inputShorts.isEmpty()) return ByteArray(0)

            // Calcular número de muestras de salida
            val numOutputSamples = (inputShorts.size.toDouble() * targetSampleRate.toDouble() / inputSampleRate.toDouble()).roundToInt()
            if (numOutputSamples == 0) return ByteArray(0)

            val outputShorts = ShortArray(numOutputSamples)
            val ratio = inputSampleRate.toDouble() / targetSampleRate.toDouble()

            // Interpolación lineal simple
            for (i in 0 until numOutputSamples) {
                val srcIndexFloat = i.toDouble() * ratio
                val srcIndex1 = floor(srcIndexFloat).toInt()
                var srcIndex2 = srcIndex1 + 1

                if (srcIndex1 >= inputShorts.size) { // Evitar IndexOutOfBounds
                    outputShorts[i] = inputShorts.lastOrNull() ?: 0 // Usar la última muestra o 0
                    continue
                }
                if (srcIndex2 >= inputShorts.size) { // Asegurar que srcIndex2 esté dentro de los límites
                    srcIndex2 = inputShorts.size - 1
                }

                val fraction = srcIndexFloat - srcIndex1
                val val1 = inputShorts[srcIndex1].toDouble()
                val val2 = inputShorts[srcIndex2].toDouble()
                outputShorts[i] = (val1 + fraction * (val2 - val1)).roundToInt().toShort()
            }

            // Convertir shorts de salida a bytes
            val outputByteBuffer = ByteBuffer.allocate(outputShorts.size * 2).order(ByteOrder.LITTLE_ENDIAN)
            outputByteBuffer.asShortBuffer().put(outputShorts)
            Log.d(TAG_RESAMPLER, context.getString(R.string.log_resampler_complete, inputShorts.size.toString(), numOutputSamples.toString()))
            return outputByteBuffer.array()
        }

        // Convierte PCM estéreo a mono promediando canales
        fun stereoToMono(context: Context, stereoPcmData: ByteArray): ByteArray? { // <--- AÑADIDO CONTEXTO
            if (stereoPcmData.size % 4 != 0) { // Cada muestra estéreo (L+R) son 4 bytes (2 por short)
                Log.e(TAG_RESAMPLER, context.getString(R.string.log_stereo_to_mono_invalid_size, stereoPcmData.size.toString()))
                return null
            }
            if (stereoPcmData.isEmpty()) return ByteArray(0)

            val numMonoSamples = stereoPcmData.size / 4 // Número de muestras mono resultantes
            val monoShorts = ShortArray(numMonoSamples)
            val stereoShortBuffer = ByteBuffer.wrap(stereoPcmData).order(ByteOrder.LITTLE_ENDIAN).asShortBuffer()

            for (i in 0 until numMonoSamples) {
                val left = stereoShortBuffer.get(i * 2).toInt()
                val right = stereoShortBuffer.get(i * 2 + 1).toInt()
                monoShorts[i] = ((left + right) / 2).toShort() // Promedio simple
            }

            val monoByteBuffer = ByteBuffer.allocate(monoShorts.size * 2).order(ByteOrder.LITTLE_ENDIAN)
            monoByteBuffer.asShortBuffer().put(monoShorts)
            Log.d(TAG_RESAMPLER, context.getString(R.string.log_stereo_to_mono_complete, numMonoSamples.toString()))
            return monoByteBuffer.array()
        }
    }


    // Ejecuta el pipeline de mejora de audio con IA (ONNX)
    private suspend fun runAiEnhancement(inputFile: File): File? = withContext(Dispatchers.IO) {
        if (!currentCoroutineContext().isActive) return@withContext null // Salir si la corrutina está cancelada
        val currentContext = context ?: return@withContext null // Necesario para cacheDir y Resampler
        Log.d(TAG_RECORD_AUDIO, getString(R.string.log_run_ai_enhancement_starting, inputFile.absolutePath))

        // Nombres de archivo para los pasos intermedios
        val decodedPcmFile = File(currentContext.cacheDir, DECODED_AUDIO_FOR_AI_FILENAME)
        val finalPcmForOnnxInput = File(currentContext.cacheDir, FINAL_PCM_FOR_ONNX_INPUT_FILENAME)
        val onnxProcessedPcmFile = File(currentContext.cacheDir, ONNX_PROCESSED_AUDIO_OUTPUT_FILENAME)
        val finalEnhancedM4aFile = File(currentContext.cacheDir, IA_PROCESSED_FILENAME_PREFIX + inputFile.nameWithoutExtension + getString(R.string.file_extension_m4a))


        // Variables para tensores ONNX, deben cerrarse en finally
        var featErbTensor: OnnxTensor? = null
        var featSpecTensor: OnnxTensor? = null
        var encResults: OrtResult? = null
        var dfDecResults: OrtResult? = null
        var erbDecResults: OrtResult? = null

        try {
            // 1. Decodificar M4A a PCM
            val pcmAudioData = decodeM4aToPcm(inputFile, decodedPcmFile)
            if (pcmAudioData == null || !currentCoroutineContext().isActive) {
                Log.e(TAG_RECORD_AUDIO, getString(R.string.log_run_ai_enhancement_failed_decode_or_cancelled, inputFile.name))
                return@withContext null
            }
            Log.i(TAG_RECORD_AUDIO, getString(R.string.log_run_ai_enhancement_pcm_decoded, inputFile.name, decodedPcmFile.absolutePath, pcmAudioData.sampleRate.toString(), pcmAudioData.channelCount.toString()))

            // 2. Leer bytes del PCM decodificado
            var pcmBytesToProcess: ByteArray? = FileInputStream(decodedPcmFile).use { it.readBytes() }
            if (pcmBytesToProcess == null || !currentCoroutineContext().isActive) {
                Log.e(TAG_RECORD_AUDIO, getString(R.string.log_run_ai_enhancement_error_reading_decoded_pcm, decodedPcmFile.name))
                return@withContext null
            }

            var currentSampleRate = pcmAudioData.sampleRate
            var currentChannelCount = pcmAudioData.channelCount

            // 3. Convertir a Mono si es necesario
            if (currentChannelCount > TARGET_CHANNEL_COUNT) {
                Log.d(TAG_RECORD_AUDIO, getString(R.string.log_run_ai_enhancement_converting_to_mono, inputFile.name, currentChannelCount.toString()))
                pcmBytesToProcess = Resampler.stereoToMono(currentContext, pcmBytesToProcess) // <--- PASAR CONTEXTO
                if (pcmBytesToProcess == null || !currentCoroutineContext().isActive) { Log.e(TAG_RECORD_AUDIO, getString(R.string.log_run_ai_enhancement_failed_to_convert_to_mono, inputFile.name)); return@withContext null }
                currentChannelCount = TARGET_CHANNEL_COUNT
                Log.i(TAG_RECORD_AUDIO, getString(R.string.log_run_ai_enhancement_converted_to_mono, inputFile.name))
            }

            // 4. Remuestrear a TARGET_SAMPLE_RATE_HZ si es necesario
            if (currentSampleRate != TARGET_SAMPLE_RATE_HZ) {
                Log.d(TAG_RECORD_AUDIO, getString(R.string.log_run_ai_enhancement_resampling, inputFile.name, currentSampleRate.toString(), TARGET_SAMPLE_RATE_HZ.toString()))
                pcmBytesToProcess = Resampler.resample(currentContext, pcmBytesToProcess, currentSampleRate, currentChannelCount, TARGET_SAMPLE_RATE_HZ, TARGET_CHANNEL_COUNT) // <--- PASAR CONTEXTO
                if (pcmBytesToProcess == null || !currentCoroutineContext().isActive) { Log.e(TAG_RECORD_AUDIO, getString(R.string.log_run_ai_enhancement_failed_to_resample, inputFile.name, TARGET_SAMPLE_RATE_HZ.toString())); return@withContext null }
                Log.i(TAG_RECORD_AUDIO, getString(R.string.log_run_ai_enhancement_resampled, inputFile.name, TARGET_SAMPLE_RATE_HZ.toString()))
            }

            if (pcmBytesToProcess == null || !currentCoroutineContext().isActive) {
                Log.e(TAG_RECORD_AUDIO, getString(R.string.log_run_ai_enhancement_pcm_data_null_after_conversion, inputFile.name))
                return@withContext null
            }
            FileOutputStream(finalPcmForOnnxInput).use { it.write(pcmBytesToProcess) } // Guardar PCM final para ONNX
            Log.i(TAG_RECORD_AUDIO, getString(R.string.log_run_ai_enhancement_final_pcm_ready_for_onnx, inputFile.name, TARGET_SAMPLE_RATE_HZ.toString(), TARGET_CHANNEL_COUNT.toString(), finalPcmForOnnxInput.absolutePath))

            // 5. Inferencia ONNX (si los modelos están cargados)
            if (encSession == null || dfDecSession == null || erbDecSession == null || ortEnvironment == null) {
                Log.e(TAG_RECORD_AUDIO, getString(R.string.log_run_ai_enhancement_onnx_sessions_not_init, inputFile.name))
                // Si los modelos no están listos, usar el PCM preprocesado como salida (sin mejora IA)
                finalPcmForOnnxInput.copyTo(onnxProcessedPcmFile, overwrite = true)
            } else {
                // Calcular número de tramas (S) para los tensores de entrada
                val numSamples = pcmBytesToProcess.size / 2 // Asumiendo PCM 16-bit
                val numFramesS = (numSamples.toFloat() / DFN_STFT_HOP_SIZE.toFloat()).toInt()
                if (numFramesS <= 0) {
                    Log.e(TAG_RECORD_AUDIO, getString(R.string.log_run_ai_enhancement_num_frames_zero_or_negative, numFramesS.toString(), inputFile.name))
                    finalPcmForOnnxInput.copyTo(onnxProcessedPcmFile, overwrite = true) // Usar preprocesado
                } else {
                    Log.d(TAG_RECORD_AUDIO, getString(R.string.log_run_ai_enhancement_num_pcm_samples_frames, inputFile.name, numSamples.toString(), numFramesS.toString()))

                    // Helper para obtener tensores de los resultados de ONNX
                    fun OrtResult.getTensorOrNull(name: String): OnnxTensor? {
                        val optionalValue: Optional<OnnxValue> = this.get(name)
                        if (!optionalValue.isPresent) {
                            Log.e(TAG_RECORD_AUDIO, getString(R.string.log_run_ai_enhancement_output_not_found_in_onnx, name, this.toString(), inputFile.name))
                            return null
                        }
                        val value: OnnxValue = optionalValue.get()
                        return if (value is OnnxTensor) {
                            value
                        } else {
                            Log.e(TAG_RECORD_AUDIO, getString(R.string.log_run_ai_enhancement_output_not_onnx_tensor, name, inputFile.name, value.type.toString()))
                            null
                        }
                    }

                    // Crear tensores de entrada para enc.onnx (rellenos con ceros por ahora)
                    // La implementación real necesitaría extraer características del audio PCM
                    val featErbShape = longArrayOf(1, 1, numFramesS.toLong(), 32L) // [B, C, S, F]
                    val featErbBuffer = FloatBuffer.allocate(featErbShape.reduce { acc, l -> acc * l }.toInt())
                    featErbTensor = OnnxTensor.createTensor(ortEnvironment, featErbBuffer, featErbShape)

                    val featSpecShape = longArrayOf(1, 2, numFramesS.toLong(), 96L) // [B, C, S, F]
                    val featSpecBuffer = FloatBuffer.allocate(featSpecShape.reduce { acc, l -> acc * l }.toInt())
                    featSpecTensor = OnnxTensor.createTensor(ortEnvironment, featSpecBuffer, featSpecShape)

                    val encInputs = mapOf("feat_erb" to featErbTensor!!, "feat_spec" to featSpecTensor!!)
                    Log.d(TAG_RECORD_AUDIO, getString(R.string.log_run_ai_enhancement_running_enc_onnx, inputFile.name))
                    encResults = encSession!!.run(encInputs) // Ejecutar enc.onnx

                    // Obtener salidas de enc.onnx
                    val embTensor = encResults!!.getTensorOrNull("emb") ?: return@withContext null
                    val c0Tensor = encResults!!.getTensorOrNull("c0") ?: return@withContext null
                    val e0Tensor = encResults!!.getTensorOrNull("e0") ?: return@withContext null
                    val e1Tensor = encResults!!.getTensorOrNull("e1") ?: return@withContext null
                    val e2Tensor = encResults!!.getTensorOrNull("e2") ?: return@withContext null
                    val e3Tensor = encResults!!.getTensorOrNull("e3") ?: return@withContext null
                    Log.d(TAG_RECORD_AUDIO, getString(R.string.log_run_ai_enhancement_enc_onnx_executed, inputFile.name, embTensor.info.shape.contentToString()))

                    // Ejecutar df_dec.onnx
                    val dfDecInputs = mapOf("emb" to embTensor, "c0" to c0Tensor)
                    Log.d(TAG_RECORD_AUDIO, getString(R.string.log_run_ai_enhancement_running_df_dec_onnx, inputFile.name))
                    dfDecResults = dfDecSession!!.run(dfDecInputs)
                    val dfOutSignalTensor = dfDecResults!!.getTensorOrNull("302") ?: return@withContext null // Nombre de salida del modelo
                    Log.d(TAG_RECORD_AUDIO, getString(R.string.log_run_ai_enhancement_df_dec_onnx_executed, inputFile.name, dfOutSignalTensor.info.shape.contentToString()))

                    // Ejecutar erb_dec.onnx
                    val erbDecInputs = mapOf("emb" to embTensor, "e3" to e3Tensor, "e2" to e2Tensor, "e1" to e1Tensor, "e0" to e0Tensor)
                    Log.d(TAG_RECORD_AUDIO, getString(R.string.log_run_ai_enhancement_running_erb_dec_onnx, inputFile.name))
                    erbDecResults = erbDecSession!!.run(erbDecInputs)
                    val erbOutMaskTensor = erbDecResults!!.getTensorOrNull("m") ?: return@withContext null // Nombre de salida del modelo
                    Log.d(TAG_RECORD_AUDIO, getString(R.string.log_run_ai_enhancement_erb_dec_onnx_executed, inputFile.name, erbOutMaskTensor.info.shape.contentToString()))

                    // TODO: Implementar la lógica para usar las salidas de los modelos ONNX
                    // Por ahora, solo se simula copiando el PCM preprocesado
                    Log.w(TAG_RECORD_AUDIO, getString(R.string.log_run_ai_enhancement_simulating_ai_output, inputFile.name))
                    finalPcmForOnnxInput.copyTo(onnxProcessedPcmFile, overwrite = true)
                }
            }

            // 6. Re-codificar el PCM (procesado o no por IA) a M4A/AAC
            Log.d(TAG_RECORD_AUDIO, getString(R.string.log_run_ai_enhancement_starting_re_encoding, inputFile.name, onnxProcessedPcmFile.absolutePath))
            if (encodePcmToAacM4a(onnxProcessedPcmFile, finalEnhancedM4aFile)) {
                Log.i(TAG_RECORD_AUDIO, getString(R.string.log_run_ai_enhancement_re_encoding_complete, inputFile.name, finalEnhancedM4aFile.absolutePath))
                return@withContext finalEnhancedM4aFile
            } else {
                Log.e(TAG_RECORD_AUDIO, getString(R.string.log_run_ai_enhancement_failed_re_encoding, inputFile.name))
                finalEnhancedM4aFile.delete() // Eliminar archivo parcial si falla
                return@withContext null
            }

        } catch (e: OrtException) {
            Log.e(TAG_RECORD_AUDIO, getString(R.string.log_run_ai_enhancement_ortexception, inputFile.name), e)
            return@withContext null
        } catch (e: IOException) {
            Log.e(TAG_RECORD_AUDIO, getString(R.string.log_run_ai_enhancement_ioexception, inputFile.name), e)
            return@withContext null
        } catch (e: Exception) { // Captura de errores críticos
            Log.e(TAG_RECORD_AUDIO, getString(R.string.log_run_ai_enhancement_critical_unexpected_error, inputFile.name), e)
            return@withContext null
        } finally {
            // Liberar recursos ONNX
            featErbTensor?.close()
            featSpecTensor?.close()
            encResults?.close()
            dfDecResults?.close()
            erbDecResults?.close()

            // Eliminar archivos temporales PCM
            if (decodedPcmFile.exists()) decodedPcmFile.delete()
            if (finalPcmForOnnxInput.exists()) finalPcmForOnnxInput.delete()
            if (onnxProcessedPcmFile.exists()) onnxProcessedPcmFile.delete()
        }
    }


    // Codifica datos PCM crudos a un archivo M4A usando AAC
    @SuppressLint("NewApi") // Para MediaMuxer y MediaCodec
    private suspend fun encodePcmToAacM4a(pcmInputFile: File, m4aOutputFile: File): Boolean = withContext(Dispatchers.IO) {
        if (!currentCoroutineContext().isActive || !isAdded || context == null || !pcmInputFile.exists() || pcmInputFile.length() == 0L) {
            Log.e(TAG_RECORD_AUDIO, getString(R.string.log_encode_pcm_to_aac_preconditions_not_met, pcmInputFile.name, pcmInputFile.exists().toString(), pcmInputFile.length().toString()))
            return@withContext false
        }
        Log.d(TAG_RECORD_AUDIO, getString(R.string.log_encode_pcm_to_aac_starting, pcmInputFile.name, m4aOutputFile.name))

        val inputChannelCount = TARGET_CHANNEL_COUNT
        val inputSampleRate = TARGET_SAMPLE_RATE_HZ

        var encoder: MediaCodec? = null
        var muxer: MediaMuxer? = null
        val timeoutUs = 10000L // 10ms
        var trackIndex = -1
        var muxerStarted = false
        val bufferSize = 2048 * inputChannelCount * 2 // Tamaño de buffer razonable para PCM 16-bit

        try {
            // Configurar formato de salida AAC
            val outputFormat = AndroidMediaFormat.createAudioFormat(AAC_MIME_TYPE, inputSampleRate, inputChannelCount)
            outputFormat.setInteger(AndroidMediaFormat.KEY_AAC_PROFILE, MediaCodecInfo.CodecProfileLevel.AACObjectLC)
            outputFormat.setInteger(AndroidMediaFormat.KEY_BIT_RATE, AAC_BIT_RATE) // Bitrate deseado

            encoder = MediaCodec.createEncoderByType(AAC_MIME_TYPE)
            encoder.configure(outputFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE)
            encoder.start()

            muxer = MediaMuxer(m4aOutputFile.absolutePath, MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4)

            val bufferInfo = MediaCodec.BufferInfo()
            FileInputStream(pcmInputFile).use { fis ->
                val pcmChunkBuffer = ByteArray(bufferSize)
                var hasMoreInput = true
                var presentationTimeUsCumulative: Long = 0 // Acumulador para el tiempo de presentación
                var totalBytesRead: Long = 0

                // Bucle principal de codificación y multiplexación
                mainLoop@ while (true) {
                    if (!currentCoroutineContext().isActive) { Log.w(TAG_RECORD_AUDIO, getString(R.string.log_encode_pcm_to_aac_cancelled_coroutine, pcmInputFile.name)); return@withContext false }

                    // Alimentar datos PCM al codificador
                    if (hasMoreInput) {
                        val inputBufferId = encoder.dequeueInputBuffer(timeoutUs)
                        if (inputBufferId >= 0) {
                            val inputBuffer = encoder.getInputBuffer(inputBufferId)!!
                            inputBuffer.clear()
                            val bytesRead = fis.read(pcmChunkBuffer, 0, min(pcmChunkBuffer.size, inputBuffer.remaining()))
                            if (bytesRead > 0) {
                                inputBuffer.put(pcmChunkBuffer, 0, bytesRead)
                                totalBytesRead += bytesRead
                                // Calcular duración del chunk para el tiempo de presentación
                                val chunkDurationUs = (bytesRead.toDouble() / (inputChannelCount * 2.0 * inputSampleRate.toDouble()) * 1_000_000.0).toLong()
                                encoder.queueInputBuffer(inputBufferId, 0, bytesRead, presentationTimeUsCumulative, 0)
                                presentationTimeUsCumulative += chunkDurationUs
                            } else { // Fin del archivo PCM
                                encoder.queueInputBuffer(inputBufferId, 0, 0, presentationTimeUsCumulative, MediaCodec.BUFFER_FLAG_END_OF_STREAM)
                                hasMoreInput = false
                                Log.d(TAG_RECORD_AUDIO, getString(R.string.log_encode_pcm_to_aac_eos_sent, pcmInputFile.name, totalBytesRead.toString()))
                            }
                        }
                    }

                    // Obtener datos codificados del codificador y escribirlos al multiplexor
                    var outputBufferId = encoder.dequeueOutputBuffer(bufferInfo, timeoutUs)
                    processingOutputLoop@ while (outputBufferId != MediaCodec.INFO_TRY_AGAIN_LATER) {
                        if (!currentCoroutineContext().isActive) { Log.w(TAG_RECORD_AUDIO, getString(R.string.log_encode_pcm_to_aac_cancelled_output_processing, pcmInputFile.name)); return@withContext false }
                        when (outputBufferId) {
                            MediaCodec.INFO_OUTPUT_FORMAT_CHANGED -> {
                                if (muxerStarted) {
                                    Log.e(TAG_RECORD_AUDIO, getString(R.string.log_encode_pcm_to_aac_format_changed_after_muxer, pcmInputFile.name))
                                    throw RuntimeException(getString(R.string.exception_format_changed_after_muxer_started))
                                }
                                val newFormat = encoder.outputFormat
                                trackIndex = muxer.addTrack(newFormat)
                                muxer.start()
                                muxerStarted = true
                                Log.i(TAG_RECORD_AUDIO, getString(R.string.log_encode_pcm_to_aac_muxer_started, pcmInputFile.name, newFormat.toString()))
                            }
                            MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED -> {
                                Log.d(TAG_RECORD_AUDIO, getString(R.string.log_encode_pcm_to_aac_output_buffers_changed, pcmInputFile.name))
                            }
                            else -> {
                                if (outputBufferId < 0) { // Error inesperado
                                    Log.e(TAG_RECORD_AUDIO, getString(R.string.log_encode_pcm_to_aac_dequeue_unexpected_code, outputBufferId.toString(), pcmInputFile.name))
                                    break@processingOutputLoop
                                }
                                if (!muxerStarted) { // Esperar a que el muxer inicie
                                    Log.w(TAG_RECORD_AUDIO, getString(R.string.log_encode_pcm_to_aac_output_before_format_changed, pcmInputFile.name))
                                    encoder.releaseOutputBuffer(outputBufferId, false) // Liberar y reintentar
                                    outputBufferId = encoder.dequeueOutputBuffer(bufferInfo, timeoutUs)
                                    continue@processingOutputLoop
                                }
                                val outputBuffer = encoder.getOutputBuffer(outputBufferId)!!
                                // Escribir datos al muxer si no es configuración del códec y hay datos
                                if (bufferInfo.flags and MediaCodec.BUFFER_FLAG_CODEC_CONFIG == 0 && bufferInfo.size != 0) {
                                    if (trackIndex != -1) {
                                        muxer.writeSampleData(trackIndex, outputBuffer, bufferInfo)
                                    } else {
                                        Log.e(TAG_RECORD_AUDIO, getString(R.string.log_encode_pcm_to_aac_muxer_track_index_invalid, pcmInputFile.name))
                                    }
                                }
                                encoder.releaseOutputBuffer(outputBufferId, false)
                                if (bufferInfo.flags and MediaCodec.BUFFER_FLAG_END_OF_STREAM != 0) {
                                    Log.d(TAG_RECORD_AUDIO, getString(R.string.log_encode_pcm_to_aac_eos_received_from_encoder, pcmInputFile.name))
                                    break@mainLoop // Salir del bucle principal
                                }
                            }
                        }
                        outputBufferId = encoder.dequeueOutputBuffer(bufferInfo, 0L) // Intentar obtener más salida sin esperar
                    }
                    // Si se recibió EOS, salir del bucle principal
                    if (bufferInfo.flags and MediaCodec.BUFFER_FLAG_END_OF_STREAM != 0) {
                        break@mainLoop
                    }
                    // Si no hay más entrada y el codificador necesita más tiempo, asumir que terminó o se atascó
                    if (!hasMoreInput && outputBufferId == MediaCodec.INFO_TRY_AGAIN_LATER){
                        Log.d(TAG_RECORD_AUDIO, getString(R.string.log_encode_pcm_to_aac_no_more_input_try_again, pcmInputFile.name))
                        break@mainLoop
                    }
                } // Fin del bucle principal
            }
            Log.i(TAG_RECORD_AUDIO, getString(R.string.log_encode_pcm_to_aac_loop_finished, pcmInputFile.name))
            return@withContext true
        } catch (e: IOException) {
            Log.e(TAG_RECORD_AUDIO, getString(R.string.log_encode_pcm_to_aac_ioexception, pcmInputFile.name), e)
            m4aOutputFile.delete()
            return@withContext false
        } catch (e: IllegalStateException) {
            Log.e(TAG_RECORD_AUDIO, getString(R.string.log_encode_pcm_to_aac_illegalstate, pcmInputFile.name), e)
            m4aOutputFile.delete()
            return@withContext false
        } catch (e: IllegalArgumentException) {
            Log.e(TAG_RECORD_AUDIO, getString(R.string.log_encode_pcm_to_aac_illegalargument, pcmInputFile.name), e)
            m4aOutputFile.delete()
            return@withContext false
        } catch (e: MediaCodec.CodecException) {
            Log.e(TAG_RECORD_AUDIO, getString(R.string.log_encode_pcm_to_aac_codecexception, pcmInputFile.name), e)
            m4aOutputFile.delete()
            return@withContext false
        } catch (e: Exception) { // Captura genérica
            Log.e(TAG_RECORD_AUDIO, getString(R.string.log_encode_pcm_to_aac_unexpected_error, pcmInputFile.name), e)
            m4aOutputFile.delete()
            return@withContext false
        } finally {
            try { encoder?.stop(); encoder?.release() } catch (e: Exception) {Log.e(TAG_RECORD_AUDIO, getString(R.string.log_encode_pcm_to_aac_error_releasing_codec, pcmInputFile.name), e)}
            try { if (muxerStarted) muxer?.stop(); muxer?.release() } catch (e: Exception) { Log.e(TAG_RECORD_AUDIO, getString(R.string.log_encode_pcm_to_aac_error_releasing_muxer, pcmInputFile.name), e)}
        }
    }


    private fun releaseMediaRecorder() {
        try {
            mediaRecorder?.reset()
            mediaRecorder?.release()
        } catch (e: Exception) {
            Log.e(TAG_RECORD_AUDIO, getString(R.string.log_release_mediarecorder_error), e)
        }
        mediaRecorder = null
    }

    private fun initializePlayer(uri: Uri) {
        if (!isAdded) return
        if (exoPlayer == null) {
            exoPlayer = ExoPlayer.Builder(requireContext()).build().apply {
                addListener(playerListener)
                val initialSpeed = playbackSpeeds[currentSpeedIndex]
                playbackParameters = PlaybackParameters(initialSpeed)
            }
        }
        val mediaItem = MediaItem.fromUri(uri)
        exoPlayer?.setMediaItem(mediaItem)
        exoPlayer?.seekTo(playerPlaybackPosition)
        exoPlayer?.playWhenReady = playerPlayWhenReady
        exoPlayer?.prepare()
        updatePlayerUI()
    }

    private fun releasePlayer() {
        if (::runnableUpdateSeekBar.isInitialized) {
            seekBarUpdateHandler.removeCallbacks(runnableUpdateSeekBar)
        }
        try {
            exoPlayer?.release()
        } catch (e: Exception) {
            Log.e(TAG_RECORD_AUDIO, getString(R.string.log_release_exoplayer_error), e)
        }
        exoPlayer = null
    }

    private fun deleteRecordedAudio(notifyListener: Boolean = true) {
        aiProcessingJob?.cancel(); aiProcessingJob = null // Cancelar procesamiento IA si está activo
        releasePlayer()
        audioFile?.delete(); audioFile = null
        processedAudioFile?.delete(); processedAudioFile = null
        currentPlayableAudioUri = null
        currentPlayableAudioOriginalName = null
        playerPlaybackPosition = 0
        playerPlayWhenReady = true
        currentSpeedIndex = 1 // Resetear velocidad a 1x
        recordingChronometer = 0L // Resetear cronómetro
        if(::waveformView.isInitialized) waveformView.clearWaveform() // Limpiar forma de onda
        currentRecordingState = RecordingState.IDLE // Volver a estado inicial
        updateUI()
        if (notifyListener) listener?.onAudioDeleted()
    }

    private fun cyclePlaybackSpeed() {
        currentSpeedIndex = (currentSpeedIndex + 1) % playbackSpeeds.size
        applyPlaybackSpeed()
        updatePlayerUI() // Actualizar texto del botón de velocidad en UI
    }

    private fun applyPlaybackSpeed() {
        exoPlayer?.let {
            val currentSpeedValue = playbackSpeeds[currentSpeedIndex]
            it.playbackParameters = PlaybackParameters(currentSpeedValue)
        }
    }

    private val playerListener = object : Player.Listener {
        override fun onIsPlayingChanged(isPlaying: Boolean) {
            updatePlayerUI()
            if (isPlaying && ::runnableUpdateSeekBar.isInitialized) {
                seekBarUpdateHandler.post(runnableUpdateSeekBar)
            } else if (::runnableUpdateSeekBar.isInitialized) {
                seekBarUpdateHandler.removeCallbacks(runnableUpdateSeekBar)
            }
        }

        override fun onPlaybackStateChanged(playbackState: Int) {
            updatePlayerUI()
            if (playbackState == Player.STATE_ENDED) {
                exoPlayer?.seekTo(0) // Volver al inicio
                exoPlayer?.playWhenReady = false // No reiniciar automáticamente
            }
        }

        override fun onPlayerError(error: PlaybackException) {
            if (!isAdded) return
            val errorMessage = getString(R.string.error_playback_failed_specific, error.localizedMessage ?: error.errorCodeName)
            Log.e(TAG_RECORD_AUDIO, "ExoPlayer error: ${error.errorCodeName} - ${error.localizedMessage}", error)
            showAlertDialog(getString(R.string.error_dialog_title), errorMessage)
            updatePlayerUI() // Actualizar UI para reflejar el error
        }
    }

    private fun initializeRecordingTimerRunnable() {
        recordingTimerRunnable = object : Runnable {
            override fun run() {
                if (currentRecordingState == RecordingState.RECORDING) {
                    recordingChronometer += 100 // Actualizar cada 100ms
                    val timeRemainingMs = MAX_RECORDING_DURATION_MS - recordingChronometer
                    binding.tvRecordingTimer.text = formatDuration(recordingChronometer, timeRemainingMs, currentRecordingState, true)

                    if (recordingChronometer >= MAX_RECORDING_DURATION_MS) {
                        // Detener grabación si se alcanza la duración máxima
                        if (currentRecordingState == RecordingState.RECORDING) { // Doble chequeo por si acaso
                            stopRecordingFlow(bySystem = false, message = getString(R.string.info_max_duration_reached, MAX_RECORDING_DURATION_MS / (60 * 1000)))
                        }
                    } else {
                        recordingTimerHandler.postDelayed(this, 100)
                    }
                }
            }
        }
    }

    private fun initializeAmplitudeUpdater() {
        amplitudeUpdater = object : Runnable {
            override fun run() {
                if (mediaRecorder != null && currentRecordingState == RecordingState.RECORDING && isAdded && ::waveformView.isInitialized) {
                    try {
                        waveformView.addAmplitude(mediaRecorder!!.maxAmplitude)
                        amplitudeUpdateHandler.postDelayed(this, AMPLITUDE_UPDATE_INTERVAL_MS)
                    } catch (e: IllegalStateException) {
                        Log.w(TAG_RECORD_AUDIO, getString(R.string.log_error_amplitude_updater_illegalstate), e)
                        amplitudeUpdateHandler.removeCallbacks(this) // Detener si hay error
                    }
                } else {
                    amplitudeUpdateHandler.removeCallbacks(this) // Detener si no se cumplen condiciones
                }
            }
        }
    }

    private fun formatDuration(elapsedMs: Long, remainingOrTotalMs: Long, state: RecordingState, includeMilliseconds: Boolean = false): String {
        val elapsedTotalSeconds = elapsedMs / 1000
        val elapsedMinutes = TimeUnit.SECONDS.toMinutes(elapsedTotalSeconds)
        val elapsedSeconds = elapsedTotalSeconds - TimeUnit.MINUTES.toSeconds(elapsedMinutes)
        val elapsedMillis = (elapsedMs % 1000) / 100 // Décimas de segundo

        return when (state) {
            RecordingState.RECORDING, RecordingState.PAUSED -> {
                val remValidMs = if (remainingOrTotalMs < 0) 0 else remainingOrTotalMs
                val remTotalSec = remValidMs / 1000
                val remMin = TimeUnit.SECONDS.toMinutes(remTotalSec)
                val remSec = remTotalSec - TimeUnit.MINUTES.toSeconds(remMin)
                val remMillis = (remValidMs % 1000) / 100
                if (includeMilliseconds) {
                    // Usar un formato de string que muestre ambas duraciones con milisegundos
                    getString(R.string.timer_format_recording_multiline_ms, elapsedMinutes, elapsedSeconds, elapsedMillis, remMin, remSec, remMillis)
                } else {
                    getString(R.string.timer_format_elapsed_remaining, elapsedMinutes, elapsedSeconds, remMin, remSec)
                }
            }
            RecordingState.STOPPED, RecordingState.AI_PROCESSING -> {
                // Mostrar solo duración total
                if (includeMilliseconds) {
                    getString(R.string.timer_format_total_duration_ms, elapsedMinutes, elapsedSeconds, elapsedMillis)
                } else {
                    getString(R.string.timer_format_total_duration, elapsedMinutes, elapsedSeconds)
                }
            }
            RecordingState.IDLE -> {
                // Mostrar duración máxima posible
                val totalDurSec = MAX_RECORDING_DURATION_MS / 1000
                val totalMin = TimeUnit.SECONDS.toMinutes(totalDurSec)
                val totalSec = totalDurSec - TimeUnit.MINUTES.toSeconds(totalMin)
                getString(R.string.timer_format_idle, totalMin, totalSec)
            }
        }
    }

    @SuppressLint("SetTextI18n")
    private fun updateUI() {
        if (_binding == null) return // Salir si el binding es nulo (vista destruida)

        val isRecordingOrPaused = currentRecordingState == RecordingState.RECORDING || currentRecordingState == RecordingState.PAUSED
        val isIdleOrStopped = currentRecordingState == RecordingState.IDLE || currentRecordingState == RecordingState.STOPPED
        val isAiProcessing = currentRecordingState == RecordingState.AI_PROCESSING

        // Habilitar/deshabilitar spinner de fuente de audio
        binding.spinnerAudioSource.isEnabled = isIdleOrStopped && currentPlayableAudioUri == null && !isAiProcessing

        // Habilitar/deshabilitar botones principales de grabación
        binding.btnStartStopRecording.isEnabled = !isAiProcessing // Siempre habilitado a menos que esté procesando IA
        binding.btnPauseResumeRecording.isEnabled = isRecordingOrPaused && Build.VERSION.SDK_INT >= Build.VERSION_CODES.N && !isAiProcessing

        // Configurar texto y visibilidad de elementos según el estado
        if (isAiProcessing) {
            binding.tvRecordingStatusDetailed.text = getString(R.string.info_ai_processing_audio)
            binding.btnStartStopRecording.text = getString(R.string.button_start_recording) // Botón principal muestra "Iniciar"
            binding.btnStartStopRecording.setIconResource(R.drawable.ic_record_red)
            binding.secondaryRecordingControls.visibility = View.GONE
            binding.recordedAudioPlayerSection.visibility = View.GONE
            binding.btnSaveLocalAudio?.visibility = View.GONE
            if(::waveformView.isInitialized) waveformView.visibility = View.VISIBLE // Mantener forma de onda visible
            binding.tvRecordingTimer.text = formatDuration(recordingChronometer, 0L, RecordingState.AI_PROCESSING, true)
        } else {
            when (currentRecordingState) {
                RecordingState.IDLE -> {
                    binding.tvRecordingStatusDetailed.text = getString(R.string.status_ready_to_record)
                    binding.btnStartStopRecording.text = getString(R.string.button_start_recording)
                    binding.btnStartStopRecording.setIconResource(R.drawable.ic_record_red)
                    binding.secondaryRecordingControls.visibility = View.GONE
                    binding.tvRecordingTimer.text = formatDuration(0, MAX_RECORDING_DURATION_MS, RecordingState.IDLE)
                    binding.btnSaveLocalAudio?.visibility = View.GONE
                    if(::waveformView.isInitialized) waveformView.visibility = View.VISIBLE // Mostrar forma de onda
                }
                RecordingState.RECORDING -> {
                    binding.tvRecordingStatusDetailed.text = getString(R.string.status_recording)
                    binding.btnStartStopRecording.text = getString(R.string.button_stop_recording)
                    binding.btnStartStopRecording.setIconResource(R.drawable.ic_stop_red)
                    binding.secondaryRecordingControls.visibility = View.VISIBLE
                    binding.btnPauseResumeRecording.text = getString(R.string.button_pause_recording)
                    binding.btnPauseResumeRecording.setIconResource(R.drawable.ic_pause_red)
                    binding.btnSaveLocalAudio?.visibility = View.GONE
                    if(::waveformView.isInitialized) waveformView.visibility = View.VISIBLE
                }
                RecordingState.PAUSED -> {
                    binding.tvRecordingStatusDetailed.text = getString(R.string.status_paused)
                    binding.btnStartStopRecording.text = getString(R.string.button_stop_recording)
                    binding.btnStartStopRecording.setIconResource(R.drawable.ic_stop_red)
                    binding.secondaryRecordingControls.visibility = View.VISIBLE
                    binding.btnPauseResumeRecording.text = getString(R.string.button_resume_recording)
                    binding.btnPauseResumeRecording.setIconResource(R.drawable.ic_play) // Icono de play para reanudar
                    // Mostrar tiempo transcurrido y restante
                    binding.tvRecordingTimer.text = formatDuration(recordingChronometer, MAX_RECORDING_DURATION_MS - recordingChronometer, RecordingState.PAUSED, true)
                    binding.btnSaveLocalAudio?.visibility = View.GONE
                    if(::waveformView.isInitialized) waveformView.visibility = View.VISIBLE
                }
                RecordingState.STOPPED -> {
                    binding.tvRecordingStatusDetailed.text = getString(R.string.status_finished)
                    // Mostrar duración total de la grabación
                    binding.tvRecordingTimer.text = formatDuration(if (currentPlayableAudioUri != null) recordingChronometer else 0L, 0L, RecordingState.STOPPED, true)
                    binding.btnStartStopRecording.text = getString(R.string.button_start_recording) // Listo para nueva grabación
                    binding.btnStartStopRecording.setIconResource(R.drawable.ic_record_red)
                    binding.secondaryRecordingControls.visibility = View.GONE
                    binding.btnSaveLocalAudio?.visibility = if (currentPlayableAudioUri != null) View.VISIBLE else View.GONE // Mostrar si hay audio
                    if(::waveformView.isInitialized) waveformView.visibility = View.VISIBLE // Mantener forma de onda
                }
                else -> { /* AI_PROCESSING ya cubierto */ }
            }
        }

        // Visibilidad del reproductor de audio grabado
        binding.recordedAudioPlayerSection.visibility = if (currentPlayableAudioUri != null && !isAiProcessing) View.VISIBLE else View.GONE
        if (currentPlayableAudioUri != null && !isAiProcessing) {
            binding.tvRecordedAudioFileName.text = getString(R.string.player_audio_file_name_format, currentPlayableAudioOriginalName ?: getString(R.string.default_audio_filename))
            updatePlayerUI() // Actualizar UI específica del reproductor
        } else if (!isAiProcessing) { // Si no hay audio y no se está procesando IA
            binding.seekBarRecordedAudio.visibility = View.GONE
            binding.tvPlayerTimer?.text = getString(R.string.player_timer_default_ss) // Formato MM:SS
            binding.btnSaveLocalAudio?.visibility = View.GONE
        }
    }

    private fun formatPlayerTimeSeconds(milliseconds: Long): String {
        if (milliseconds < 0) return "00:00" // Manejar valores negativos
        val totalSeconds = TimeUnit.MILLISECONDS.toSeconds(milliseconds.coerceAtLeast(0))
        val minutes = TimeUnit.SECONDS.toMinutes(totalSeconds)
        val seconds = totalSeconds - TimeUnit.MINUTES.toSeconds(minutes)
        return String.format(Locale.getDefault(), "%02d:%02d", minutes, seconds)
    }

    private fun updatePlayerTimerDisplay() {
        if (_binding == null || exoPlayer == null) { // Comprobar nulidad de binding también
            binding.tvPlayerTimer?.text = getString(R.string.player_timer_default_ss)
            return
        }
        val currentPos = exoPlayer?.currentPosition ?: 0
        val totalDur = exoPlayer?.duration ?: 0

        val currentFormatted = formatPlayerTimeSeconds(currentPos)
        val totalFormatted = formatPlayerTimeSeconds(if (totalDur > 0 && totalDur != com.google.android.exoplayer2.C.TIME_UNSET) totalDur else 0)

        binding.tvPlayerTimer?.text = "$currentFormatted / $totalFormatted"
    }

    private fun updatePlayerUI() {
        if (_binding == null || currentRecordingState == RecordingState.AI_PROCESSING) {
            // Si el binding es nulo o se está procesando IA, ocultar reproductor
            if (_binding != null) binding.recordedAudioPlayerSection.visibility = View.GONE
            return
        }

        // Determinar si el reproductor está realmente listo para reproducir
        val isPlayerActuallyReady = exoPlayer != null &&
                exoPlayer?.playbackState != Player.STATE_IDLE &&
                exoPlayer?.playbackState != Player.STATE_BUFFERING &&
                (exoPlayer?.duration ?: 0) > 0 &&
                exoPlayer?.duration != com.google.android.exoplayer2.C.TIME_UNSET

        val isPlaying = exoPlayer?.isPlaying ?: false

        // Visibilidad de botones Play/Pause
        binding.btnPlayRecordedAudio.visibility = if (isPlaying) View.GONE else View.VISIBLE
        binding.btnPauseRecordedAudio.visibility = if (isPlaying) View.VISIBLE else View.GONE

        // Habilitar/deshabilitar botones del reproductor
        binding.btnPlayRecordedAudio.isEnabled = isPlayerActuallyReady && !isPlaying
        binding.btnPauseRecordedAudio.isEnabled = isPlayerActuallyReady && isPlaying
        binding.btnDeleteRecordedAudio.isEnabled = currentPlayableAudioUri != null // Habilitar si hay audio
        binding.tvPlaybackSpeedRecorded.isEnabled = isPlayerActuallyReady
        binding.btnSaveLocalAudio?.isEnabled = currentPlayableAudioUri != null // Habilitar si hay audio

        // Actualizar SeekBar y temporizador del reproductor
        if (isPlayerActuallyReady) {
            binding.seekBarRecordedAudio.visibility = View.VISIBLE
            binding.tvPlayerTimer?.visibility = View.VISIBLE
            updatePlayerTimerDisplay()
            binding.seekBarRecordedAudio.max = (exoPlayer!!.duration).toInt()
            binding.seekBarRecordedAudio.progress = (exoPlayer!!.currentPosition).toInt()
        } else {
            binding.seekBarRecordedAudio.visibility = View.GONE
            binding.tvPlayerTimer?.text = getString(R.string.player_timer_default_ss)
            binding.tvPlayerTimer?.visibility = if (currentPlayableAudioUri != null) View.VISIBLE else View.GONE
            binding.seekBarRecordedAudio.progress = 0
            binding.seekBarRecordedAudio.max = 100 // Valor por defecto
        }

        // Actualizar texto del botón de velocidad
        if (::playbackSpeedStrings.isInitialized && playbackSpeedStrings.isNotEmpty()) {
            binding.tvPlaybackSpeedRecorded.text = playbackSpeedStrings.getOrElse(currentSpeedIndex) { playbackSpeedStrings[0] }
        } else {
            binding.tvPlaybackSpeedRecorded.text = "1x" // Fallback
        }
    }

    private fun initializeSeekBarUpdaterPlayer() {
        runnableUpdateSeekBar = object : Runnable {
            override fun run() {
                exoPlayer?.let { player ->
                    if (player.isPlaying && view != null && isAdded) { // Comprobar vista y fragmento
                        binding.seekBarRecordedAudio.progress = player.currentPosition.toInt()
                        updatePlayerTimerDisplay()
                        seekBarUpdateHandler.postDelayed(this, 200) // Actualizar cada 200ms
                    }
                }
            }
        }
    }

    private fun saveAudioToPublicMusicDirectory(sourceFileUri: Uri, desiredFileName: String) {
        if (!isAdded || context == null) {
            showSafeToast(getString(R.string.error_saving_audio_no_context))
            return
        }
        val resolver = requireContext().contentResolver
        var finalPathForDialog = "" // Para mostrar al usuario dónde se guardó

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            // Para Android Q y superior, usar MediaStore
            val audioCollection = MediaStore.Audio.Media.getContentUri(MediaStore.VOLUME_EXTERNAL_PRIMARY)
            val relativePath = Environment.DIRECTORY_MUSIC + File.separator + getString(R.string.app_recordings_folder_name)
            finalPathForDialog = "Música/${getString(R.string.app_recordings_folder_name)}/$desiredFileName"

            val newAudioDetails = ContentValues().apply {
                put(MediaStore.Audio.Media.DISPLAY_NAME, desiredFileName)
                put(MediaStore.Audio.Media.MIME_TYPE, "audio/m4a") // Asumir M4A
                put(MediaStore.Audio.Media.RELATIVE_PATH, relativePath)
                put(MediaStore.Audio.Media.IS_PENDING, 1) // Marcar como pendiente hasta que se escriba
            }
            var newAudioUri: Uri? = null
            try {
                newAudioUri = resolver.insert(audioCollection, newAudioDetails)
                if (newAudioUri == null) {
                    showAlertDialog(getString(R.string.error_dialog_title), getString(R.string.error_saving_audio_failed_mediastore))
                    return
                }
                resolver.openOutputStream(newAudioUri).use { output ->
                    resolver.openInputStream(sourceFileUri).use { input ->
                        if (input == null || output == null) throw IOException(getString(R.string.error_saving_audio_copy_failed_streams_null))
                        input.copyTo(output)
                    }
                }
                newAudioDetails.clear()
                newAudioDetails.put(MediaStore.Audio.Media.IS_PENDING, 0) // Marcar como no pendiente
                resolver.update(newAudioUri, newAudioDetails, null, null)
                showAlertDialog(getString(R.string.info_audio_saved_locally), getString(R.string.success_audio_saved_to_music_path_dialog, finalPathForDialog))
            } catch (ioe: IOException) {
                Log.e(TAG_RECORD_AUDIO, "IOException al guardar audio (API Q+).", ioe)
                showAlertDialog(getString(R.string.error_dialog_title), getString(R.string.error_saving_audio_copy_failed, ioe.localizedMessage ?: getString(R.string.unknown_error)))
                newAudioUri?.let { resolver.delete(it, null, null) } // Eliminar entrada si falla la copia
            } catch (e: Exception) { // Captura genérica
                Log.e(TAG_RECORD_AUDIO, "Excepción al guardar audio (API Q+).", e)
                showAlertDialog(getString(R.string.error_dialog_title), getString(R.string.error_saving_audio_copy_failed, e.localizedMessage ?: getString(R.string.unknown_error)))
                newAudioUri?.let { resolver.delete(it, null, null) }
            }
        } else {
            // Para versiones anteriores a Android Q, solicitar permiso de escritura si es necesario
            if (ContextCompat.checkSelfPermission(requireContext(), Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
                requestWriteStoragePermissionLauncher.launch(Manifest.permission.WRITE_EXTERNAL_STORAGE)
                return
            }
            val publicMusicDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_MUSIC)
            val appDir = File(publicMusicDir, getString(R.string.app_recordings_folder_name))
            if (!appDir.exists() && !appDir.mkdirs()) {
                showAlertDialog(getString(R.string.error_dialog_title), getString(R.string.error_creating_directory_failed, appDir.name))
                return
            }
            val outputFile = File(appDir, desiredFileName)
            finalPathForDialog = outputFile.absolutePath
            try {
                FileOutputStream(outputFile).use { output ->
                    resolver.openInputStream(sourceFileUri)?.use { input ->
                        input.copyTo(output)
                    } ?: throw IOException(getString(R.string.error_saving_audio_copy_failed_input_null))
                }
                showAlertDialog(getString(R.string.info_audio_saved_locally), getString(R.string.success_audio_saved_to_music_path_dialog, finalPathForDialog))
                // Notificar a MediaScanner para que el archivo aparezca en otras apps
                MediaScannerConnection.scanFile(requireContext(), arrayOf(outputFile.toString()), null, null)
            } catch (ioe: IOException) {
                Log.e(TAG_RECORD_AUDIO, "IOException al guardar audio (API < Q).", ioe)
                showAlertDialog(getString(R.string.error_dialog_title), getString(R.string.error_saving_audio_copy_failed, ioe.localizedMessage ?: getString(R.string.unknown_error)))
            } catch (e: Exception) { // Captura genérica
                Log.e(TAG_RECORD_AUDIO, "Excepción al guardar audio (API < Q).", e)
                showAlertDialog(getString(R.string.error_dialog_title), getString(R.string.error_saving_audio_copy_failed, e.localizedMessage ?: getString(R.string.unknown_error)))
            }
        }
    }


    // --- Funciones públicas para la actividad contenedora ---
    fun getRecordedAudioUri(): Uri? = currentPlayableAudioUri
    fun getRecordedAudioOriginalName(): String? = currentPlayableAudioOriginalName
    val isRecording: Boolean get() = currentRecordingState == RecordingState.RECORDING || currentRecordingState == RecordingState.PAUSED

    fun resetState() {
        aiProcessingJob?.cancel(); aiProcessingJob = null
        if (isRecording) { // Si está grabando o pausado
            amplitudeUpdateHandler.removeCallbacks(amplitudeUpdater)
            stopRecordingFlow(bySystem = true) // Detener la grabación (marcar como por sistema para no notificar)
        }
        deleteRecordedAudio(notifyListener = false) // Eliminar cualquier audio y resetear UI, sin notificar
        currentRecordingState = RecordingState.IDLE // Asegurar estado IDLE
        recordingChronometer = 0L
        if(::waveformView.isInitialized) waveformView.clearWaveform()
        listener?.onRecordingStateChanged(isRecording = false) // Notificar que ya no se está grabando
        updateUI() // Actualizar UI final
    }

    companion object {
        private const val TAG_RECORD_AUDIO = "RecordAudioFragment" // Etiqueta específica para logs
        private const val TAG_RESAMPLER = "ResamplerUtil" // Etiqueta para logs de Resampler
        @JvmStatic
        fun newInstance() = RecordAudioFragment()
    }
}


===== Archivo: app\src\main\java\com\example\mexicoparanormal\RelatoViewerActivity.kt =====


package com.example.mexicoparanormal

import android.os.Bundle
import android.util.Log
import android.view.View
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import com.bumptech.glide.Glide
import com.example.mexicoparanormal.databinding.ActivityRelatoViewerBinding // Asegúrate que el nombre del binding es correcto
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.firestore.FirebaseFirestore
import java.text.SimpleDateFormat // Import para SimpleDateFormat
import java.util.Date // Import para Date
import java.util.Locale // Import para Locale

class RelatoViewerActivity : AppCompatActivity() {

    private lateinit var binding: ActivityRelatoViewerBinding
    private lateinit var firestore: FirebaseFirestore
    // private lateinit var auth: FirebaseAuth // Descomenta si necesitas verificar el usuario actual para alguna lógica específica del visor
    private var storyId: String? = null
    private var isPendingReview: Boolean = false

    companion object {
        private const val TAG = "RelatoViewerActivity" // Etiqueta para logs
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityRelatoViewerBinding.inflate(layoutInflater) // Usa el nombre correcto de tu clase de Binding
        setContentView(binding.root)

        firestore = FirebaseFirestore.getInstance()
        // auth = FirebaseAuth.getInstance() // Descomenta si es necesario

        storyId = intent.getStringExtra(getString(R.string.intent_extra_story_id_key)) // Usar constante de string
        isPendingReview = intent.getBooleanExtra(getString(R.string.intent_extra_is_pending_review_key), false) // Usar constante de string

        // Configura el botón de regreso (asegúrate que el ID sea correcto)
        binding.btnBackRelatoViewer.setOnClickListener {
            finish()
        }

        if (storyId == null) {
            Toast.makeText(this, getString(R.string.content_not_found), Toast.LENGTH_LONG).show()
            finish()
            return
        }

        setupUIForPendingStatus()
        loadStoryData()
    }

    private fun setupUIForPendingStatus() {
        if (isPendingReview) {
            binding.textViewPendingReviewStatusRelato.visibility = View.VISIBLE // ID Corregido
            // binding.textViewPendingReviewStatusRelato.text = getString(R.string.status_pending_review_message) // El texto ya está en el XML

            // Ocultar o deshabilitar elementos de interacción
            binding.interactionLayoutRelato.visibility = View.GONE // ID Corregido (Layout que contiene los botones)
        } else {
            binding.textViewPendingReviewStatusRelato.visibility = View.GONE // ID Corregido
            binding.interactionLayoutRelato.visibility = View.VISIBLE // ID Corregido
        }
    }

    private fun loadStoryData() {
        val collectionPath = if (isPendingReview) getString(R.string.firestore_collection_stories_pending) else getString(R.string.firestore_collection_stories_approved) // Ajusta "stories" si tu colección de aprobados es otra

        storyId?.let { id ->
            firestore.collection(collectionPath).document(id)
                .get()
                .addOnSuccessListener { document ->
                    if (document != null && document.exists()) {
                        binding.storyTitleTextViewer.text = document.getString(getString(R.string.firestore_field_title)) ?: getString(R.string.title_not_available) // ID Corregido
                        binding.storyContentTextViewer.text = document.getString(getString(R.string.firestore_field_text)) ?: getString(R.string.content_not_available) // ID Corregido
                        binding.storyAuthorTextViewer.text = getString(R.string.author_format, document.getString(getString(R.string.firestore_field_authorUsername)) ?: getString(R.string.unknown_user)) // ID Corregido

                        val timestamp = document.getTimestamp(getString(R.string.firestore_field_timestamp))?.toDate()
                        if (timestamp != null) {
                            val sdf = SimpleDateFormat(getString(R.string.date_format_dd_mm_yyyy_hh_mm), Locale.getDefault()) // Locale importado
                            binding.storyDateTextViewer.text = getString(R.string.date_format_viewer, sdf.format(timestamp)) // ID Corregido
                        } else {
                            binding.storyDateTextViewer.text = getString(R.string.date_format_viewer, getString(R.string.date_type_unknown)) // ID Corregido
                        }

                        binding.storyLocationTextViewer.text = document.getString(getString(R.string.firestore_field_location)) ?: getString(R.string.location_unknown) // ID Corregido
                        binding.storyTypeTextViewer.text = document.getString(getString(R.string.firestore_field_storyType)) ?: getString(R.string.type_unknown) // ID Corregido


                        val imageUrl = document.getString(getString(R.string.firestore_field_imageUrl))
                        if (!imageUrl.isNullOrEmpty()) {
                            binding.storyOptionalImageViewer.visibility = View.VISIBLE // ID Corregido
                            Glide.with(this)
                                .load(imageUrl)
                                .placeholder(R.drawable.placeholder_image)
                                .error(R.drawable.placeholder_image)
                                .into(binding.storyOptionalImageViewer) // ID Corregido
                        } else {
                            binding.storyOptionalImageViewer.visibility = View.GONE // ID Corregido
                        }

                        // Actualiza el título de la pantalla si lo deseas
                        binding.screenTitleRelatoViewer.text = document.getString(getString(R.string.firestore_field_title)) ?: getString(R.string.title_not_available)


                    } else {
                        Log.e(TAG, getString(R.string.log_document_not_found_in_collection, collectionPath, id))
                        Toast.makeText(this, getString(R.string.content_not_found), Toast.LENGTH_LONG).show()
                        finish()
                    }
                }
                .addOnFailureListener { exception ->
                    Log.e(TAG, getString(R.string.log_error_loading_story_with_id, id), exception)
                    Toast.makeText(this, getString(R.string.error_loading_content), Toast.LENGTH_LONG).show()
                    finish()
                }
        }
    }
}


===== Archivo: app\src\main\java\com\example\mexicoparanormal\SearchResultsActivity.kt =====


package com.example.mexicoparanormal

import android.content.Context
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageButton
import android.widget.TextView
import android.widget.Toast
import androidx.activity.enableEdgeToEdge
import androidx.appcompat.app.AppCompatActivity
import androidx.core.view.ViewCompat
import androidx.core.view.WindowInsetsCompat
import androidx.core.view.accessibility.AccessibilityNodeInfoCompat
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import androidx.core.view.AccessibilityDelegateCompat
import com.google.android.material.chip.Chip

class SearchResultsActivity : AppCompatActivity() {
    private lateinit var recyclerView: RecyclerView
    private lateinit var searchAdapter: SearchResultAdapter

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()
        setContentView(R.layout.activity_search_results)

        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.search_results_main)) { v, insets ->
            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())
            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)
            insets
        }

        // Configurar botón de regreso (CORRECCIÓN IMPORTANTE)
        val btnBack: ImageButton = findViewById(R.id.btn_back)
        btnBack.setOnClickListener { finish() }

        // Configurar título
        val searchQuery = intent.getStringExtra("SEARCH_QUERY") ?: "fantasma"
        findViewById<TextView>(R.id.title_search_results).text =
            getString(R.string.search_results_title, searchQuery)

        // Contador de resultados
        findViewById<TextView>(R.id.text_results_count).text =
            getString(R.string.showing_results, 5)

        // Configurar RecyclerView con accesibilidad
        recyclerView = findViewById<RecyclerView>(R.id.recycler_search_results).apply {
            layoutManager = LinearLayoutManager(this@SearchResultsActivity)
            searchAdapter = SearchResultAdapter(this@SearchResultsActivity, createSampleData())
            adapter = searchAdapter

            ViewCompat.setAccessibilityDelegate(this, object : AccessibilityDelegateCompat() {
                override fun onInitializeAccessibilityNodeInfo(host: View, info: AccessibilityNodeInfoCompat) {
                    super.onInitializeAccessibilityNodeInfo(host, info)
                    info.contentDescription =
                        getString(R.string.results_list_dynamic_description, searchAdapter.itemCount)
                }
            })
        }

        // Configurar filtros
        listOf<Chip>(
            findViewById(R.id.filter_location),
            findViewById(R.id.filter_date),
            findViewById(R.id.filter_types)
        ).forEach { chip ->
            chip.setOnClickListener {
                Toast.makeText(this, "Filtrar por: ${chip.text}", Toast.LENGTH_SHORT).show()
            }
        }

        // Configurar paginación (PREPARADO PARA IMPLEMENTACIÓN FUTURA)
        findViewById<View>(R.id.btn_previous).setOnClickListener {
            Toast.makeText(this, "Página anterior", Toast.LENGTH_SHORT).show()
        }
        findViewById<View>(R.id.btn_next).setOnClickListener {
            Toast.makeText(this, "Página siguiente", Toast.LENGTH_SHORT).show()
        }
    }

    private fun createSampleData(): List<SearchResult> {
        return listOf(
            SearchResult(1, SearchResultType.STORY, "Encuentro en Oaxaca", "Oaxaca", "2022"),
            SearchResult(2, SearchResultType.PHOTO, "Casa abandonada en Puebla", "Puebla", "2021"),
            SearchResult(3, SearchResultType.VIDEO, "OVNI en Sonora", "Sonora", "2023")
        )
    }

    class SearchResultAdapter(
        private val context: Context,
        private val results: List<SearchResult>
    ) : RecyclerView.Adapter<SearchResultAdapter.SearchResultViewHolder>() {

        override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): SearchResultViewHolder {
            val itemView = LayoutInflater.from(parent.context)
                .inflate(R.layout.item_search_result, parent, false)
            return SearchResultViewHolder(itemView)
        }

        override fun onBindViewHolder(holder: SearchResultViewHolder, position: Int) {
            val result = results[position]
            val titleText = when (result.type) {
                SearchResultType.STORY -> context.getString(R.string.result_story, result.title)
                SearchResultType.PHOTO -> context.getString(R.string.result_photo, result.title)
                SearchResultType.VIDEO -> context.getString(R.string.result_video, result.title)
            }

            with(holder) {
                titleTextView.text = context.getString(R.string.result_item_title, position + 1, titleText)
                titleTextView.contentDescription = context.getString(
                    R.string.result_item_description,
                    position + 1,
                    titleText
                )

                detailsTextView.text = context.getString(R.string.location_format, result.location, result.date)
                detailsTextView.contentDescription = context.getString(
                    R.string.result_details_description,
                    result.location,
                    result.date
                )
            }
        }

        override fun getItemCount() = results.size

        class SearchResultViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
            val titleTextView: TextView = itemView.findViewById(R.id.text_result_title)
            val detailsTextView: TextView = itemView.findViewById(R.id.text_result_details)
        }
    }

    data class SearchResult(
        val id: Int,
        val type: SearchResultType,
        val title: String,
        val location: String,
        val date: String
    )

    enum class SearchResultType {
        STORY, PHOTO, VIDEO
    }
}


===== Archivo: app\src\main\java\com\example\mexicoparanormal\SettingsFragment.kt =====


package com.example.mexicoparanormal

import android.app.AlertDialog // Importación para AlertDialog
import android.content.Intent
import android.os.Bundle
import android.util.Log
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Toast
import androidx.fragment.app.Fragment
import com.bumptech.glide.Glide
import com.example.mexicoparanormal.databinding.FragmentSettingsBinding
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.auth.FirebaseAuthRecentLoginRequiredException // Importación para manejo de error específico
import com.google.firebase.firestore.FirebaseFirestore
// Si usas el SDK de Cloudinary, necesitarás sus importaciones aquí
// import com.cloudinary.android.MediaManager
// import com.cloudinary.android.callback.ErrorInfo
// import com.cloudinary.android.callback.DestroyCallback


class SettingsFragment : Fragment() {

    private var _binding: FragmentSettingsBinding? = null
    private val binding get() = _binding!!
    private lateinit var auth: FirebaseAuth
    private lateinit var firestore: FirebaseFirestore

    companion object {
        private const val TAG = "SettingsFragment" // Etiqueta para logs
    }

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        _binding = FragmentSettingsBinding.inflate(inflater, container, false)
        val root = binding.root

        auth = FirebaseAuth.getInstance()
        firestore = FirebaseFirestore.getInstance()

        loadUserProfileData()

        binding.optionEditProfile.setOnClickListener {
            startActivity(Intent(requireContext(), EditProfileActivity::class.java))
        }

        binding.optionLogout.setOnClickListener {
            auth.signOut()
            val intent = Intent(requireContext(), MainActivity::class.java)
            intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
            startActivity(intent)
            activity?.finish()
        }

        // Configurar Click Listener para "Eliminar Cuenta"
        binding.optionDeleteAccount.setOnClickListener {
            showDeleteAccountConfirmationDialog()
        }

        // Aquí puedes añadir listeners para otras opciones como comentarios, favoritos, etc.
        // binding.optionComments.setOnClickListener { /* Lógica para comentarios */ }
        // binding.optionFavorites.setOnClickListener { /* Lógica para favoritos */ }

        return root
    }

    private fun loadUserProfileData() {
        val currentUser = auth.currentUser
        if (currentUser != null) {
            val userId = currentUser.uid
            firestore.collection(getString(R.string.firestore_collection_users)).document(userId).get()
                .addOnSuccessListener { document ->
                    if (document.exists()) {
                        val username = document.getString(getString(R.string.firestore_field_username))
                        val location = document.getString(getString(R.string.firestore_field_location))
                        binding.textViewUsernameDisplay.text = username ?: getString(R.string.username_not_set)
                        binding.textViewLocationDisplay.text = location ?: getString(R.string.location_not_set)
                        Log.d(TAG, getString(R.string.log_profile_data_loaded, userId))

                        val profileImageUrl = document.getString(getString(R.string.firestore_field_profileImageUrl))
                        if (!profileImageUrl.isNullOrEmpty()) {
                            Glide.with(this)
                                .load(profileImageUrl)
                                .circleCrop()
                                .placeholder(R.drawable.ic_perfil)
                                .error(R.drawable.ic_perfil)
                                .into(binding.imageViewProfilePictureSettings)
                        } else {
                            binding.imageViewProfilePictureSettings.setImageResource(R.drawable.ic_perfil)
                        }
                    } else {
                        Log.d(TAG, getString(R.string.log_user_document_not_found_settings, userId))
                        binding.textViewUsernameDisplay.text = getString(R.string.unknown_user)
                        binding.textViewLocationDisplay.text = getString(R.string.undefined_location)
                        binding.imageViewProfilePictureSettings.setImageResource(R.drawable.ic_perfil)
                    }
                }
                .addOnFailureListener { exception ->
                    Log.e(TAG, getString(R.string.log_error_loading_profile_data_settings, userId), exception)
                    Toast.makeText(requireContext(), getString(R.string.error_loading_profile_data_message, exception.message), Toast.LENGTH_SHORT).show()
                    binding.textViewUsernameDisplay.text = getString(R.string.error_loading_name)
                    binding.textViewLocationDisplay.text = getString(R.string.error_loading_location)
                    binding.imageViewProfilePictureSettings.setImageResource(R.drawable.ic_perfil)
                }
        } else {
            Log.e(TAG, getString(R.string.log_user_not_authenticated_settings))
            Toast.makeText(requireContext(), getString(R.string.user_not_authenticated_message), Toast.LENGTH_SHORT).show()
            binding.textViewUsernameDisplay.text = getString(R.string.not_authenticated)
            binding.textViewLocationDisplay.text = ""
            binding.imageViewProfilePictureSettings.setImageResource(R.drawable.ic_perfil)
        }
    }

    // --- Inicio: Funcionalidad de Eliminar Cuenta ---

    private fun showDeleteAccountConfirmationDialog() {
        val currentUser = auth.currentUser
        if (currentUser == null) {
            Toast.makeText(requireContext(), getString(R.string.error_user_not_authenticated_for_action), Toast.LENGTH_SHORT).show()
            return
        }

        AlertDialog.Builder(requireContext())
            .setTitle(getString(R.string.dialog_delete_account_title))
            .setMessage(getString(R.string.dialog_delete_account_message))
            .setPositiveButton(getString(R.string.action_delete_account_confirm)) { _, _ ->
                initiateAccountDeletionProcess()
            }
            .setNegativeButton(android.R.string.cancel, null) // Usar string de Android para "Cancelar"
            .show()
    }

    private fun initiateAccountDeletionProcess() {
        showLoading(getString(R.string.info_deleting_account_progress))

        val firebaseUser = auth.currentUser
        if (firebaseUser == null) { // Doble chequeo, aunque showDeleteAccountConfirmationDialog ya lo hace
            Toast.makeText(requireContext(), getString(R.string.error_user_not_authenticated_for_action), Toast.LENGTH_SHORT).show()
            hideLoading()
            return
        }
        val userId = firebaseUser.uid

        // Paso 1: Obtener la URL de la imagen de perfil de Firestore ANTES de eliminar cualquier cosa
        firestore.collection(getString(R.string.firestore_collection_users)).document(userId).get()
            .addOnSuccessListener { documentSnapshot ->
                val profileImageUrlFromFirestore = if (documentSnapshot.exists()) {
                    documentSnapshot.getString(getString(R.string.firestore_field_profileImageUrl))
                } else {
                    Log.w(TAG, "El documento del usuario no existe en Firestore al intentar obtener la URL de la imagen.")
                    null
                }
                // Continuar con la eliminación de Auth, pasando la URL obtenida
                deleteFirebaseUser(firebaseUser, userId, profileImageUrlFromFirestore)
            }
            .addOnFailureListener { exception ->
                Log.e(TAG, "Error al obtener el documento del usuario de Firestore para la URL de la imagen: ${exception.message}", exception)
                Toast.makeText(requireContext(), "Error al obtener datos del perfil para eliminación. Se intentará continuar.", Toast.LENGTH_SHORT).show()
                // Continuar el proceso de eliminación de Auth/Firestore pero no podremos estar seguros de eliminar la imagen de Cloudinary.
                deleteFirebaseUser(firebaseUser, userId, null)
            }
    }

    private fun deleteFirebaseUser(firebaseUser: com.google.firebase.auth.FirebaseUser, userId: String, profileImageUrl: String?) {
        // Paso 2: Eliminar el usuario de Firebase Authentication
        firebaseUser.delete()
            .addOnSuccessListener {
                Log.d(TAG, "Usuario eliminado de Firebase Authentication.")
                // Paso 3: Eliminar el documento del usuario en Firestore
                deleteFirestoreUserData(userId, profileImageUrl)
            }
            .addOnFailureListener { authException ->
                Log.e(TAG, "Error al eliminar usuario de Firebase Auth: ${authException.message}", authException)
                if (authException is FirebaseAuthRecentLoginRequiredException) {
                    Toast.makeText(requireContext(), "Por seguridad, debes volver a iniciar sesión para eliminar tu cuenta. Cierra sesión e inténtalo de nuevo.", Toast.LENGTH_LONG).show()
                    // Opcional: Guiar al usuario para que vuelva a iniciar sesión.
                    // auth.signOut() // Forzar cierre de sesión
                    // val intent = Intent(requireContext(), LoginActivity::class.java) // Asumiendo LoginActivity
                    // intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
                    // startActivity(intent)
                    // activity?.finish()
                } else {
                    Toast.makeText(requireContext(), getString(R.string.error_deleting_auth_user, authException.message), Toast.LENGTH_LONG).show()
                }
                hideLoading()
            }
    }

    private fun deleteFirestoreUserData(userId: String, profileImageUrl: String?) {
        firestore.collection(getString(R.string.firestore_collection_users)).document(userId)
            .delete()
            .addOnSuccessListener {
                Log.d(TAG, "Documento de usuario eliminado de Firestore.")
                // Paso 4: Intentar eliminar la foto de perfil de Cloudinary
                attemptCloudinaryProfilePictureDeletion(profileImageUrl)
            }
            .addOnFailureListener { firestoreException ->
                Log.e(TAG, getString(R.string.error_deleting_user_data_firestore, firestoreException.message), firestoreException)
                Toast.makeText(requireContext(), getString(R.string.error_deleting_user_data_firestore, firestoreException.message), Toast.LENGTH_LONG).show()
                // Aunque Firestore falle, la cuenta de Auth fue eliminada. Proceder con Cloudinary y completar.
                attemptCloudinaryProfilePictureDeletion(profileImageUrl)
            }
    }

    private fun attemptCloudinaryProfilePictureDeletion(imageUrl: String?) {
        if (!imageUrl.isNullOrEmpty()) {
            // La eliminación de Cloudinary es "mejor esfuerzo" desde el cliente.
            // La lógica real debe manejar la asincronía y llamar a completeAccountDeletion() en su finalización.
            deleteProfilePictureFromCloudinary(imageUrl) { success ->
                if (success) {
                    Log.d(TAG, "Eliminación de foto de perfil de Cloudinary (o intento) gestionada.")
                } else {
                    Log.w(TAG, "Fallo o no se intentó la eliminación de foto de perfil de Cloudinary.")
                    // El Toast de advertencia ya se mostraría dentro de deleteProfilePictureFromCloudinary
                }
                completeAccountDeletion() // Completar la eliminación independientemente del resultado de Cloudinary
            }
        } else {
            Log.d(TAG, "No hay URL de imagen de perfil para eliminar de Cloudinary, o no se pudo obtener.")
            completeAccountDeletion() // No hay imagen, proceder a completar la eliminación
        }
    }

    // Implementa esta función con tu lógica real de Cloudinary
    private fun deleteProfilePictureFromCloudinary(imageUrl: String, onDeletionAttemptFinished: (Boolean) -> Unit) {
        // Aquí implementarías la lógica para eliminar la imagen de Cloudinary.
        // Necesitarás extraer el public_id de imageUrl si es una URL completa.
        // Ejemplo: val publicId = extractPublicIdFromUrl(imageUrl) // Debes implementar esta función
        // Y luego usar la API de Cloudinary, por ejemplo:
        // CloudinaryManager.getInstance(requireContext()).mediaManager.destroy(publicId, object : DestroyCallback {
        //     override fun onSuccess() {
        //         Log.d(TAG, "Foto de perfil eliminada de Cloudinary: $publicId")
        //         onDeletionAttemptFinished(true)
        //     }
        //     override fun onError(error: ErrorInfo) {
        //         Log.w(TAG, "Error al eliminar foto de Cloudinary: $publicId, ${error.description}")
        //         Toast.makeText(requireContext(), getString(R.string.warning_profile_picture_deletion_failed) + ": " + error.description, Toast.LENGTH_LONG).show()
        //         onDeletionAttemptFinished(false) // Indicar fallo, pero la eliminación de cuenta continuará
        //     }
        // })
        // if (publicId == null) { // Si no se pudo extraer el publicId
        //    Log.w(TAG, "No se pudo extraer public_id de la URL para Cloudinary: $imageUrl")
        //    onDeletionAttemptFinished(false)
        // }

        // --- INICIO SIMULACIÓN / PLACEHOLDER ---
        // ESTA ES UNA SIMULACIÓN. Reemplaza con tu lógica real de Cloudinary.
        Log.d(TAG, "Intentando eliminar de Cloudinary (simulación): $imageUrl")
        android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({
            val simulatedSuccess = true // Cambia a false para simular un fallo
            if (simulatedSuccess) {
                Log.d(TAG, "Foto de perfil (simulada) eliminada de Cloudinary: $imageUrl")
            } else {
                Log.w(TAG, "Fallo al eliminar (simulado) foto de perfil de Cloudinary: $imageUrl")
                Toast.makeText(requireContext(), getString(R.string.warning_profile_picture_deletion_failed) + " (simulado)", Toast.LENGTH_LONG).show()
            }
            onDeletionAttemptFinished(simulatedSuccess)
        }, 1000) // Simula un retraso de red de 1 segundo
        // --- FIN SIMULACIÓN / PLACEHOLDER ---
    }

    /*
    // Ejemplo de función para extraer public_id de la URL de Cloudinary.
    // Necesitarás adaptarla a la estructura de tus URLs.
    private fun extractPublicIdFromUrl(imageUrl: String): String? {
        // Ejemplo: "http://res.cloudinary.com/demo/image/upload/v12345/folder/public_id.jpg"
        // El public_id podría ser "folder/public_id"
        // Esta es una implementación muy básica y puede necesitar ajustes.
        try {
            val uri = java.net.URI(imageUrl)
            val path = uri.path
            // Buscar el segmento después de "/upload/" y la versión (e.g., /v12345/)
            val uploadMarker = "/upload/"
            val pathAfterUploadMarker = path.substringAfter(uploadMarker, "")
            if (pathAfterUploadMarker.isNotEmpty()) {
                val publicIdWithVersionAndExtension = pathAfterUploadMarker.substringAfter('/', "") // Quita la versión si está presente
                if (publicIdWithVersionAndExtension.isNotEmpty()) {
                    return publicIdWithVersionAndExtension.substringBeforeLast('.')
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error al extraer public_id de la URL: $imageUrl", e)
        }
        Log.w(TAG, "No se pudo extraer public_id de Cloudinary URL: $imageUrl")
        return null
    }
    */

    private fun completeAccountDeletion() {
        // Asegurarse de que el usuario está deslogueado, aunque ya debería estarlo si delete() tuvo éxito
        // o si se manejó un error que no permitió la eliminación de Auth.
        // Si delete() falló y el usuario no fue deslogueado, signOut aquí es importante.
        if (auth.currentUser != null) { // Solo cierra sesión si todavía hay un usuario (por si delete() falló antes)
            auth.signOut()
        }

        Toast.makeText(requireContext(), getString(R.string.success_account_deleted), Toast.LENGTH_LONG).show()
        hideLoading()

        // Redirigir al MainActivity y limpiar la pila
        val intent = Intent(requireContext(), MainActivity::class.java)
        intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
        startActivity(intent)
        activity?.finish() // Finalizar la actividad actual
    }

    private fun showLoading(message: String) {
        binding.settingsProgressBar.visibility = View.VISIBLE
        binding.settingsProgressMessage.text = message
        binding.settingsProgressMessage.visibility = View.VISIBLE
        // Opcionalmente, deshabilitar interacciones del usuario aquí
    }

    private fun hideLoading() {
        binding.settingsProgressBar.visibility = View.GONE
        binding.settingsProgressMessage.visibility = View.GONE
        // Opcionalmente, rehabilitar interacciones del usuario aquí
    }

    // --- Fin: Funcionalidad de Eliminar Cuenta ---

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }

    override fun onResume() {
        super.onResume()
        // Si el usuario fue eliminado y redirigido, este fragmento podría ser destruido pronto.
        // loadUserProfileData() ya verifica auth.currentUser, lo cual es bueno.
        // Si no hay usuario actual (porque fue eliminado o cerró sesión), no cargará nada.
        if (auth.currentUser != null) {
            loadUserProfileData() // Cargar/refrescar datos si el usuario sigue autenticado
        } else {
            // Si el usuario es nulo (quizás después de una eliminación fallida donde se hizo signOut),
            // podrías querer limpiar la UI o incluso navegar fuera de esta pantalla.
            // Por ahora, loadUserProfileData() maneja el estado de UI para usuario no autenticado.
        }
    }
}


===== Archivo: app\src\main\java\com\example\mexicoparanormal\StoryInputPagerAdapter.kt =====


package com.example.mexicoparanormal // Asegúrate de que el paquete sea el correcto

import androidx.fragment.app.Fragment
import androidx.fragment.app.FragmentActivity
import androidx.viewpager2.adapter.FragmentStateAdapter

/**
 * Adaptador para gestionar los fragmentos de las pestañas en UploadStoryActivity.
 * Pestañas: Escribir Relato, Grabar Audio, Adjuntar Audio.
 */
class StoryInputPagerAdapter(activity: FragmentActivity) : FragmentStateAdapter(activity) {

    // Define el número total de pestañas/fragmentos que el ViewPager2 manejará.
    override fun getItemCount(): Int = 3 // Tenemos tres pestañas

    /**
     * Crea y devuelve el Fragment apropiado para la posición dada.
     * Este método se llama cuando el ViewPager2 necesita un nuevo fragmento
     * o cuando se restaura el estado.
     *
     * @param position La posición de la pestaña para la cual crear el fragmento.
     * @return Una nueva instancia del Fragment correspondiente.
     */
    override fun createFragment(position: Int): Fragment {
        return when (position) {
            0 -> WriteStoryFragment.newInstance()      // Pestaña 0: Escribir Relato
            1 -> RecordAudioFragment.newInstance()      // Pestaña 1: Grabar Audio
            2 -> AttachAudioFragment.newInstance()      // Pestaña 2: Adjuntar Audio
            else -> throw IllegalStateException("Posición de fragmento inválida: $position. Se esperaban 0, 1 o 2.")
        }
    }
}


===== Archivo: app\src\main\java\com\example\mexicoparanormal\UploadImageActivity.kt =====


package com.example.mexicoparanormal

import android.app.Activity
import android.app.AlertDialog
import android.content.ContentResolver
import android.content.Intent
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.graphics.Matrix
import androidx.exifinterface.media.ExifInterface
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.provider.OpenableColumns
import android.text.Editable
import android.text.TextWatcher
import android.util.Log
import android.view.View
import android.widget.AdapterView
import android.widget.ArrayAdapter
import android.widget.EditText
import android.widget.Toast
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AppCompatActivity
import androidx.core.net.toUri
import androidx.core.view.isVisible
import com.cloudinary.android.MediaManager
import com.cloudinary.android.callback.ErrorInfo
import com.cloudinary.android.callback.UploadCallback
import com.example.mexicoparanormal.databinding.ActivityUploadImageBinding
import com.google.android.material.textfield.TextInputLayout
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.firestore.FieldValue
import com.google.firebase.firestore.FirebaseFirestore
import java.io.ByteArrayOutputStream
import java.io.FileNotFoundException
import java.io.IOException
import java.io.InputStream
import java.text.ParseException
import java.text.SimpleDateFormat
import java.util.*
import kotlin.collections.HashMap
// import kotlin.math.max // No se usa directamente, roundToInt sí
import kotlin.math.roundToInt

class UploadImageActivity : AppCompatActivity(), DialogCustomDatePicker.OnDateSelectedListener {

    private lateinit var binding: ActivityUploadImageBinding
    private lateinit var auth: FirebaseAuth
    private lateinit var firestore: FirebaseFirestore
    private var imageUri: Uri? = null
    private val MIN_YEAR_IMAGE = 1826 // Año mínimo para fecha de imagen
    private val dateFormatImage = SimpleDateFormat("dd/MM/yyyy", Locale.getDefault())

    private var selectedLatitude: Double? = null
    private var selectedLongitude: Double? = null
    private var selectedCityName: String? = null

    private lateinit var mapsActivityResultLauncher: ActivityResultLauncher<Intent>

    private var isSubmitting = false
    private var currentUploadRequestId: String? = null

    private val selectImageResultLauncher = registerForActivityResult(
        ActivityResultContracts.GetContent()
    ) { uri: Uri? ->
        if (uri != null) {
            try {
                val contentResolver: ContentResolver = applicationContext.contentResolver
                val type = contentResolver.getType(uri)
                val allowedMimeTypes = listOf("image/jpeg", "image/png", "image/jfif", "image/webp")

                if (type != null && allowedMimeTypes.contains(type.lowercase(Locale.getDefault()))) {
                    val fileSize = getFileSize(uri, contentResolver)
                    val maxFileSizeInBytes = MAX_FILE_SIZE_MB_IMAGE * 1024 * 1024
                    if (fileSize > maxFileSizeInBytes) {
                        showToast(getString(R.string.error_audio_file_too_large_detailed, MAX_FILE_SIZE_MB_IMAGE, fileSize / (1024 * 1024)))
                        clearImageSelection()
                        return@registerForActivityResult
                    }

                    imageUri = uri
                    binding.imageViewPreview.setImageURI(uri)
                    binding.imageViewPreview.isVisible = true
                    binding.textViewPreviewLabel.isVisible = true
                    Log.d(TAG, getString(R.string.log_image_selected, uri.toString()))
                    showToast(getString(R.string.image_selection_successful))
                } else {
                    val allowedFormats = allowedMimeTypes.joinToString(", ") { it.substringAfter("/") }
                    showToast(getString(R.string.error_invalid_file_type_specific, allowedFormats))
                    clearImageSelection()
                }
            } catch (e: SecurityException) {
                Log.e(TAG, getString(R.string.log_security_exception_processing_image, uri.toString()), e)
                showToast(getString(R.string.error_accessing_file_permission, uri.lastPathSegment ?: getString(R.string.selected_image_default_name)))
                clearImageSelection()
            } catch (e: IllegalArgumentException) {
                Log.e(TAG, getString(R.string.log_illegal_argument_processing_image, uri.toString()), e)
                showToast(getString(R.string.error_invalid_file_type_specific, getString(R.string.unknown_format)))
                clearImageSelection()
            } catch (e: Exception) {
                Log.e(TAG, getString(R.string.log_unexpected_error_processing_image, uri.toString()), e)
                showToast(getString(R.string.upload_file_error_message, e.localizedMessage ?: getString(R.string.unknown_error)))
                clearImageSelection()
            }
        } else {
            clearImageSelection()
            Log.d(TAG, getString(R.string.log_image_selection_cancelled))
            showToast(getString(R.string.image_selection_cancelled))
        }
    }

    companion object {
        private const val TAG = "UploadImageActivity"
        private const val MAX_FILE_SIZE_MB_IMAGE = 10 // Tamaño máximo en MB para la imagen
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityUploadImageBinding.inflate(layoutInflater)
        setContentView(binding.root)

        auth = FirebaseAuth.getInstance()
        firestore = FirebaseFirestore.getInstance()
        dateFormatImage.isLenient = false // Para validación estricta de fechas

        if (auth.currentUser == null) {
            Log.w(TAG, getString(R.string.log_user_not_authenticated_oncreate))
            Toast.makeText(this, getString(R.string.error_user_not_authenticated), Toast.LENGTH_LONG).show()
            finish()
            return
        }

        mapsActivityResultLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result ->
            if (result.resultCode == Activity.RESULT_OK) {
                result.data?.let { data ->
                    selectedLatitude = data.getDoubleExtra(getString(R.string.intent_extra_latitude_result), 0.0).takeIf { lat -> lat != 0.0 }
                    selectedLongitude = data.getDoubleExtra(getString(R.string.intent_extra_longitude_result), 0.0).takeIf { lon -> lon != 0.0 }
                    selectedCityName = data.getStringExtra(getString(R.string.intent_extra_cityname_result))
                    Log.i(TAG, getString(R.string.log_coordinates_received, selectedLatitude.toString(), selectedLongitude.toString(), selectedCityName))
                    actualizarUIcoordenadas()
                }
            } else {
                Log.d(TAG, getString(R.string.log_map_selection_cancelled))
            }
        }

        if (savedInstanceState != null) {
            selectedLatitude = savedInstanceState.getDouble("selectedLatitude", 0.0).takeIf { it != 0.0 }
            selectedLongitude = savedInstanceState.getDouble("selectedLongitude", 0.0).takeIf { it != 0.0 }
            selectedCityName = savedInstanceState.getString("selectedCityName")
            imageUri = savedInstanceState.getString("imageUriKey")?.let { Uri.parse(it) }
            if (imageUri != null) {
                binding.imageViewPreview.setImageURI(imageUri)
                binding.imageViewPreview.isVisible = true
                binding.textViewPreviewLabel.isVisible = true
            }
            Log.d(TAG, getString(R.string.log_state_restored_upload_image, imageUri.toString(), selectedLatitude.toString()))
        }
        setupUI()
        checkCloudinaryInitialization()
    }

    private fun setupUI() {
        setupTextWatchers()
        binding.btnBack.setOnClickListener { onBackPressedDispatcher.onBackPressed() }
        setupLocationSpinner()
        setupDateInputFields()
        setupCoordinatesSection()
        setupUploadCancelButton()

        binding.infoIconDate.setOnClickListener { if (it.isEnabled) showDateFormatInfoDialog() }
        binding.btnSelectFile.setOnClickListener { if (it.isEnabled) selectImageResultLauncher.launch("image/*") }
        binding.btnBorrarTodoImagen.setOnClickListener { clearAllFields() }
        binding.btnEnviarImagen.setOnClickListener { processImageSubmission() }

        // Visibilidad inicial de los campos
        binding.textInputLayoutYear.isVisible = false
        binding.textInputLayoutExactDate.isVisible = false
        binding.dateRangeLayout.isVisible = false
        binding.dateInputFieldsContainer.isVisible = false
        binding.textViewPreviewLabel.isVisible = false
        binding.imageViewPreview.isVisible = false
        binding.uploadProgressOverlayImage.isVisible = false
        binding.mapSelectionContainer.isVisible = binding.switchCoordinates.isChecked
        actualizarUIcoordenadas()
    }


    private fun checkCloudinaryInitialization() {
        try {
            if (MediaManager.get().cloudinary == null) {
                Log.e(TAG, getString(R.string.log_error_cloudinary_not_configured))
                Toast.makeText(this, getString(R.string.cloudinary_config_error), Toast.LENGTH_LONG).show()
                binding.btnEnviarImagen.isEnabled = false // Deshabilitar botón de envío
            }
        } catch (e: IllegalStateException) {
            Log.e(TAG, getString(R.string.log_error_cloudinary_not_initialized), e)
            Toast.makeText(this, getString(R.string.cloudinary_init_error), Toast.LENGTH_LONG).show()
            binding.btnEnviarImagen.isEnabled = false
        } catch (e: Exception) {
            Log.e(TAG, getString(R.string.log_error_cloudinary_unknown_check), e)
            Toast.makeText(this, getString(R.string.cloudinary_check_error), Toast.LENGTH_LONG).show()
            binding.btnEnviarImagen.isEnabled = false
        }
    }

    private fun setupUploadCancelButton() {
        binding.btnCancelUploadImage.setOnClickListener {
            currentUploadRequestId?.let { reqId ->
                try {
                    MediaManager.get().cancelRequest(reqId)
                    Log.i(TAG, getString(R.string.log_upload_cancellation_sent, reqId))
                } catch (e: Exception) {
                    Log.e(TAG, getString(R.string.log_error_cancelling_upload, reqId), e)
                }
            }
            handleUploadError(getString(R.string.upload_cancelled)) // Mostrar mensaje de cancelación
        }
    }


    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        selectedLatitude?.let { outState.putDouble("selectedLatitude", it) }
        selectedLongitude?.let { outState.putDouble("selectedLongitude", it) }
        outState.putString("selectedCityName", selectedCityName)
        imageUri?.let { outState.putString("imageUriKey", it.toString()) }
    }

    private fun setupLocationSpinner() {
        val locations = resources.getStringArray(R.array.locations_array)
        val adapter = ArrayAdapter(this, R.layout.spinner_item, locations)
        adapter.setDropDownViewResource(R.layout.spinner_dropdown_item)
        binding.spinnerLocation.adapter = adapter
        binding.spinnerLocation.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
            override fun onItemSelected(parent: AdapterView<*>?, view: View?, position: Int, id: Long) {
                if (position <= 1) { // "Seleccione una ubicación" o "desconocido"
                    if (binding.switchCoordinates.isChecked) {
                        binding.switchCoordinates.isChecked = false // Desactiva el switch si se selecciona una opción no válida
                    } else {
                        // Si el switch ya estaba apagado, solo oculta y resetea
                        binding.mapSelectionContainer.isVisible = false
                        resetCoordinates()
                    }
                }
            }
            override fun onNothingSelected(p0: AdapterView<*>?) { /* No se necesita acción */ }
        }
    }

    private fun setupCoordinatesSection() {
        binding.switchCoordinates.setOnCheckedChangeListener { _, isChecked ->
            if (isChecked) {
                if (binding.spinnerLocation.selectedItemPosition <= 1) { // No permitir si no hay estado válido
                    showToast(getString(R.string.error_select_state_first))
                    binding.switchCoordinates.isChecked = false // Revertir el switch
                    return@setOnCheckedChangeListener
                }
                binding.mapSelectionContainer.isVisible = true
            } else {
                binding.mapSelectionContainer.isVisible = false
                resetCoordinates() // Limpiar coordenadas si se apaga el switch
            }
            actualizarUIcoordenadas() // Actualizar la UI en ambos casos
        }

        binding.textViewSelectCoordinates.setOnClickListener {
            if (binding.spinnerLocation.selectedItemPosition > 1) { // Solo si hay un estado válido seleccionado
                openMapForSelection()
            } else {
                showToast(getString(R.string.error_select_state_first))
            }
        }
        binding.btnEditCoordinates.setOnClickListener {
            if (binding.spinnerLocation.selectedItemPosition > 1) { // Solo si hay un estado válido seleccionado
                openMapForSelection()
            }
            // No es necesario un 'else' aquí si el botón solo es visible cuando hay un estado
        }
    }

    private fun openMapForSelection() {
        val intent = Intent(this, MapsActivity::class.java).apply {
            putExtra(getString(R.string.intent_extra_selected_state), binding.spinnerLocation.selectedItem.toString())
            selectedLatitude?.let { putExtra(getString(R.string.intent_extra_latitude), it) }
            selectedLongitude?.let { putExtra(getString(R.string.intent_extra_longitude), it) }
        }
        mapsActivityResultLauncher.launch(intent)
    }


    private fun actualizarUIcoordenadas() {
        val coordinatesAvailable = selectedLatitude != null && selectedLongitude != null
        val switchIsOn = binding.switchCoordinates.isChecked

        if (switchIsOn) {
            binding.mapSelectionContainer.isVisible = true // Asegurar que el contenedor sea visible si el switch está ON
            if (coordinatesAvailable) {
                binding.textViewSelectedCoordinates.text = getString(R.string.selected_coordinates_format, selectedLatitude, selectedLongitude)
                binding.textViewSelectedCoordinates.isVisible = true
                binding.textViewCityName.text = selectedCityName ?: ""
                binding.textViewCityName.isVisible = !selectedCityName.isNullOrEmpty()
                binding.btnEditCoordinates.isVisible = true
                binding.textViewSelectCoordinates.isVisible = false
            } else {
                binding.textViewSelectedCoordinates.isVisible = false
                binding.textViewCityName.isVisible = false
                binding.btnEditCoordinates.isVisible = false
                binding.textViewSelectCoordinates.isVisible = true
            }
        } else {
            binding.mapSelectionContainer.isVisible = false // Ocultar si el switch está OFF
        }
    }


    private fun resetCoordinates() {
        selectedLatitude = null
        selectedLongitude = null
        selectedCityName = null
        actualizarUIcoordenadas() // Actualizar la UI para reflejar el reseteo
    }

    private fun setupDateInputFields() {
        binding.radioGroupDateType.setOnCheckedChangeListener { _, checkedId ->
            binding.textInputLayoutYear.isVisible = false
            binding.textInputLayoutExactDate.isVisible = false
            binding.dateRangeLayout.isVisible = false
            binding.dateInputFieldsContainer.isVisible = true // Mostrar contenedor de campos de fecha

            if (checkedId != -1) binding.radioUnknown.isChecked = false // Desmarcar "Desconocido" si se selecciona otro
            clearDateErrors() // Limpiar errores al cambiar tipo

            when (checkedId) {
                R.id.radioYear -> binding.textInputLayoutYear.isVisible = true
                R.id.radioExactDate -> binding.textInputLayoutExactDate.isVisible = true
                R.id.radioDateRange -> binding.dateRangeLayout.isVisible = true
                else -> binding.dateInputFieldsContainer.isVisible = false // Ocultar si no hay nada seleccionado
            }
        }
        binding.radioUnknown.setOnCheckedChangeListener { _, isChecked ->
            if (isChecked) {
                binding.radioGroupDateType.clearCheck() // Desmarcar otros tipos de fecha
                binding.textInputLayoutYear.isVisible = false
                binding.textInputLayoutExactDate.isVisible = false
                binding.dateRangeLayout.isVisible = false
                binding.dateInputFieldsContainer.isVisible = false // Ocultar contenedor
                clearDateFields() // Limpiar campos de fecha
                clearDateErrors() // Limpiar errores
            }
        }
        binding.editTextExactDate.setOnClickListener { if (it.isEnabled) showCustomDatePickerImageFragment() }

        // Asegurar visibilidad inicial correcta basada en el estado guardado o por defecto
        val initiallyCheckedId = binding.radioGroupDateType.checkedRadioButtonId
        if (initiallyCheckedId != -1) {
            binding.dateInputFieldsContainer.isVisible = true
            when (initiallyCheckedId) {
                R.id.radioYear -> binding.textInputLayoutYear.isVisible = true
                R.id.radioExactDate -> binding.textInputLayoutExactDate.isVisible = true
                R.id.radioDateRange -> binding.dateRangeLayout.isVisible = true
            }
        } else if (binding.radioUnknown.isChecked) {
            binding.dateInputFieldsContainer.isVisible = false
        } else {
            // Por defecto, si nada está seleccionado, el contenedor de campos de fecha debería estar oculto
            binding.dateInputFieldsContainer.isVisible = false
        }
    }

    private fun clearDateErrors() {
        binding.textInputLayoutYear.error = null
        binding.textInputLayoutExactDate.error = null
        binding.textInputLayoutStartYear.error = null
        binding.textInputLayoutEndYear.error = null
        binding.textDateMessageImage.isVisible = false // Ocultar mensaje de error de fecha
    }

    private fun showCustomDatePickerImageFragment() {
        val cal = Calendar.getInstance()
        var currentDay = cal.get(Calendar.DAY_OF_MONTH)
        var currentMonth = cal.get(Calendar.MONTH) // 0-11
        var currentYear = cal.get(Calendar.YEAR)

        val dateStr = binding.editTextExactDate.text.toString()
        if (dateStr.isNotEmpty()) {
            try {
                val date = dateFormatImage.parse(dateStr)
                date?.let {
                    val selectedCal = Calendar.getInstance().apply { time = it }
                    currentDay = selectedCal.get(Calendar.DAY_OF_MONTH)
                    currentMonth = selectedCal.get(Calendar.MONTH)
                    currentYear = selectedCal.get(Calendar.YEAR)
                }
            } catch (e: ParseException) {
                Log.w(TAG, getString(R.string.log_error_parsing_date_datepicker, dateStr), e)
                // No es necesario mostrar un Toast aquí, el diálogo usará la fecha actual
            }
        }

        val dialog = DialogCustomDatePicker.newInstance(
            initialDay = currentDay,
            initialMonth = currentMonth,
            initialYear = currentYear,
            minYear = MIN_YEAR_IMAGE, // minYear específico para imágenes
            title = getString(R.string.dialog_title_image_date) // Título específico
        )
        dialog.show(supportFragmentManager, "customDatePickerImageDialog")
    }


    override fun onDateSelected(day: Int, month: Int, year: Int) {
        val cal = Calendar.getInstance().apply { set(year, month, day, 0, 0, 0) } // Asegurar hora 00:00:00
        binding.editTextExactDate.setText(dateFormatImage.format(cal.time))
        binding.textInputLayoutExactDate.error = null // Limpiar error al seleccionar
    }

    private fun clearAllFields() {
        binding.editTextImageTitle.text?.clear()
        binding.textInputLayoutImageTitle.error = null
        binding.editTextImageDescription.text?.clear()
        binding.textInputLayoutImageDescription.error = null
        binding.spinnerLocation.setSelection(0) // Resetear spinner
        binding.radioGroupDateType.clearCheck() // Limpiar selección de tipo de fecha
        binding.radioUnknown.isChecked = false // Desmarcar "Desconocido"
        clearDateFields() // Limpiar campos de fecha individuales
        clearImageSelection() // Limpiar selección de imagen
        binding.switchCoordinates.isChecked = false // Resetear switch de coordenadas

        // Resetear estado de subida
        binding.uploadProgressOverlayImage.isVisible = false
        setUiEnabled(true)
        isSubmitting = false
        currentUploadRequestId = null
        Log.d(TAG, getString(R.string.log_all_fields_cleared))
    }

    private fun clearDateFields() {
        binding.editTextYear.text?.clear()
        binding.editTextExactDate.text?.clear()
        binding.editTextStartYear.text?.clear()
        binding.editTextEndYear.text?.clear()
        clearDateErrors() // También limpiar errores de fecha
    }

    private fun clearImageSelection() {
        imageUri = null
        binding.imageViewPreview.setImageDrawable(null) // Limpiar la imagen
        binding.imageViewPreview.isVisible = false
        binding.textViewPreviewLabel.isVisible = false
    }

    private fun showDateFormatInfoDialog() {
        AlertDialog.Builder(this)
            .setTitle(R.string.desc_info_date_format_title)
            .setMessage(R.string.desc_info_date_format_message)
            .setPositiveButton(R.string.dialog_positive_button_understood, null)
            .show()
    }

    private fun getFileSize(uri: Uri, resolver: ContentResolver): Long {
        var size = 0L
        try {
            resolver.query(uri, arrayOf(OpenableColumns.SIZE), null, null, null)?.use { cursor ->
                if (cursor.moveToFirst()) {
                    val sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE)
                    if (sizeIndex != -1) size = cursor.getLong(sizeIndex)
                }
            }
        } catch (e: SecurityException) {
            Log.e(TAG, getString(R.string.log_security_exception_get_filesize_uri, uri.toString()), e)
            showToast(getString(R.string.error_accessing_file_permission, uri.lastPathSegment ?: getString(R.string.default_file_name)))
        } catch (e: IllegalArgumentException) {
            Log.e(TAG, getString(R.string.log_illegal_argument_get_filesize_uri, uri.toString()), e)
            showToast(getString(R.string.error_invalid_file_type_specific, getString(R.string.unknown_format)))
        } catch (e: Exception) { // Captura más genérica para otros errores
            Log.e(TAG, getString(R.string.log_error_get_filesize_uri, uri.toString()), e)
            showToast(getString(R.string.upload_file_error_message, e.localizedMessage ?: getString(R.string.unknown_error)))
        }
        return size
    }

    private fun setupTextWatchers() {
        fun createWatcher(layout: TextInputLayout) = object : TextWatcher {
            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}
            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) { layout.error = null }
            override fun afterTextChanged(s: Editable?) {}
        }
        binding.editTextImageTitle.addTextChangedListener(createWatcher(binding.textInputLayoutImageTitle))
        binding.editTextImageDescription.addTextChangedListener(createWatcher(binding.textInputLayoutImageDescription))
        binding.editTextYear.addTextChangedListener(createWatcher(binding.textInputLayoutYear))
        binding.editTextExactDate.addTextChangedListener(createWatcher(binding.textInputLayoutExactDate))
        binding.editTextStartYear.addTextChangedListener(createWatcher(binding.textInputLayoutStartYear))
        binding.editTextEndYear.addTextChangedListener(createWatcher(binding.textInputLayoutEndYear))
    }

    private fun showToast(message: String) {
        Toast.makeText(this, message, Toast.LENGTH_SHORT).show()
    }

    private fun processImageSubmission() {
        if (isSubmitting) {
            Log.d(TAG, getString(R.string.log_submission_already_in_progress))
            return
        }

        if (!validateForm()) {
            Log.w(TAG, getString(R.string.log_form_not_valid))
            return
        }

        setUiEnabled(false) // Deshabilitar UI
        isSubmitting = true

        binding.uploadProgressOverlayImage.isVisible = true
        binding.progressBarUploadImage.progress = 0
        binding.textProgressImage.text = getString(R.string.uploading_image_progress_percent, 0)

        val currentUser = auth.currentUser ?: run {
            Log.e(TAG, getString(R.string.log_error_user_not_authenticated_submission))
            handleUploadError(getString(R.string.error_user_not_authenticated))
            return
        }
        val userId = currentUser.uid

        firestore.collection(getString(R.string.firestore_collection_users)).document(userId).get()
            .addOnSuccessListener { userDocument ->
                val authorUsername = userDocument.getString(getString(R.string.firestore_field_username))?.takeIf { it.isNotEmpty() } ?: currentUser.displayName ?: getString(R.string.unknown_user)
                val authorProfileImageUrl = userDocument.getString(getString(R.string.firestore_field_profileImageUrl))?.takeIf { it.isNotEmpty() } ?: currentUser.photoUrl?.toString() ?: ""

                val imageTitle = binding.editTextImageTitle.text.toString().trim()
                val imageDescription = binding.editTextImageDescription.text.toString().trim()
                val location = binding.spinnerLocation.selectedItem.toString()
                val dateData = getDateFromInputs()

                val imageData = hashMapOf<String, Any?>(
                    getString(R.string.firestore_field_userId) to userId,
                    getString(R.string.firestore_field_authorUsername) to authorUsername,
                    getString(R.string.firestore_field_authorProfileImageUrl) to authorProfileImageUrl,
                    getString(R.string.firestore_field_title) to imageTitle,
                    getString(R.string.firestore_field_description) to imageDescription,
                    getString(R.string.firestore_field_type) to getString(R.string.content_type_image), // Tipo de contenido
                    getString(R.string.firestore_field_location) to location,
                    getString(R.string.firestore_field_date) to dateData, // Mapa de datos de fecha
                    getString(R.string.firestore_field_timestamp) to FieldValue.serverTimestamp(),
                    getString(R.string.firestore_field_status) to getString(R.string.status_pending_value), // Estado inicial
                    getString(R.string.firestore_field_isVisible) to false, // No visible hasta aprobación
                    getString(R.string.firestore_field_likes) to 0,
                    getString(R.string.firestore_field_commentsCount) to 0,
                    getString(R.string.firestore_field_imageUrl) to null, // Se actualizará después de subir a Cloudinary
                    getString(R.string.firestore_field_latitude) to selectedLatitude,
                    getString(R.string.firestore_field_longitude) to selectedLongitude,
                    getString(R.string.firestore_field_cityName) to selectedCityName,
                    getString(R.string.firestore_field_moderatedBy) to null,
                    getString(R.string.firestore_field_moderationTimestamp) to null,
                    getString(R.string.firestore_field_rejectionReason) to null
                )

                if (imageUri != null) {
                    Log.i(TAG, getString(R.string.log_starting_cloudinary_upload, imageUri.toString()))
                    uploadImageToCloudinaryAndSaveData(imageUri!!, imageData)
                } else {
                    // Este caso no debería ocurrir si validateForm() funciona correctamente
                    Log.e(TAG, getString(R.string.log_error_imageuri_null_after_validation))
                    handleUploadError(getString(R.string.error_select_image_internal))
                }
            }
            .addOnFailureListener { e ->
                Log.e(TAG, getString(R.string.log_error_getting_user_data_for_authorship), e)
                handleUploadError(getString(R.string.submission_generic_error_message_upload) + getString(R.string.error_suffix_user_data_fetch))
            }
    }

    private fun validateForm(): Boolean {
        var isValid = true
        val imageTitle = binding.editTextImageTitle.text.toString().trim()
        if (imageTitle.isBlank()) {
            binding.textInputLayoutImageTitle.error = getString(R.string.error_image_title_required)
            isValid = false
        } else if (imageTitle.length > 37) {
            binding.textInputLayoutImageTitle.error = getString(R.string.error_title_length)
            isValid = false
        } else {
            binding.textInputLayoutImageTitle.error = null
        }

        val imageDescription = binding.editTextImageDescription.text.toString().trim()
        if (imageDescription.isBlank()) {
            binding.textInputLayoutImageDescription.error = getString(R.string.error_image_description_required)
            isValid = false
        } else if (imageDescription.length > 666) { // Asumiendo que 666 es el límite
            binding.textInputLayoutImageDescription.error = getString(R.string.error_description_length, 666)
            isValid = false
        } else {
            binding.textInputLayoutImageDescription.error = null
        }

        if (binding.spinnerLocation.selectedItemPosition == 0) { // "Seleccione una ubicación"
            showToast(getString(R.string.error_location_required))
            isValid = false
        }

        if (imageUri == null) {
            showToast(getString(R.string.error_select_image))
            isValid = false
        }

        if (!validateDateSelection()) isValid = false

        if (binding.switchCoordinates.isChecked && (selectedLatitude == null || selectedLongitude == null)) {
            showToast(getString(R.string.error_select_coordinates_on_map))
            isValid = false
        }

        return isValid
    }

    private fun validateDateSelection(): Boolean {
        var dateValid = true
        clearDateErrors() // Limpiar errores previos
        val checkedId = binding.radioGroupDateType.checkedRadioButtonId

        // Si no se ha seleccionado ningún tipo de fecha Y "Desconocido" no está marcado
        if (checkedId == -1 && !binding.radioUnknown.isChecked) {
            binding.textDateMessageImage.text = getString(R.string.error_select_date_type_or_unknown)
            binding.textDateMessageImage.isVisible = true
            return false // No es válido si no se selecciona nada
        }
        // Si "Desconocido" está marcado, es válido
        if (binding.radioUnknown.isChecked) return true

        // Validaciones para los tipos de fecha específicos
        val currentYear = Calendar.getInstance().get(Calendar.YEAR)
        val minDateCalImage = Calendar.getInstance().apply { set(MIN_YEAR_IMAGE, Calendar.JANUARY, 1,0,0,0) } // Para comparación

        when (checkedId) {
            R.id.radioYear -> {
                val yearStr = binding.editTextYear.text.toString()
                val year = yearStr.toIntOrNull()
                if (yearStr.isEmpty() || year == null || year < MIN_YEAR_IMAGE || year > currentYear) {
                    binding.textInputLayoutYear.error = getString(R.string.error_invalid_year_range_simple, MIN_YEAR_IMAGE, currentYear)
                    dateValid = false
                }
            }
            R.id.radioExactDate -> {
                val dateStr = binding.editTextExactDate.text.toString()
                if (dateStr.isEmpty()) {
                    binding.textInputLayoutExactDate.error = getString(R.string.error_select_exact_date)
                    dateValid = false
                } else {
                    try {
                        val date = dateFormatImage.parse(dateStr) // dateFormatImage ya es lenient = false
                        val selectedCal = Calendar.getInstance().apply { time = date!! }
                        // Normalizar horas, minutos, segundos para comparación justa de fechas
                        selectedCal.set(Calendar.HOUR_OF_DAY, 0); selectedCal.set(Calendar.MINUTE, 0); selectedCal.set(Calendar.SECOND, 0); selectedCal.set(Calendar.MILLISECOND, 0)
                        val todayCal = Calendar.getInstance().apply {set(Calendar.HOUR_OF_DAY, 0); set(Calendar.MINUTE, 0); set(Calendar.SECOND, 0); set(Calendar.MILLISECOND, 0) }

                        if (selectedCal.before(minDateCalImage) || selectedCal.after(todayCal)) {
                            binding.textInputLayoutExactDate.error = getString(R.string.error_invalid_date_range, dateFormatImage.format(minDateCalImage.time), dateFormatImage.format(todayCal.time))
                            dateValid = false
                        }
                    } catch (e: ParseException) {
                        binding.textInputLayoutExactDate.error = getString(R.string.error_invalid_date_format)
                        dateValid = false
                    }
                }
            }
            R.id.radioDateRange -> {
                val startYearStr = binding.editTextStartYear.text.toString()
                val endYearStr = binding.editTextEndYear.text.toString()
                val startYear = startYearStr.toIntOrNull()
                val endYear = endYearStr.toIntOrNull()

                var individualYearsValid = true
                if (startYearStr.isEmpty() || startYear == null || startYear < MIN_YEAR_IMAGE || startYear > currentYear) {
                    binding.textInputLayoutStartYear.error = getString(R.string.error_invalid_year_range_simple, MIN_YEAR_IMAGE, currentYear)
                    individualYearsValid = false
                }
                if (endYearStr.isEmpty() || endYear == null || endYear < MIN_YEAR_IMAGE || endYear > currentYear) {
                    binding.textInputLayoutEndYear.error = getString(R.string.error_invalid_year_range_simple, MIN_YEAR_IMAGE, currentYear)
                    individualYearsValid = false
                }

                if (individualYearsValid && startYear != null && endYear != null && startYear > endYear) {
                    binding.textInputLayoutStartYear.error = getString(R.string.error_year_range_order)
                    binding.textInputLayoutEndYear.error = getString(R.string.error_year_range_order) // Mostrar error en ambos
                    dateValid = false
                } else if (!individualYearsValid) { // Si alguno de los años individuales no es válido
                    dateValid = false
                }
            }
        }
        if (!dateValid) { // Si alguna validación falló, mostrar mensaje general
            binding.textDateMessageImage.text = getString(R.string.error_correct_date_errors)
            binding.textDateMessageImage.isVisible = true
        }
        return dateValid
    }


    private fun getDateFromInputs(): Map<String, Any?> {
        val dateMap = mutableMapOf<String, Any?>()
        if (binding.radioUnknown.isChecked) {
            dateMap[getString(R.string.firestore_field_date_type)] = getString(R.string.date_type_value_unknown)
            dateMap[getString(R.string.firestore_field_date_value)] = getString(R.string.date_type_unknown) // O un valor específico para "Desconocido"
        } else {
            when (binding.radioGroupDateType.checkedRadioButtonId) {
                R.id.radioYear -> {
                    dateMap[getString(R.string.firestore_field_date_type)] = getString(R.string.date_type_value_year)
                    dateMap[getString(R.string.firestore_field_date_value)] = binding.editTextYear.text.toString().toIntOrNull()
                }
                R.id.radioExactDate -> {
                    dateMap[getString(R.string.firestore_field_date_type)] = getString(R.string.date_type_value_exact)
                    dateMap[getString(R.string.firestore_field_date_value)] = binding.editTextExactDate.text.toString() // Guardar como String dd/MM/yyyy
                }
                R.id.radioDateRange -> {
                    dateMap[getString(R.string.firestore_field_date_type)] = getString(R.string.date_type_value_range)
                    dateMap[getString(R.string.firestore_field_date_startYear)] = binding.editTextStartYear.text.toString().toIntOrNull()
                    dateMap[getString(R.string.firestore_field_date_endYear)] = binding.editTextEndYear.text.toString().toIntOrNull()
                }
                else -> {
                    // Caso por si no se selecciona nada (aunque la validación debería prevenir esto)
                    dateMap[getString(R.string.firestore_field_date_type)] = getString(R.string.date_type_value_none)
                }
            }
        }
        return dateMap
    }


    private fun uploadImageToCloudinaryAndSaveData(imageUriToUpload: Uri, imageData: HashMap<String, Any?>) {
        val imageBytes = compressImageToWebP(imageUriToUpload, 70, 1280) // Calidad 70, lado máx 1280px
        if (imageBytes == null) {
            Log.e(TAG, getString(R.string.log_error_compressing_image_uri, imageUriToUpload.toString()))
            handleUploadError(getString(R.string.error_image_compression_failed))
            return
        }

        val options = HashMap<String, Any>().apply {
            put(getString(R.string.cloudinary_option_folder), getString(R.string.cloudinary_folder_image_uploads, imageData[getString(R.string.firestore_field_userId)])) // Organizar por ID de usuario
            put(getString(R.string.cloudinary_option_public_id), getString(R.string.cloudinary_public_id_image_prefix) + System.currentTimeMillis() + "_" + UUID.randomUUID()) // Nombre único
            put(getString(R.string.cloudinary_option_resource_type), getString(R.string.cloudinary_resource_type_image))
            // Podrías añadir transformaciones aquí si es necesario, ej: put("transformation", "w_1280,h_1280,c_limit")
        }

        currentUploadRequestId = MediaManager.get().upload(imageBytes)
            .options(options)
            .callback(object : UploadCallback {
                override fun onStart(requestId: String?) {
                    Log.i(TAG, getString(R.string.log_cloudinary_upload_started, requestId))
                    // UI ya está mostrando el progreso
                }

                override fun onProgress(requestId: String?, bytes: Long, totalBytes: Long) {
                    val progress = (bytes.toDouble() / totalBytes * 100).toInt()
                    runOnUiThread {
                        binding.progressBarUploadImage.progress = progress
                        binding.textProgressImage.text = getString(R.string.uploading_image_progress_percent, progress)
                    }
                }

                override fun onSuccess(requestId: String?, resultData: MutableMap<Any?, Any?>?) {
                    currentUploadRequestId = null
                    val url = resultData?.get(getString(R.string.cloudinary_result_secure_url)) as? String
                    if (url != null) {
                        Log.i(TAG, getString(R.string.log_cloudinary_upload_success, url))
                        imageData[getString(R.string.firestore_field_imageUrl)] = url
                        runOnUiThread { binding.textProgressImage.text = getString(R.string.uploading_content_progress) } // Mensaje "Guardando datos..."
                        saveImageDataToFirestore(imageData)
                    } else {
                        Log.e(TAG, getString(R.string.log_error_cloudinary_url_null))
                        handleUploadError(getString(R.string.submission_generic_error_message_upload) + getString(R.string.error_suffix_cloudinary_url_null))
                    }
                }

                override fun onError(requestId: String?, error: ErrorInfo?) {
                    currentUploadRequestId = null
                    val errorMessage = error?.description ?: getString(R.string.error_unknown_upload)
                    Log.e(TAG, getString(R.string.log_error_cloudinary_upload, requestId, errorMessage, error?.code.toString()))
                    if (error?.code == ErrorInfo.REQUEST_CANCELLED) {
                        handleUploadError(getString(R.string.upload_cancelled))
                    } else {
                        handleUploadError(getString(R.string.upload_error_prefix, errorMessage))
                    }
                }

                override fun onReschedule(requestId: String?, error: ErrorInfo?) {
                    currentUploadRequestId = null
                    Log.w(TAG, getString(R.string.log_cloudinary_upload_rescheduled, requestId, error?.description, error?.code.toString()))
                    handleUploadError(getString(R.string.error_unknown_upload) + getString(R.string.error_suffix_upload_rescheduled, error?.description))
                }
            })
            .dispatch()
    }

    private fun saveImageDataToFirestore(imageData: HashMap<String, Any?>) {
        firestore.collection(getString(R.string.firestore_collection_images_pending)).add(imageData)
            .addOnSuccessListener { documentReference ->
                Log.i(TAG, getString(R.string.log_firestore_image_data_saved, documentReference.id))
                runOnUiThread {
                    binding.uploadProgressOverlayImage.isVisible = false
                    showSubmissionConfirmationDialog(getString(R.string.submission_success_title_upload), getString(R.string.submission_success_message_upload))
                }
            }
            .addOnFailureListener { e ->
                Log.e(TAG, getString(R.string.log_error_firestore_saving_image_data), e)
                runOnUiThread { // Asegurar que se ejecuta en el hilo UI
                    binding.uploadProgressOverlayImage.isVisible = false // Ocultar progreso
                    handleUploadError(getString(R.string.submission_generic_error_message_upload) + getString(R.string.error_suffix_firestore_save, e.localizedMessage))
                }
            }
    }


    private fun handleUploadError(errorMessage: String) {
        Log.e(TAG, getString(R.string.log_handling_upload_error, errorMessage))
        currentUploadRequestId = null // Limpiar ID de solicitud
        runOnUiThread {
            binding.uploadProgressOverlayImage.isVisible = false
            showAlertDialog(getString(R.string.error_dialog_title), getString(R.string.upload_error_prefix, errorMessage))
            setUiEnabled(true) // Reactivar UI
            isSubmitting = false
        }
    }

    private fun showSubmissionConfirmationDialog(title: String, message: String) {
        if (isFinishing || isDestroyed) { // Evitar mostrar diálogo si la actividad está finalizando
            Log.w(TAG, getString(R.string.log_activity_finishing_dialog_not_shown))
            return
        }
        AlertDialog.Builder(this)
            .setTitle(title)
            .setMessage(message)
            .setPositiveButton(R.string.dialog_positive_button_understood) { _, _ ->
                finish() // Cerrar actividad después de confirmación
            }
            .setCancelable(false) // No permitir cancelar el diálogo con back button
            .show()
    }


    private fun setUiEnabled(enabled: Boolean) {
        binding.btnEnviarImagen.isEnabled = enabled
        binding.btnBorrarTodoImagen.isEnabled = enabled

        // Habilitar/deshabilitar todos los campos del formulario
        val formElementsEnabled = enabled // Usar 'enabled' directamente para claridad
        binding.editTextImageTitle.isEnabled = formElementsEnabled
        binding.editTextImageDescription.isEnabled = formElementsEnabled
        binding.btnSelectFile.isEnabled = formElementsEnabled
        binding.spinnerLocation.isEnabled = formElementsEnabled

        // Habilitar/deshabilitar RadioGroup y sus hijos
        binding.radioGroupDateType.isEnabled = formElementsEnabled
        for (i in 0 until binding.radioGroupDateType.childCount) {
            binding.radioGroupDateType.getChildAt(i).isEnabled = formElementsEnabled
        }
        binding.radioUnknown.isEnabled = formElementsEnabled

        // Habilitar campos de fecha solo si son visibles y 'enabled' es true
        binding.editTextYear.isEnabled = formElementsEnabled && binding.textInputLayoutYear.isVisible
        binding.editTextExactDate.isEnabled = formElementsEnabled && binding.textInputLayoutExactDate.isVisible
        binding.editTextStartYear.isEnabled = formElementsEnabled && binding.dateRangeLayout.isVisible
        binding.editTextEndYear.isEnabled = formElementsEnabled && binding.dateRangeLayout.isVisible
        binding.infoIconDate.isEnabled = formElementsEnabled // Icono de información de fecha

        // Habilitar/deshabilitar sección de coordenadas
        binding.switchCoordinates.isEnabled = formElementsEnabled
        binding.textViewSelectCoordinates.isEnabled = formElementsEnabled && binding.mapSelectionContainer.isVisible && binding.textViewSelectCoordinates.isVisible
        binding.btnEditCoordinates.isEnabled = formElementsEnabled && binding.mapSelectionContainer.isVisible && binding.btnEditCoordinates.isVisible
    }

    private fun resizeBitmapKeepingAspectRatio(bitmap: Bitmap, maxSideLength: Int): Bitmap {
        val currentWidth = bitmap.width
        val currentHeight = bitmap.height

        if (currentWidth <= maxSideLength && currentHeight <= maxSideLength) {
            return bitmap // No necesita redimensionamiento
        }

        val ratio = currentWidth.toFloat() / currentHeight.toFloat()
        var newWidth: Int
        var newHeight: Int

        if (currentWidth > currentHeight) {
            newWidth = maxSideLength
            newHeight = (maxSideLength / ratio).roundToInt()
        } else {
            newHeight = maxSideLength
            newWidth = (maxSideLength * ratio).roundToInt()
        }
        // Asegurar que las nuevas dimensiones no sean cero
        if (newWidth <= 0) newWidth = 1
        if (newHeight <= 0) newHeight = 1

        return Bitmap.createScaledBitmap(bitmap, newWidth, newHeight, true)
    }

    private fun compressImageToWebP(uri: Uri, quality: Int, maxSideLength: Int): ByteArray? {
        var inputStream: InputStream? = null
        var exifInputStream: InputStream? = null
        try {
            inputStream = contentResolver.openInputStream(uri) ?: throw FileNotFoundException(getString(R.string.error_inputstream_null_for_uri, uri.toString()))
            val originalBitmap = BitmapFactory.decodeStream(inputStream)
                ?: throw IOException(getString(R.string.error_failed_decode_bitmap_from_uri, uri.toString()))

            exifInputStream = contentResolver.openInputStream(uri) ?: throw FileNotFoundException(getString(R.string.error_exif_inputstream_null_for_uri, uri.toString()))
            val exif = ExifInterface(exifInputStream)
            val orientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL)

            val matrix = Matrix()
            when (orientation) {
                ExifInterface.ORIENTATION_ROTATE_90 -> matrix.postRotate(90f)
                ExifInterface.ORIENTATION_ROTATE_180 -> matrix.postRotate(180f)
                ExifInterface.ORIENTATION_ROTATE_270 -> matrix.postRotate(270f)
                ExifInterface.ORIENTATION_FLIP_HORIZONTAL -> matrix.postScale(-1f, 1f)
                ExifInterface.ORIENTATION_FLIP_VERTICAL -> matrix.postScale(1f, -1f)
                ExifInterface.ORIENTATION_TRANSPOSE -> { matrix.postRotate(90f); matrix.postScale(-1f, 1f) }
                ExifInterface.ORIENTATION_TRANSVERSE -> { matrix.postRotate(-90f); matrix.postScale(-1f, 1f) }
            }
            val rotatedBitmap = Bitmap.createBitmap(originalBitmap, 0, 0, originalBitmap.width, originalBitmap.height, matrix, true)
            if (originalBitmap != rotatedBitmap) {
                originalBitmap.recycle()
            }

            val resizedBitmap = resizeBitmapKeepingAspectRatio(rotatedBitmap, maxSideLength)
            if (rotatedBitmap != resizedBitmap) {
                rotatedBitmap.recycle()
            }

            ByteArrayOutputStream().use { outputStream ->
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
                    resizedBitmap.compress(Bitmap.CompressFormat.WEBP_LOSSY, quality, outputStream)
                } else {
                    @Suppress("DEPRECATION")
                    resizedBitmap.compress(Bitmap.CompressFormat.WEBP, quality, outputStream)
                }
                resizedBitmap.recycle()
                return outputStream.toByteArray()
            }
        } catch (fnfe: FileNotFoundException) {
            Log.e(TAG, getString(R.string.log_error_file_not_found_compress_webp, uri.toString()), fnfe)
            showToast(getString(R.string.error_file_not_found_for_compression, uri.lastPathSegment ?: getString(R.string.selected_image_default_name)))
            return null
        } catch (ioe: IOException) {
            Log.e(TAG, getString(R.string.log_error_io_compress_webp, uri.toString()), ioe)
            showToast(getString(R.string.error_io_compressing_image))
            return null
        } catch (e: Exception) {
            Log.e(TAG, getString(R.string.log_error_unexpected_compress_webp, uri.toString()), e)
            showToast(getString(R.string.error_unknown_compressing_image))
            return null
        } finally {
            try {
                inputStream?.close()
                exifInputStream?.close()
            } catch (ioe: IOException) {
                Log.e(TAG, getString(R.string.log_error_closing_streams_compress_webp_uri, uri.toString()), ioe)
            }
        }
    }

    private fun showAlertDialog(title: String, message: String) {
        if (isFinishing || isDestroyed) { // Evitar mostrar diálogo si la actividad está finalizando
            Log.w(TAG, getString(R.string.log_activity_finishing_dialog_not_shown_alert))
            return
        }
        AlertDialog.Builder(this)
            .setTitle(title)
            .setMessage(message)
            .setPositiveButton(getString(R.string.dialog_ok), null) // Usar string resource para OK
            .show()
    }
}


===== Archivo: app\src\main\java\com\example\mexicoparanormal\UploadsFragment.kt =====


package com.example.mexicoparanormal

import android.content.Intent
import android.os.Bundle
import androidx.fragment.app.Fragment
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Toast // Mantener si quieres usar Toast para depuración
import com.example.mexicoparanormal.databinding.FragmentUploadsBinding // Asegúrate de tener View Binding habilitado

// Este fragmento muestra el contenido de la pestaña "Subidas"
class UploadsFragment : Fragment() {

    private var _binding: FragmentUploadsBinding? = null
    // Esta propiedad solo es válida entre onCreateView y onDestroyView.
    private val binding get() = _binding!!

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        // Inflar el layout para este fragmento usando View Binding
        _binding = FragmentUploadsBinding.inflate(inflater, container, false)
        val root: View = binding.root

        // --- Añade aquí los listeners para las opciones de subir y los estados de envío ---

        // Listener para "Subir Relato"
        binding.optionUploadRelato.setOnClickListener {
            // Lógica para iniciar la subida de un relato (navegar a otra actividad/fragmento, mostrar diálogo, etc.)
            val intent = Intent(activity, UploadStoryActivity::class.java)
            startActivity(intent)
            // Toast.makeText(requireContext(), getString(R.string.toast_upload_story_tapped), Toast.LENGTH_SHORT).show() // Opcional para depuración
        }

        // Listener para "Subir Foto"
        binding.optionUploadFoto.setOnClickListener {
            // Lógica para iniciar la subida de una foto
            val intent = Intent(activity, UploadImageActivity::class.java)
            startActivity(intent)
            // Toast.makeText(requireContext(), getString(R.string.toast_upload_photo_tapped), Toast.LENGTH_SHORT).show() // Opcional para depuración
        }

        // Listener para "Subir Video"
        binding.optionUploadVideo.setOnClickListener {
            val intent = Intent(activity, UploadVideoActivity::class.java)
            startActivity(intent)
            // Toast.makeText(requireContext(), getString(R.string.toast_upload_video_tapped), Toast.LENGTH_SHORT).show() // Opcional para depuración
        }

        // Listener para la sección "Pendientes"
        binding.statusPending.setOnClickListener {
            val intent = Intent(activity, PendingUploadsActivity::class.java)
            startActivity(intent)
            // Toast.makeText(requireContext(), getString(R.string.toast_pending_section_tapped), Toast.LENGTH_SHORT).show() // Opcional para depuración
        }

        // Listeners para los estados de envío (Aprobados, Rechazados - pendiente de implementación)
        binding.statusApproved.setOnClickListener {
            // TODO: Lógica para ver los envíos aprobados (navegar a una nueva Activity/Fragment)
            Toast.makeText(requireContext(), getString(R.string.toast_approved_tapped_placeholder), Toast.LENGTH_SHORT).show()
        }
        binding.statusRejected.setOnClickListener {
            // TODO: Lógica para ver los envíos rechazados (navegar a una nueva Activity/Fragment)
            Toast.makeText(requireContext(), getString(R.string.toast_rejected_tapped_placeholder), Toast.LENGTH_SHORT).show()
        }
        // ------------------------------------------------------------------------------

        return root
    }

    // Es importante limpiar la referencia del binding para evitar fugas de memoria en Fragmentos
    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }
}


===== Archivo: app\src\main\java\com\example\mexicoparanormal\UploadStoryActivity.kt =====


package com.example.mexicoparanormal

import android.Manifest // No se usa directamente, pero puede ser necesario para permisos de audio/imagen
import android.app.Activity
import android.app.AlertDialog
import android.content.ContentResolver
// Eliminada importación no utilizada de android.content.pm.PackageManager
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.graphics.Matrix
import androidx.exifinterface.media.ExifInterface
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.provider.OpenableColumns
import android.text.Editable
import android.text.TextWatcher
import android.util.Log
import android.view.View
import android.widget.AdapterView
import android.widget.ArrayAdapter
import android.widget.Toast
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AppCompatActivity
// Eliminada importación no utilizada de androidx.core.content.ContextCompat
import androidx.core.net.toUri
import androidx.core.view.isVisible
import androidx.fragment.app.Fragment
import com.cloudinary.android.MediaManager
import com.cloudinary.android.callback.ErrorInfo
import com.cloudinary.android.callback.UploadCallback
import com.example.mexicoparanormal.databinding.ActivityUploadStoryBinding
import com.google.android.material.tabs.TabLayoutMediator
import com.google.android.material.textfield.TextInputLayout
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.firestore.FieldValue
import com.google.firebase.firestore.FirebaseFirestore
import java.io.ByteArrayOutputStream
import java.io.File // Necesario para manejo de archivos de audio
import java.io.InputStream
import java.io.FileNotFoundException
// Eliminada importación no utilizada de java.io.FileOutputStream
import java.io.IOException
import java.text.ParseException
import java.text.SimpleDateFormat
import java.util.Calendar
import java.util.Locale
import java.util.UUID
import android.content.Intent
// import kotlin.math.max // No se usa directamente
import kotlin.math.roundToInt
import androidx.core.graphics.scale

class UploadStoryActivity : AppCompatActivity(),
    DialogCustomDatePicker.OnDateSelectedListener,
    RecordAudioFragment.AudioRecordListener,
    AttachAudioFragment.AudioAttachListener {

    private lateinit var binding: ActivityUploadStoryBinding
    private lateinit var auth: FirebaseAuth
    private lateinit var firestore: FirebaseFirestore
    private lateinit var storyInputPagerAdapter: StoryInputPagerAdapter

    private var selectedLatitude: Double? = null
    private var selectedLongitude: Double? = null
    private var selectedCityName: String? = null

    private lateinit var mapsActivityResultLauncher: ActivityResultLauncher<Intent>

    private var selectedImageUri: Uri? = null // Para imagen opcional del relato
    private var recordedAudioUri: Uri? = null
    private var recordedAudioOriginalName: String? = null
    private var attachedAudioUri: Uri? = null
    private var attachedAudioOriginalName: String? = null
    private var finalAudioToUploadUri: Uri? = null // El URI que finalmente se subirá (grabado o adjunto)
    private var finalAudioOriginalName: String? = null // Nombre original del audio final

    private val MIN_YEAR_STORY = 1582 // Año mínimo para relatos
    private val dateFormatStory = SimpleDateFormat("dd/MM/yyyy", Locale.getDefault())

    private var isSubmitting = false
    private var currentStoryImageUploadRequestId: String? = null // ID para subida de imagen del relato
    private var currentAudioFileUploadRequestId: String? = null // ID para subida de audio

    companion object {
        private const val TAG = "UploadStoryActivity"
        private const val MAX_IMAGE_FILE_SIZE_MB = 10 // Para imagen opcional
        // El tamaño máximo del archivo de audio se maneja en los fragmentos de audio
    }

    private val selectImageLauncher = registerForActivityResult(ActivityResultContracts.GetContent()) { uri: Uri? ->
        uri?.let {
            try {
                val contentResolver: ContentResolver = applicationContext.contentResolver
                val type = contentResolver.getType(it)
                val allowedMimeTypes = listOf("image/jpeg", "image/png", "image/jfif", "image/webp")

                if (type != null && allowedMimeTypes.contains(type.lowercase(Locale.getDefault()))) {
                    val fileSize = getFileSize(contentResolver, it) // Pasar contentResolver
                    val maxFileSizeInBytes = MAX_IMAGE_FILE_SIZE_MB * 1024 * 1024
                    if (fileSize > maxFileSizeInBytes) {
                        showToast(getString(R.string.error_audio_file_too_large_detailed, MAX_IMAGE_FILE_SIZE_MB, fileSize / (1024*1024)))
                        clearOptionalImageSelection()
                        return@registerForActivityResult
                    }
                    selectedImageUri = it
                    binding.imageViewPreviewStory.setImageURI(it)
                    binding.imageViewPreviewStory.isVisible = true
                    binding.textViewPreviewLabelStory.isVisible = true
                    Log.i(TAG, getString(R.string.log_optional_image_selected, it.toString()))
                    showToast(getString(R.string.image_selection_successful))
                } else {
                    val allowedFormats = allowedMimeTypes.joinToString(", ") { mime -> mime.substringAfter("/") }
                    Log.w(TAG, getString(R.string.log_invalid_file_type_optional_image, it.toString(), type))
                    showToast(getString(R.string.error_invalid_file_type_specific, allowedFormats))
                    clearOptionalImageSelection()
                }
            } catch (e: SecurityException) {
                Log.e(TAG, getString(R.string.log_security_exception_validating_optional_image, it.toString()), e)
                showToast(getString(R.string.error_accessing_file_permission, it.lastPathSegment ?: getString(R.string.selected_image_default_name)))
                clearOptionalImageSelection()
            } catch (e: IllegalArgumentException) {
                Log.e(TAG, getString(R.string.log_illegal_argument_validating_optional_image, it.toString()), e)
                showToast(getString(R.string.error_invalid_file_type_specific, getString(R.string.unknown_format)))
                clearOptionalImageSelection()
            } catch (e: Exception) {
                Log.e(TAG, getString(R.string.log_unexpected_error_validating_optional_image, it.toString()), e)
                showToast(getString(R.string.upload_file_error_message, e.localizedMessage ?: getString(R.string.unknown_error)))
                clearOptionalImageSelection()
            }
        } ?: run { // Si el URI es nulo (selección cancelada)
            clearOptionalImageSelection()
            Log.d(TAG, getString(R.string.log_optional_image_selection_cancelled))
            showToast(getString(R.string.image_selection_cancelled))
        }
    }


    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityUploadStoryBinding.inflate(layoutInflater)
        setContentView(binding.root)

        auth = FirebaseAuth.getInstance()
        firestore = FirebaseFirestore.getInstance()
        dateFormatStory.isLenient = false // Para validación estricta de fechas

        if (auth.currentUser == null) {
            Log.w(TAG, getString(R.string.log_user_not_authenticated_oncreate_story))
            Toast.makeText(this, getString(R.string.error_user_not_authenticated), Toast.LENGTH_LONG).show()
            finish()
            return
        }

        mapsActivityResultLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result ->
            if (result.resultCode == Activity.RESULT_OK) {
                result.data?.let { data ->
                    selectedLatitude = data.getDoubleExtra(getString(R.string.intent_extra_latitude_result), 0.0).takeIf { lat -> lat != 0.0 }
                    selectedLongitude = data.getDoubleExtra(getString(R.string.intent_extra_longitude_result), 0.0).takeIf { lon -> lon != 0.0 }
                    selectedCityName = data.getStringExtra(getString(R.string.intent_extra_cityname_result))
                    Log.i(TAG, getString(R.string.log_coordinates_received_story, selectedLatitude.toString(), selectedLongitude.toString(), selectedCityName))
                    actualizarUIcoordenadas()
                }
            } else {
                Log.d(TAG, getString(R.string.log_map_selection_cancelled_story))
            }
        }

        if (savedInstanceState != null) {
            selectedLatitude = savedInstanceState.getDouble("selectedLatitude", 0.0).takeIf { it != 0.0 }
            selectedLongitude = savedInstanceState.getDouble("selectedLongitude", 0.0).takeIf { it != 0.0 }
            selectedCityName = savedInstanceState.getString("selectedCityName")
            selectedImageUri = savedInstanceState.getString("selectedImageUriKey")?.toUri()
            recordedAudioUri = savedInstanceState.getString("recordedAudioUriKey")?.toUri()
            recordedAudioOriginalName = savedInstanceState.getString("recordedAudioOriginalNameKey")
            attachedAudioUri = savedInstanceState.getString("attachedAudioUriKey")?.toUri()
            attachedAudioOriginalName = savedInstanceState.getString("attachedAudioOriginalNameKey")
            finalAudioToUploadUri = savedInstanceState.getString("finalAudioToUploadUriKey")?.toUri()
            finalAudioOriginalName = savedInstanceState.getString("finalAudioOriginalNameKey")

            if (selectedImageUri != null) {
                binding.imageViewPreviewStory.setImageURI(selectedImageUri)
                binding.imageViewPreviewStory.isVisible = true
                binding.textViewPreviewLabelStory.isVisible = true
            }
            Log.d(TAG, getString(R.string.log_state_restored_upload_story, selectedImageUri.toString(), recordedAudioUri.toString(), attachedAudioUri.toString(), selectedLatitude.toString()))
        }

        setupUI()
        checkCloudinaryInitialization()
        updateAudioWarningVisibility() // Llamar después de restaurar estado
    }

    private fun setupUI() {
        storyInputPagerAdapter = StoryInputPagerAdapter(this)
        binding.viewPagerStoryInput.adapter = storyInputPagerAdapter

        TabLayoutMediator(binding.tabLayoutStoryInput, binding.viewPagerStoryInput) { tab, position ->
            tab.text = when (position) {
                0 -> getString(R.string.tab_title_write)
                1 -> getString(R.string.tab_title_record_audio)
                2 -> getString(R.string.tab_title_attach_audio)
                else -> null
            }
        }.attach()

        setupTextWatchers()
        binding.btnBack.setOnClickListener { onBackPressedDispatcher.onBackPressed() }
        setupSpinners()
        setupDateSelection()
        setupCoordinatesSection()
        setupUploadCancelButton()

        binding.infoIconDate.setOnClickListener { if (it.isEnabled) showDateFormatInfoDialog() }
        binding.btnSelectImageStory.setOnClickListener { if (it.isEnabled) selectImageLauncher.launch("image/*") }
        binding.btnBorrarTodo.setOnClickListener { clearAllFields() }
        binding.btnEnviarRelato.setOnClickListener { processStorySubmission() }

        // Visibilidad inicial de campos
        binding.textInputLayoutOtherStoryType.isVisible = false
        binding.textInputLayoutYear.isVisible = false
        binding.textInputLayoutExactDate.isVisible = false
        binding.dateRangeLayout.isVisible = false
        binding.dateInputFieldsContainer.isVisible = false
        binding.imageViewPreviewStory.isVisible = selectedImageUri != null // Basado en si hay URI guardada
        binding.textViewPreviewLabelStory.isVisible = selectedImageUri != null
        binding.uploadProgressOverlayStory.isVisible = false
        binding.mapSelectionContainer.isVisible = binding.switchCoordinates.isChecked
        actualizarUIcoordenadas()
    }

    private fun checkCloudinaryInitialization() {
        try {
            if (MediaManager.get().cloudinary == null) {
                Log.e(TAG, getString(R.string.log_error_cloudinary_not_configured_story))
                Toast.makeText(this, getString(R.string.cloudinary_config_error), Toast.LENGTH_LONG).show()
                binding.btnEnviarRelato.isEnabled = false
            }
        } catch (e: IllegalStateException) {
            Log.e(TAG, getString(R.string.log_error_cloudinary_not_initialized_story), e)
            Toast.makeText(this, getString(R.string.cloudinary_init_error), Toast.LENGTH_LONG).show()
            binding.btnEnviarRelato.isEnabled = false
        } catch (e: Exception) {
            Log.e(TAG, getString(R.string.log_error_cloudinary_unknown_check_story), e)
            Toast.makeText(this, getString(R.string.cloudinary_check_error), Toast.LENGTH_LONG).show()
            binding.btnEnviarRelato.isEnabled = false
        }
    }

    private fun setupUploadCancelButton() {
        binding.btnCancelUploadStory.setOnClickListener {
            currentStoryImageUploadRequestId?.let {
                try { MediaManager.get().cancelRequest(it)
                    Log.i(TAG, getString(R.string.log_story_image_upload_cancellation_sent, it))
                }
                catch (e: Exception) { Log.e(TAG, getString(R.string.log_error_cancelling_story_image_upload, it), e)}
            }
            currentAudioFileUploadRequestId?.let {
                try { MediaManager.get().cancelRequest(it)
                    Log.i(TAG, getString(R.string.log_story_audio_upload_cancellation_sent, it))
                }
                catch (e: Exception) { Log.e(TAG, getString(R.string.log_error_cancelling_story_audio_upload, it), e)}
            }
            Log.i(TAG, getString(R.string.log_general_upload_cancellation_sent))
            handleUploadError(getString(R.string.upload_cancelled)) // Mensaje genérico de cancelación
        }
    }


    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        selectedLatitude?.let { outState.putDouble("selectedLatitude", it) }
        selectedLongitude?.let { outState.putDouble("selectedLongitude", it) }
        outState.putString("selectedCityName", selectedCityName)
        selectedImageUri?.let { outState.putString("selectedImageUriKey", it.toString()) }
        recordedAudioUri?.let { outState.putString("recordedAudioUriKey", it.toString()) }
        recordedAudioOriginalName?.let { outState.putString("recordedAudioOriginalNameKey", it) }
        attachedAudioUri?.let { outState.putString("attachedAudioUriKey", it.toString()) }
        attachedAudioOriginalName?.let { outState.putString("attachedAudioOriginalNameKey", it) }
        finalAudioToUploadUri?.let { outState.putString("finalAudioToUploadUriKey", it.toString())} // Guardar audio final
        finalAudioOriginalName?.let { outState.putString("finalAudioOriginalNameKey", it) } // Guardar nombre de audio final
    }

    private fun setupSpinners() {
        val storyTypes = resources.getStringArray(R.array.story_types_array)
        val storyTypeAdapter = ArrayAdapter(this, R.layout.spinner_item, storyTypes)
        storyTypeAdapter.setDropDownViewResource(R.layout.spinner_dropdown_item)
        binding.spinnerStoryType.adapter = storyTypeAdapter
        binding.spinnerStoryType.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
            override fun onItemSelected(parent: AdapterView<*>?, view: View?, position: Int, id: Long) {
                val selectedType = parent?.getItemAtPosition(position).toString()
                binding.textInputLayoutOtherStoryType.isVisible = selectedType == getString(R.string.story_type_other)
                if (selectedType != getString(R.string.story_type_other)) {
                    binding.editTextOtherStoryType.text?.clear()
                    binding.textInputLayoutOtherStoryType.error = null // Limpiar error si se cambia de "Otro"
                }
            }
            override fun onNothingSelected(parent: AdapterView<*>?) { /* No se necesita acción */ }
        }

        val locations = resources.getStringArray(R.array.locations_array)
        val locationAdapter = ArrayAdapter(this, R.layout.spinner_item, locations)
        locationAdapter.setDropDownViewResource(R.layout.spinner_dropdown_item)
        binding.spinnerLocation.adapter = locationAdapter
        binding.spinnerLocation.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
            override fun onItemSelected(parent: AdapterView<*>?, view: View?, position: Int, id: Long) {
                if (position <= 1) { // "Seleccione una ubicación" o "desconocido"
                    if (binding.switchCoordinates.isChecked) {
                        binding.switchCoordinates.isChecked = false // Desactivar si se selecciona opción inválida
                    } else {
                        binding.mapSelectionContainer.isVisible = false // Si ya estaba desactivado, solo ocultar
                        resetCoordinates()
                    }
                }
            }
            override fun onNothingSelected(p0: AdapterView<*>?) { /* No se necesita acción */ }
        }
    }

    private fun setupCoordinatesSection() {
        binding.switchCoordinates.setOnCheckedChangeListener { _, isChecked ->
            if (isChecked) {
                if (binding.spinnerLocation.selectedItemPosition <= 1) { // No permitir si no hay estado válido
                    showToast(getString(R.string.error_select_state_first))
                    binding.switchCoordinates.isChecked = false // Revertir el switch
                    return@setOnCheckedChangeListener
                }
                binding.mapSelectionContainer.isVisible = true
            } else {
                binding.mapSelectionContainer.isVisible = false
                resetCoordinates() // Limpiar coordenadas si se apaga el switch
            }
            actualizarUIcoordenadas() // Actualizar la UI en ambos casos
        }

        binding.textViewSelectCoordinates.setOnClickListener {
            if (binding.spinnerLocation.selectedItemPosition > 1) { // Solo si hay un estado válido seleccionado
                openMapForSelection()
            } else {
                showToast(getString(R.string.error_select_state_first))
            }
        }
        binding.btnEditCoordinates.setOnClickListener {
            if (binding.spinnerLocation.selectedItemPosition > 1) { // Solo si hay un estado válido seleccionado
                openMapForSelection()
            }
            // No es necesario un 'else' aquí si el botón solo es visible cuando hay un estado
        }
    }

    private fun openMapForSelection() {
        val intent = Intent(this, MapsActivity::class.java).apply {
            putExtra(getString(R.string.intent_extra_selected_state), binding.spinnerLocation.selectedItem.toString())
            selectedLatitude?.let { putExtra(getString(R.string.intent_extra_latitude), it) }
            selectedLongitude?.let { putExtra(getString(R.string.intent_extra_longitude), it) }
        }
        mapsActivityResultLauncher.launch(intent)
    }

    private fun actualizarUIcoordenadas() {
        val coordinatesAvailable = selectedLatitude != null && selectedLongitude != null
        val switchIsOn = binding.switchCoordinates.isChecked

        if (switchIsOn) {
            binding.mapSelectionContainer.isVisible = true // Asegurar que el contenedor sea visible si el switch está ON
            if (coordinatesAvailable) {
                binding.textViewSelectedCoordinates.text = getString(R.string.selected_coordinates_format, selectedLatitude, selectedLongitude)
                binding.textViewSelectedCoordinates.isVisible = true
                binding.textViewCityName.text = selectedCityName ?: ""
                binding.textViewCityName.isVisible = !selectedCityName.isNullOrEmpty()
                binding.btnEditCoordinates.isVisible = true
                binding.textViewSelectCoordinates.isVisible = false
            } else {
                binding.textViewSelectedCoordinates.isVisible = false
                binding.textViewCityName.isVisible = false
                binding.btnEditCoordinates.isVisible = false
                binding.textViewSelectCoordinates.isVisible = true
            }
        } else {
            binding.mapSelectionContainer.isVisible = false // Ocultar si el switch está OFF
        }
    }

    private fun resetCoordinates() {
        selectedLatitude = null
        selectedLongitude = null
        selectedCityName = null
        actualizarUIcoordenadas() // Actualizar la UI para reflejar el reseteo
    }

    private fun setupDateSelection() {
        binding.radioGroupDateType.setOnCheckedChangeListener { _, checkedId ->
            binding.textInputLayoutYear.isVisible = false
            binding.textInputLayoutExactDate.isVisible = false
            binding.dateRangeLayout.isVisible = false
            binding.dateInputFieldsContainer.isVisible = true // Mostrar contenedor de campos de fecha

            if (checkedId != -1) binding.radioUnknown.isChecked = false // Desmarcar "Desconocido" si se selecciona otro
            clearDateErrors() // Limpiar errores al cambiar tipo

            when (checkedId) {
                R.id.radioYear -> binding.textInputLayoutYear.isVisible = true
                R.id.radioExactDate -> binding.textInputLayoutExactDate.isVisible = true
                R.id.radioDateRange -> binding.dateRangeLayout.isVisible = true
                else -> binding.dateInputFieldsContainer.isVisible = false // Ocultar si no hay nada seleccionado
            }
        }
        binding.radioUnknown.setOnCheckedChangeListener { _, isChecked ->
            if (isChecked) {
                binding.radioGroupDateType.clearCheck() // Desmarcar otros tipos de fecha
                binding.textInputLayoutYear.isVisible = false
                binding.textInputLayoutExactDate.isVisible = false
                binding.dateRangeLayout.isVisible = false
                binding.dateInputFieldsContainer.isVisible = false // Ocultar contenedor
                clearDateFields() // Limpiar campos de fecha
                clearDateErrors() // Limpiar errores
            }
        }
        binding.editTextExactDate.setOnClickListener { if (it.isEnabled) showCustomDatePickerStoryFragment() }

        // Asegurar visibilidad inicial correcta basada en el estado guardado o por defecto
        val initiallyCheckedId = binding.radioGroupDateType.checkedRadioButtonId
        if (initiallyCheckedId != -1) {
            binding.dateInputFieldsContainer.isVisible = true
            when (initiallyCheckedId) {
                R.id.radioYear -> binding.textInputLayoutYear.isVisible = true
                R.id.radioExactDate -> binding.textInputLayoutExactDate.isVisible = true
                R.id.radioDateRange -> binding.dateRangeLayout.isVisible = true
            }
        } else if (binding.radioUnknown.isChecked) {
            binding.dateInputFieldsContainer.isVisible = false
        } else {
            // Por defecto, si nada está seleccionado, el contenedor de campos de fecha debería estar oculto
            binding.dateInputFieldsContainer.isVisible = false
        }
    }

    private fun clearDateErrors() {
        binding.textInputLayoutYear.error = null
        binding.textInputLayoutExactDate.error = null
        binding.textInputLayoutStartYear.error = null
        binding.textInputLayoutEndYear.error = null
        binding.textDateMessageStory.isVisible = false // Ocultar mensaje de error de fecha
    }

    private fun showCustomDatePickerStoryFragment() {
        val cal = Calendar.getInstance()
        var currentDay = cal.get(Calendar.DAY_OF_MONTH)
        var currentMonth = cal.get(Calendar.MONTH) // 0-11
        var currentYear = cal.get(Calendar.YEAR)

        val dateStr = binding.editTextExactDate.text.toString()
        if (dateStr.isNotEmpty()) {
            try {
                val date = dateFormatStory.parse(dateStr)
                date?.let {
                    val selectedCal = Calendar.getInstance().apply { time = it }
                    currentDay = selectedCal.get(Calendar.DAY_OF_MONTH)
                    currentMonth = selectedCal.get(Calendar.MONTH)
                    currentYear = selectedCal.get(Calendar.YEAR)
                }
            } catch (e: ParseException) {
                Log.w(TAG, getString(R.string.log_error_parsing_date_datepicker_story, dateStr), e)
                // No es necesario mostrar un Toast aquí, el diálogo usará la fecha actual
            }
        }

        val dialog = DialogCustomDatePicker.newInstance(
            initialDay = currentDay,
            initialMonth = currentMonth,
            initialYear = currentYear,
            minYear = MIN_YEAR_STORY, // minYear específico para relatos
            title = getString(R.string.dialog_title_story_date) // Título específico
        )
        dialog.show(supportFragmentManager, "customDatePickerStoryDialog")
    }


    override fun onDateSelected(day: Int, month: Int, year: Int) {
        val cal = Calendar.getInstance().apply { set(year, month, day, 0, 0, 0) } // Asegurar hora 00:00:00
        binding.editTextExactDate.setText(dateFormatStory.format(cal.time))
        binding.textInputLayoutExactDate.error = null // Limpiar error al seleccionar
    }

    private fun clearAllFields() {
        binding.editTextStoryTitle.text?.clear()
        binding.textInputLayoutStoryTitle.error = null

        // Limpiar fragmentos
        getFragmentAtIndex<WriteStoryFragment>(0)?.setStoryText("") // Limpiar texto del relato
        getFragmentAtIndex<RecordAudioFragment>(1)?.resetState() // Resetear fragmento de grabación
        getFragmentAtIndex<AttachAudioFragment>(2)?.resetState() // Resetear fragmento de adjuntar

        // Limpiar URIs y nombres de audio
        recordedAudioUri = null
        recordedAudioOriginalName = null
        attachedAudioUri = null
        attachedAudioOriginalName = null
        finalAudioToUploadUri = null
        finalAudioOriginalName = null
        updateAudioWarningVisibility() // Actualizar advertencia de audio

        binding.spinnerStoryType.setSelection(0) // Resetear spinner de tipo de relato
        binding.editTextOtherStoryType.text?.clear()
        binding.textInputLayoutOtherStoryType.error = null
        binding.spinnerLocation.setSelection(0) // Resetear spinner de ubicación
        binding.radioGroupDateType.clearCheck() // Limpiar selección de tipo de fecha
        binding.radioUnknown.isChecked = false // Desmarcar "Desconocido"
        clearDateFields() // Limpiar campos de fecha individuales
        clearOptionalImageSelection() // Limpiar selección de imagen opcional
        binding.switchCoordinates.isChecked = false // Resetear switch de coordenadas

        // Resetear estado de subida
        binding.uploadProgressOverlayStory.isVisible = false
        setUiEnabled(true)
        isSubmitting = false
        currentStoryImageUploadRequestId = null
        currentAudioFileUploadRequestId = null
        Log.d(TAG, getString(R.string.log_all_fields_cleared_story))
    }

    private fun clearDateFields() {
        binding.editTextYear.text?.clear()
        binding.editTextExactDate.text?.clear()
        binding.editTextStartYear.text?.clear()
        binding.editTextEndYear.text?.clear()
        clearDateErrors() // También limpiar errores de fecha
    }

    private fun clearOptionalImageSelection() {
        selectedImageUri = null
        binding.imageViewPreviewStory.setImageDrawable(null) // Limpiar la imagen
        binding.imageViewPreviewStory.isVisible = false
        binding.textViewPreviewLabelStory.isVisible = false
    }

    private fun showDateFormatInfoDialog() {
        AlertDialog.Builder(this)
            .setTitle(R.string.desc_info_date_format_title)
            .setMessage(R.string.desc_info_date_format_message)
            .setPositiveButton(R.string.dialog_positive_button_understood, null)
            .show()
    }

    private fun getFileSize(resolver: ContentResolver, uri: Uri): Long {
        var size = 0L
        try {
            resolver.query(uri, arrayOf(OpenableColumns.SIZE), null, null, null)?.use { cursor ->
                if (cursor.moveToFirst()) {
                    val sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE)
                    if (sizeIndex != -1) size = cursor.getLong(sizeIndex)
                }
            }
        } catch (e: SecurityException) {
            Log.e(TAG, getString(R.string.log_security_exception_get_filesize_uri_story, uri.toString()), e)
            showToast(getString(R.string.error_accessing_file_permission, uri.lastPathSegment ?: getString(R.string.default_file_name)))
        } catch (e: IllegalArgumentException) {
            Log.e(TAG, getString(R.string.log_illegal_argument_get_filesize_uri_story, uri.toString()), e)
            showToast(getString(R.string.error_invalid_file_type_specific, getString(R.string.unknown_format)))
        } catch (e: Exception) { // Captura más genérica para otros errores
            Log.e(TAG, getString(R.string.log_error_get_filesize_uri_story, uri.toString()), e)
            showToast(getString(R.string.upload_file_error_message, e.localizedMessage ?: getString(R.string.unknown_error)))
        }
        return size
    }


    private fun setupTextWatchers() {
        fun createWatcher(layout: TextInputLayout) = object : TextWatcher {
            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}
            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) { layout.error = null }
            override fun afterTextChanged(s: Editable?) {}
        }
        binding.editTextStoryTitle.addTextChangedListener(createWatcher(binding.textInputLayoutStoryTitle))
        binding.editTextOtherStoryType.addTextChangedListener(createWatcher(binding.textInputLayoutOtherStoryType))
        binding.editTextYear.addTextChangedListener(createWatcher(binding.textInputLayoutYear))
        binding.editTextExactDate.addTextChangedListener(createWatcher(binding.textInputLayoutExactDate))
        binding.editTextStartYear.addTextChangedListener(createWatcher(binding.textInputLayoutStartYear))
        binding.editTextEndYear.addTextChangedListener(createWatcher(binding.textInputLayoutEndYear))
    }

    private fun showToast(message: String) {
        Toast.makeText(this, message, Toast.LENGTH_SHORT).show()
    }

    private fun processStorySubmission() {
        if (isSubmitting) {
            Log.d(TAG, getString(R.string.log_submission_already_in_progress_story))
            return
        }

        val storyText = getStoryTextFromFragment()
        if (!validateForm(storyText)) {
            Log.w(TAG, getString(R.string.log_form_not_valid_story))
            return
        }

        // Determinar qué audio se va a subir
        finalAudioToUploadUri = recordedAudioUri ?: attachedAudioUri
        finalAudioOriginalName = recordedAudioOriginalName ?: attachedAudioOriginalName

        val dialogMessage = if (finalAudioToUploadUri != null && selectedImageUri != null) {
            getString(R.string.submission_success_story_audio_image)
        } else if (finalAudioToUploadUri != null) {
            getString(R.string.dialog_confirm_upload_story_with_audio_message)
        } else if (selectedImageUri != null) {
            getString(R.string.submission_success_story_image)
        }
        else { // Solo relato de texto
            getString(R.string.dialog_confirm_upload_story_text_only_message)
        }


        AlertDialog.Builder(this)
            .setTitle(getString(R.string.dialog_confirm_upload_title))
            .setMessage(dialogMessage)
            .setPositiveButton(getString(R.string.accept)) { _, _ ->
                proceedWithSubmission(storyText)
            }
            .setNegativeButton(getString(R.string.cancelar), null)
            .show()
    }

    private fun proceedWithSubmission(storyText: String) {
        setUiEnabled(false) // Deshabilitar UI
        isSubmitting = true

        binding.uploadProgressOverlayStory.isVisible = true
        binding.progressBarUploadStory.progress = 0 // Resetear progreso
        binding.textProgressStory.text = getString(R.string.uploading_content_progress) // Mensaje inicial

        val currentUser = auth.currentUser ?: run {
            Log.e(TAG, getString(R.string.log_error_user_not_authenticated_submission_story))
            handleUploadError(getString(R.string.error_user_not_authenticated))
            return
        }
        val userId = currentUser.uid

        firestore.collection(getString(R.string.firestore_collection_users)).document(userId).get()
            .addOnSuccessListener { userDocument ->
                val authorUsername = userDocument.getString(getString(R.string.firestore_field_username))?.takeIf { it.isNotEmpty() } ?: currentUser.displayName ?: getString(R.string.unknown_user)
                val authorProfileImageUrl = userDocument.getString(getString(R.string.firestore_field_profileImageUrl))?.takeIf { it.isNotEmpty() } ?: currentUser.photoUrl?.toString() ?: ""

                val storyTitle = binding.editTextStoryTitle.text.toString().trim()
                var storyTypeSelected = binding.spinnerStoryType.selectedItem.toString()
                if (storyTypeSelected == getString(R.string.story_type_other)) {
                    storyTypeSelected = binding.editTextOtherStoryType.text.toString().trim()
                }
                val location = binding.spinnerLocation.selectedItem.toString()
                val dateData = getDateFromInputs()

                val storyData = hashMapOf<String, Any?>(
                    getString(R.string.firestore_field_userId) to userId,
                    getString(R.string.firestore_field_authorUsername) to authorUsername,
                    getString(R.string.firestore_field_authorProfileImageUrl) to authorProfileImageUrl,
                    getString(R.string.firestore_field_title) to storyTitle,
                    getString(R.string.firestore_field_text) to storyText.takeIf { it.isNotBlank() }, // Guardar texto solo si no está vacío
                    getString(R.string.firestore_field_type) to getString(R.string.content_type_story), // Tipo de contenido
                    getString(R.string.firestore_field_storyType) to storyTypeSelected,
                    getString(R.string.firestore_field_location) to location,
                    getString(R.string.firestore_field_date) to dateData, // Mapa de datos de fecha
                    getString(R.string.firestore_field_timestamp) to FieldValue.serverTimestamp(),
                    getString(R.string.firestore_field_status) to getString(R.string.status_pending_value), // Estado inicial
                    getString(R.string.firestore_field_isVisible) to false, // No visible hasta aprobación
                    getString(R.string.firestore_field_likes) to 0,
                    getString(R.string.firestore_field_commentsCount) to 0,
                    getString(R.string.firestore_field_imageUrl) to null, // Se actualizará si hay imagen
                    getString(R.string.firestore_field_audioUrl) to null, // Se actualizará si hay audio
                    getString(R.string.firestore_field_audioOriginalName) to null, // Nombre original del audio
                    getString(R.string.firestore_field_latitude) to selectedLatitude,
                    getString(R.string.firestore_field_longitude) to selectedLongitude,
                    getString(R.string.firestore_field_cityName) to selectedCityName,
                    getString(R.string.firestore_field_moderatedBy) to null,
                    getString(R.string.firestore_field_moderationTimestamp) to null,
                    getString(R.string.firestore_field_rejectionReason) to null
                )

                // Lógica de subida secuencial: Audio -> Imagen (si existe) -> Firestore
                if (finalAudioToUploadUri != null) {
                    Log.i(TAG, getString(R.string.log_starting_cloudinary_audio_upload, finalAudioToUploadUri.toString()))
                    runOnUiThread { binding.textProgressStory.text = getString(R.string.info_audio_preparing) } // Mensaje específico
                    uploadAudioToCloudinary(finalAudioToUploadUri!!, finalAudioOriginalName, storyData) { audioUrl, originalName ->
                        storyData[getString(R.string.firestore_field_audioUrl)] = audioUrl
                        storyData[getString(R.string.firestore_field_audioOriginalName)] = originalName // Guardar nombre original
                        if (selectedImageUri != null) {
                            Log.i(TAG, getString(R.string.log_audio_uploaded_starting_optional_image_upload, selectedImageUri.toString()))
                            uploadOptionalImageToCloudinary(selectedImageUri!!, storyData) { imageUrl ->
                                storyData[getString(R.string.firestore_field_imageUrl)] = imageUrl
                                saveStoryDataToFirestore(storyData)
                            }
                        } else {
                            Log.i(TAG, getString(R.string.log_audio_uploaded_no_optional_image))
                            saveStoryDataToFirestore(storyData)
                        }
                    }
                } else if (selectedImageUri != null) { // Si no hay audio pero sí imagen
                    Log.i(TAG, getString(R.string.log_no_audio_starting_optional_image_upload, selectedImageUri.toString()))
                    uploadOptionalImageToCloudinary(selectedImageUri!!, storyData) { imageUrl ->
                        storyData[getString(R.string.firestore_field_imageUrl)] = imageUrl
                        saveStoryDataToFirestore(storyData)
                    }
                } else { // Solo texto
                    Log.i(TAG, getString(R.string.log_no_audio_no_optional_image))
                    saveStoryDataToFirestore(storyData)
                }
            }
            .addOnFailureListener { e ->
                Log.e(TAG, getString(R.string.log_error_getting_user_data_for_authorship_story), e)
                handleUploadError(getString(R.string.submission_generic_error_message_upload) + getString(R.string.error_suffix_user_data_fetch))
            }
    }


    private fun validateForm(storyText: String): Boolean {
        var isValid = true
        val storyTitle = binding.editTextStoryTitle.text.toString().trim()
        if (storyTitle.isBlank()) {
            binding.textInputLayoutStoryTitle.error = getString(R.string.error_story_title_required)
            isValid = false
        } else if (storyTitle.length > 37) { // Asumiendo que 37 es el límite
            binding.textInputLayoutStoryTitle.error = getString(R.string.error_title_length)
            isValid = false
        } else {
            binding.textInputLayoutStoryTitle.error = null
        }

        // Validar que haya texto o audio
        if (storyText.isBlank() && recordedAudioUri == null && attachedAudioUri == null) {
            showToast(getString(R.string.error_story_text_or_audio_required))
            binding.tabLayoutStoryInput.getTabAt(0)?.select() // Enfocar pestaña de texto
            isValid = false
        } else if (storyText.length > 20000) { // Límite de caracteres para el texto
            showToast(getString(R.string.error_story_text_too_long, 20000))
            binding.tabLayoutStoryInput.getTabAt(0)?.select() // Enfocar pestaña de texto
            isValid = false
        }


        if (binding.spinnerStoryType.selectedItemPosition == 0) { // "Seleccione un tipo"
            showToast(getString(R.string.error_story_type_required))
            isValid = false
        } else if (binding.spinnerStoryType.selectedItem.toString() == getString(R.string.story_type_other)) {
            if (binding.editTextOtherStoryType.text.toString().trim().isBlank()) {
                binding.textInputLayoutOtherStoryType.error = getString(R.string.error_other_story_type_required)
                isValid = false
            } else {
                binding.textInputLayoutOtherStoryType.error = null
            }
        }

        if (binding.spinnerLocation.selectedItemPosition == 0) { // "Seleccione una ubicación"
            showToast(getString(R.string.error_location_required))
            isValid = false
        }

        if (!validateDateSelection()) isValid = false

        if (binding.switchCoordinates.isChecked && (selectedLatitude == null || selectedLongitude == null)) {
            showToast(getString(R.string.error_select_coordinates_on_map))
            isValid = false
        }
        return isValid
    }

    private fun validateDateSelection(): Boolean {
        var dateValid = true
        clearDateErrors() // Limpiar errores previos
        val checkedId = binding.radioGroupDateType.checkedRadioButtonId

        // Si no se ha seleccionado ningún tipo de fecha Y "Desconocido" no está marcado
        if (checkedId == -1 && !binding.radioUnknown.isChecked) {
            binding.textDateMessageStory.text = getString(R.string.error_select_date_type_or_unknown)
            binding.textDateMessageStory.isVisible = true
            return false // No es válido si no se selecciona nada
        }
        // Si "Desconocido" está marcado, es válido
        if (binding.radioUnknown.isChecked) return true

        // Validaciones para los tipos de fecha específicos
        val currentYear = Calendar.getInstance().get(Calendar.YEAR)
        val minDateCalStory = Calendar.getInstance().apply { set(MIN_YEAR_STORY, Calendar.JANUARY, 1,0,0,0) } // Para comparación


        when (checkedId) {
            R.id.radioYear -> {
                val yearStr = binding.editTextYear.text.toString()
                val year = yearStr.toIntOrNull()
                if (yearStr.isEmpty() || year == null || year < MIN_YEAR_STORY || year > currentYear) {
                    binding.textInputLayoutYear.error = getString(R.string.error_invalid_year_range_simple, MIN_YEAR_STORY, currentYear)
                    dateValid = false
                }
            }
            R.id.radioExactDate -> {
                val dateStr = binding.editTextExactDate.text.toString()
                if (dateStr.isEmpty()) {
                    binding.textInputLayoutExactDate.error = getString(R.string.error_select_exact_date)
                    dateValid = false
                } else {
                    try {
                        val date = dateFormatStory.parse(dateStr) // dateFormatStory ya es lenient = false
                        val selectedCal = Calendar.getInstance().apply { time = date!! }
                        // Normalizar horas, minutos, segundos para comparación justa de fechas
                        selectedCal.set(Calendar.HOUR_OF_DAY, 0); selectedCal.set(Calendar.MINUTE, 0); selectedCal.set(Calendar.SECOND, 0); selectedCal.set(Calendar.MILLISECOND, 0)
                        val todayCal = Calendar.getInstance().apply {set(Calendar.HOUR_OF_DAY, 0); set(Calendar.MINUTE, 0); set(Calendar.SECOND, 0); set(Calendar.MILLISECOND, 0) }

                        if (selectedCal.before(minDateCalStory) || selectedCal.after(todayCal)) {
                            binding.textInputLayoutExactDate.error = getString(R.string.error_invalid_date_range, dateFormatStory.format(minDateCalStory.time), dateFormatStory.format(todayCal.time))
                            dateValid = false
                        }
                    } catch (e: ParseException) {
                        binding.textInputLayoutExactDate.error = getString(R.string.error_invalid_date_format)
                        dateValid = false
                    }
                }
            }
            R.id.radioDateRange -> {
                val startYearStr = binding.editTextStartYear.text.toString()
                val endYearStr = binding.editTextEndYear.text.toString()
                val startYear = startYearStr.toIntOrNull()
                val endYear = endYearStr.toIntOrNull()

                var individualYearsValid = true
                if (startYearStr.isEmpty() || startYear == null || startYear < MIN_YEAR_STORY || startYear > currentYear) {
                    binding.textInputLayoutStartYear.error = getString(R.string.error_invalid_year_range_simple, MIN_YEAR_STORY, currentYear)
                    individualYearsValid = false
                }
                if (endYearStr.isEmpty() || endYear == null || endYear < MIN_YEAR_STORY || endYear > currentYear) {
                    binding.textInputLayoutEndYear.error = getString(R.string.error_invalid_year_range_simple, MIN_YEAR_STORY, currentYear)
                    individualYearsValid = false
                }

                if (individualYearsValid && startYear != null && endYear != null && startYear > endYear) {
                    binding.textInputLayoutStartYear.error = getString(R.string.error_year_range_order)
                    binding.textInputLayoutEndYear.error = getString(R.string.error_year_range_order) // Mostrar error en ambos
                    dateValid = false
                } else if (!individualYearsValid) { // Si alguno de los años individuales no es válido
                    dateValid = false
                }
            }
        }
        if (!dateValid) { // Si alguna validación falló, mostrar mensaje general
            binding.textDateMessageStory.text = getString(R.string.error_correct_date_errors)
            binding.textDateMessageStory.isVisible = true
        }
        return dateValid
    }


    private fun getDateFromInputs(): Map<String, Any?> {
        val dateMap = mutableMapOf<String, Any?>()
        if (binding.radioUnknown.isChecked) {
            dateMap[getString(R.string.firestore_field_date_type)] = getString(R.string.date_type_value_unknown)
            dateMap[getString(R.string.firestore_field_date_value)] = getString(R.string.date_type_unknown) // Valor textual para "Desconocido"
        } else {
            when (binding.radioGroupDateType.checkedRadioButtonId) {
                R.id.radioYear -> {
                    dateMap[getString(R.string.firestore_field_date_type)] = getString(R.string.date_type_value_year)
                    dateMap[getString(R.string.firestore_field_date_value)] = binding.editTextYear.text.toString().toIntOrNull()
                }
                R.id.radioExactDate -> {
                    dateMap[getString(R.string.firestore_field_date_type)] = getString(R.string.date_type_value_exact)
                    dateMap[getString(R.string.firestore_field_date_value)] = binding.editTextExactDate.text.toString() // Guardar como String dd/MM/yyyy
                }
                R.id.radioDateRange -> {
                    dateMap[getString(R.string.firestore_field_date_type)] = getString(R.string.date_type_value_range)
                    dateMap[getString(R.string.firestore_field_date_startYear)] = binding.editTextStartYear.text.toString().toIntOrNull()
                    dateMap[getString(R.string.firestore_field_date_endYear)] = binding.editTextEndYear.text.toString().toIntOrNull()
                }
                else -> dateMap[getString(R.string.firestore_field_date_type)] = getString(R.string.date_type_value_none) // Caso por defecto
            }
        }
        return dateMap
    }


    private fun getStoryTextFromFragment(): String {
        val writeFragment = getFragmentAtIndex<WriteStoryFragment>(0) // Índice 0 para WriteStoryFragment
        return writeFragment?.getStoryText()?.trim() ?: ""
    }

    private fun uploadAudioToCloudinary(audioFileUri: Uri, originalFileName: String?, storyData: HashMap<String, Any?>, onComplete: (audioUrl: String?, originalName: String?) -> Unit) {
        runOnUiThread {
            binding.progressBarUploadStory.isIndeterminate = false // Asegurar que no sea indeterminada
            binding.progressBarUploadStory.progress = 0
            binding.textProgressStory.text = getString(R.string.uploading_audio_progress, 0)
        }

        val audioBytes = getBytesFromUri(audioFileUri) ?: run {
            Log.e(TAG, getString(R.string.log_error_getting_bytes_from_audio_uri, audioFileUri.toString()))
            handleUploadError(getString(R.string.error_audio_compression)) // Mensaje genérico de error de audio
            onComplete(null, originalFileName) // Notificar que falló
            return
        }

        // Crear un nombre de archivo más seguro para Cloudinary
        val cloudinaryFileName = originalFileName?.let {
            it.substringBeforeLast('.').replace(Regex("[^a-zA-Z0-9_-]"), "_") // Reemplazar caracteres no válidos
        } ?: getString(R.string.cloudinary_default_audio_filename_prefix) + System.currentTimeMillis()


        val options = HashMap<String, Any>().apply {
            put(getString(R.string.cloudinary_option_folder), getString(R.string.cloudinary_folder_story_audios, storyData[getString(R.string.firestore_field_userId)]))
            put(getString(R.string.cloudinary_option_resource_type), getString(R.string.cloudinary_resource_type_video)) // Cloudinary trata audios como "videos"
            put(getString(R.string.cloudinary_option_public_id), cloudinaryFileName) // Usar el nombre sanitizado

            // No es necesario especificar 'format' para tipos comunes como m4a, mp3, opus, ogg, aac.
            // Cloudinary intentará detectarlo.
        }

        currentAudioFileUploadRequestId = MediaManager.get().upload(audioBytes)
            .options(options)
            .callback(object : UploadCallback {
                override fun onStart(requestId: String?) { Log.i(TAG, getString(R.string.log_cloudinary_audio_upload_started, requestId)) }
                override fun onProgress(requestId: String?, bytes: Long, totalBytes: Long) {
                    val progress = if (totalBytes > 0) (bytes.toDouble() / totalBytes * 100).toInt() else 0
                    runOnUiThread {
                        binding.progressBarUploadStory.progress = progress
                        binding.textProgressStory.text = getString(R.string.uploading_audio_progress, progress)
                    }
                }
                override fun onSuccess(requestId: String?, resultData: MutableMap<Any?, Any?>?) {
                    currentAudioFileUploadRequestId = null
                    val url = resultData?.get(getString(R.string.cloudinary_result_secure_url)) as? String
                    Log.i(TAG, getString(R.string.log_cloudinary_audio_upload_success, url))
                    onComplete(url, originalFileName) // Pasar nombre original
                }
                override fun onError(requestId: String?, error: ErrorInfo?) {
                    currentAudioFileUploadRequestId = null
                    val errorMsg = error?.description ?: getString(R.string.error_unknown_upload)
                    Log.e(TAG, getString(R.string.log_error_cloudinary_audio_upload, requestId, errorMsg, error?.code.toString()))
                    if (error?.code == ErrorInfo.REQUEST_CANCELLED) {
                        handleUploadError(getString(R.string.upload_cancelled) + getString(R.string.error_suffix_audio_upload))
                    } else {
                        handleUploadError(getString(R.string.error_upload_audio_generic, errorMsg))
                    }
                    onComplete(null, originalFileName)
                }
                override fun onReschedule(requestId: String?, error: ErrorInfo?) {
                    currentAudioFileUploadRequestId = null
                    Log.w(TAG, getString(R.string.log_cloudinary_audio_upload_rescheduled, requestId, error?.description, error?.code.toString()))
                    handleUploadError(getString(R.string.error_upload_audio_rescheduled))
                    onComplete(null, originalFileName)
                }
            })
            .dispatch()
    }

    private fun uploadOptionalImageToCloudinary(imageUri: Uri, storyData: HashMap<String, Any?>, onComplete: (String?) -> Unit) {
        runOnUiThread { // Asegurar que se ejecuta en UI thread
            binding.textProgressStory.text = getString(R.string.uploading_image_progress_percent, 0)
            binding.progressBarUploadStory.progress = 0 // Resetear progreso para la imagen
            binding.progressBarUploadStory.isIndeterminate = false // Asegurar que no sea indeterminada
        }

        val imageBytes = compressImageToWebP(imageUri, 70, 1280) ?: run {
            Log.e(TAG, getString(R.string.log_error_compressing_optional_image_uri, imageUri.toString()))
            handleUploadError(getString(R.string.error_image_compression_failed))
            onComplete(null) // Notificar que falló
            return
        }

        val options = HashMap<String, Any>().apply {
            put(getString(R.string.cloudinary_option_folder), getString(R.string.cloudinary_folder_story_images, storyData[getString(R.string.firestore_field_userId)]))
            put(getString(R.string.cloudinary_option_public_id), getString(R.string.cloudinary_public_id_story_image_prefix) + System.currentTimeMillis() + "_" + UUID.randomUUID())
            put(getString(R.string.cloudinary_option_resource_type), getString(R.string.cloudinary_resource_type_image))
        }

        currentStoryImageUploadRequestId = MediaManager.get().upload(imageBytes)
            .options(options)
            .callback(object : UploadCallback {
                override fun onStart(requestId: String?) { Log.i(TAG, getString(R.string.log_cloudinary_optional_image_upload_started, requestId)) }
                override fun onProgress(requestId: String?, bytes: Long, totalBytes: Long) {
                    val progress = if (totalBytes > 0) (bytes.toDouble() / totalBytes * 100).toInt() else 0
                    runOnUiThread {
                        binding.progressBarUploadStory.progress = progress
                        binding.textProgressStory.text = getString(R.string.uploading_image_progress_percent, progress)
                    }
                }
                override fun onSuccess(requestId: String?, resultData: MutableMap<Any?, Any?>?) {
                    currentStoryImageUploadRequestId = null
                    val url = resultData?.get(getString(R.string.cloudinary_result_secure_url)) as? String
                    Log.i(TAG, getString(R.string.log_cloudinary_optional_image_upload_success, url))
                    onComplete(url)
                }
                override fun onError(requestId: String?, error: ErrorInfo?) {
                    currentStoryImageUploadRequestId = null
                    val errorMsg = error?.description ?: getString(R.string.error_unknown_upload)
                    Log.e(TAG, getString(R.string.log_error_cloudinary_optional_image_upload, requestId, errorMsg, error?.code.toString()))
                    if (error?.code == ErrorInfo.REQUEST_CANCELLED) {
                        handleUploadError(getString(R.string.upload_cancelled) + getString(R.string.error_suffix_story_image_upload))
                    } else {
                        handleUploadError(getString(R.string.error_upload_image_generic_story, errorMsg))
                    }
                    onComplete(null) // Notificar que falló
                }
                override fun onReschedule(requestId: String?, error: ErrorInfo?) {
                    currentStoryImageUploadRequestId = null
                    Log.w(TAG, getString(R.string.log_cloudinary_optional_image_upload_rescheduled, requestId, error?.description, error?.code.toString()))
                    handleUploadError(getString(R.string.error_upload_image_rescheduled_story))
                    onComplete(null) // Notificar que falló
                }
            })
            .dispatch()
    }


    private fun saveStoryDataToFirestore(storyData: HashMap<String, Any?>) {
        runOnUiThread { binding.textProgressStory.text = getString(R.string.uploading_content_progress) } // Mensaje "Guardando..."
        firestore.collection(getString(R.string.firestore_collection_stories_pending)).add(storyData)
            .addOnSuccessListener { documentReference ->
                Log.i(TAG, getString(R.string.log_firestore_story_data_saved, documentReference.id))
                runOnUiThread {
                    binding.uploadProgressOverlayStory.isVisible = false // Ocultar overlay

                    // Determinar mensaje de éxito basado en lo que se subió
                    val successMessage = when {
                        storyData[getString(R.string.firestore_field_audioUrl)] != null && storyData[getString(R.string.firestore_field_imageUrl)] != null -> getString(R.string.submission_success_story_audio_image_sent)
                        storyData[getString(R.string.firestore_field_audioUrl)] != null -> getString(R.string.submission_success_story_audio_sent)
                        storyData[getString(R.string.firestore_field_imageUrl)] != null -> getString(R.string.submission_success_story_image_sent)
                        else -> getString(R.string.submission_success_message_story) // Solo texto
                    }

                    showSubmissionConfirmationDialog(
                        getString(R.string.submission_success_title_story),
                        successMessage
                    )
                }
            }
            .addOnFailureListener { e ->
                Log.e(TAG, getString(R.string.log_error_firestore_saving_story_data), e)
                handleUploadError(getString(R.string.save_story_error_message, e.localizedMessage) + getString(R.string.error_suffix_firestore_save_story))
            }
    }

    private fun handleUploadError(errorMessage: String) {
        Log.e(TAG, getString(R.string.log_handling_upload_error_story, errorMessage))
        currentStoryImageUploadRequestId = null // Limpiar IDs
        currentAudioFileUploadRequestId = null
        runOnUiThread {
            binding.uploadProgressOverlayStory.isVisible = false
            showAlertDialog(getString(R.string.error_dialog_title), getString(R.string.upload_error_prefix, errorMessage))
            setUiEnabled(true) // Reactivar UI
            isSubmitting = false
        }
    }

    private fun showSubmissionConfirmationDialog(title: String, message: String) {
        if (isFinishing || isDestroyed) {
            Log.w(TAG, getString(R.string.log_activity_finishing_dialog_not_shown_story))
            return
        }
        AlertDialog.Builder(this)
            .setTitle(title)
            .setMessage(message)
            .setPositiveButton(R.string.dialog_positive_button_understood) { _, _ ->
                finish()
            }
            .setCancelable(false) // No permitir cancelar el diálogo con back button
            .show()
    }


    private fun setUiEnabled(enabled: Boolean) {
        binding.btnEnviarRelato.isEnabled = enabled
        binding.btnBorrarTodo.isEnabled = enabled
        binding.editTextStoryTitle.isEnabled = enabled

        // Habilitar/deshabilitar interacción con las pestañas
        for (i in 0 until binding.tabLayoutStoryInput.tabCount) {
            val tabView = (binding.tabLayoutStoryInput.getTabAt(i)?.view)
            tabView?.isClickable = enabled
            tabView?.alpha = if (enabled) 1.0f else 0.5f // Efecto visual de deshabilitado
        }
        binding.viewPagerStoryInput.isUserInputEnabled = enabled // Deshabilitar swipe entre pestañas


        binding.spinnerStoryType.isEnabled = enabled
        binding.editTextOtherStoryType.isEnabled = enabled && binding.textInputLayoutOtherStoryType.isVisible
        binding.spinnerLocation.isEnabled = enabled
        binding.btnSelectImageStory.isEnabled = enabled

        binding.radioGroupDateType.isEnabled = enabled
        for (i in 0 until binding.radioGroupDateType.childCount) {
            binding.radioGroupDateType.getChildAt(i).isEnabled = enabled
        }
        binding.radioUnknown.isEnabled = enabled

        binding.editTextYear.isEnabled = enabled && binding.textInputLayoutYear.isVisible
        binding.editTextExactDate.isEnabled = enabled && binding.textInputLayoutExactDate.isVisible
        binding.editTextStartYear.isEnabled = enabled && binding.dateRangeLayout.isVisible
        binding.editTextEndYear.isEnabled = enabled && binding.dateRangeLayout.isVisible
        binding.infoIconDate.isEnabled = enabled

        binding.switchCoordinates.isEnabled = enabled
        binding.textViewSelectCoordinates.isEnabled = enabled && binding.mapSelectionContainer.isVisible && binding.textViewSelectCoordinates.isVisible
        binding.btnEditCoordinates.isEnabled = enabled && binding.mapSelectionContainer.isVisible && binding.btnEditCoordinates.isVisible
    }

    private fun resizeBitmapKeepingAspectRatio(bitmap: Bitmap, maxSideLength: Int): Bitmap {
        val currentWidth = bitmap.width
        val currentHeight = bitmap.height

        if (currentWidth <= maxSideLength && currentHeight <= maxSideLength) {
            return bitmap
        }

        val ratio = currentWidth.toFloat() / currentHeight.toFloat()
        var newWidth: Int
        var newHeight: Int

        if (currentWidth > currentHeight) {
            newWidth = maxSideLength
            newHeight = (maxSideLength / ratio).roundToInt()
        } else {
            newHeight = maxSideLength
            newWidth = (maxSideLength * ratio).roundToInt()
        }

        // Asegurar que las nuevas dimensiones no sean cero
        if (newWidth <= 0) newWidth = 1
        if (newHeight <= 0) newHeight = 1

        return bitmap.scale(newWidth, newHeight, true)
    }

    private fun compressImageToWebP(uri: Uri, quality: Int, maxSideLength: Int): ByteArray? {
        var inputStream: InputStream? = null
        var exifInputStream: InputStream? = null
        try {
            inputStream = contentResolver.openInputStream(uri) ?: throw FileNotFoundException(getString(R.string.error_inputstream_null_for_uri_compress, uri.toString()))
            val originalBitmap = BitmapFactory.decodeStream(inputStream)
                ?: throw IOException(getString(R.string.error_failed_decode_bitmap_from_uri_compress, uri.toString()))

            exifInputStream = contentResolver.openInputStream(uri) ?: throw FileNotFoundException(getString(R.string.error_exif_inputstream_null_for_uri_compress, uri.toString()))
            val exif = ExifInterface(exifInputStream)
            val orientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL)

            val matrix = Matrix()
            when (orientation) {
                ExifInterface.ORIENTATION_ROTATE_90 -> matrix.postRotate(90f)
                ExifInterface.ORIENTATION_ROTATE_180 -> matrix.postRotate(180f)
                ExifInterface.ORIENTATION_ROTATE_270 -> matrix.postRotate(270f)
                ExifInterface.ORIENTATION_FLIP_HORIZONTAL -> matrix.postScale(-1f, 1f)
                ExifInterface.ORIENTATION_FLIP_VERTICAL -> matrix.postScale(1f, -1f)
                ExifInterface.ORIENTATION_TRANSPOSE -> { matrix.postRotate(90f); matrix.postScale(-1f, 1f) }
                ExifInterface.ORIENTATION_TRANSVERSE -> { matrix.postRotate(-90f); matrix.postScale(-1f, 1f) }
            }
            val rotatedBitmap = Bitmap.createBitmap(originalBitmap, 0, 0, originalBitmap.width, originalBitmap.height, matrix, true)
            if (originalBitmap != rotatedBitmap) { // Solo reciclar si se creó un nuevo bitmap
                originalBitmap.recycle()
            }

            val resizedBitmap = resizeBitmapKeepingAspectRatio(rotatedBitmap, maxSideLength)
            if (rotatedBitmap != resizedBitmap) { // Solo reciclar si se creó un nuevo bitmap
                rotatedBitmap.recycle()
            }

            ByteArrayOutputStream().use { outputStream ->
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
                    resizedBitmap.compress(Bitmap.CompressFormat.WEBP_LOSSY, quality, outputStream)
                } else {
                    @Suppress("DEPRECATION") // WEBP_LOSSY es preferido en R+, pero WEBP es la opción para < R
                    resizedBitmap.compress(Bitmap.CompressFormat.WEBP, quality, outputStream)
                }
                resizedBitmap.recycle() // Reciclar el bitmap final
                return outputStream.toByteArray()
            }

        } catch (fnfe: FileNotFoundException) {
            Log.e(TAG, getString(R.string.log_error_file_not_found_compress_webp_story, uri.toString()), fnfe)
            showToast(getString(R.string.error_file_not_found_for_compression, uri.lastPathSegment ?: getString(R.string.selected_image_default_name)))
            return null
        } catch (ioe: IOException) {
            Log.e(TAG, getString(R.string.log_error_io_compress_webp_story, uri.toString()), ioe)
            showToast(getString(R.string.error_io_compressing_image))
            return null
        } catch (e: Exception) { // Captura más genérica para otros errores
            Log.e(TAG, getString(R.string.log_error_unexpected_compress_webp_story, uri.toString()), e)
            showToast(getString(R.string.error_unknown_compressing_image))
            return null
        } finally {
            try {
                inputStream?.close()
                exifInputStream?.close()
            } catch (ioe: IOException) {
                Log.e(TAG, getString(R.string.log_error_closing_streams_compress_webp_uri_story, uri.toString()), ioe)
            }
        }
    }


    private fun getBytesFromUri(uri: Uri): ByteArray? {
        try {
            return contentResolver.openInputStream(uri)?.use { it.readBytes() }
        } catch (fnfe: FileNotFoundException) {
            Log.e(TAG, getString(R.string.log_error_file_not_found_get_bytes, uri.toString()), fnfe)
            showToast(getString(R.string.error_file_not_found_for_compression, uri.lastPathSegment ?: getString(R.string.default_file_name)))
            return null
        } catch (ioe: IOException) {
            Log.e(TAG, getString(R.string.log_error_io_get_bytes, uri.toString()), ioe)
            showToast(getString(R.string.error_io_compressing_image)) // Reutilizar si es genérico
            return null
        } catch (e: SecurityException) { // Añadir manejo de SecurityException
            Log.e(TAG, getString(R.string.log_security_exception_get_bytes, uri.toString()), e)
            showToast(getString(R.string.error_accessing_file_permission, uri.lastPathSegment ?: getString(R.string.default_file_name)))
            return null
        }
        catch (e: Exception) { // Captura genérica para otros errores
            Log.e(TAG, getString(R.string.log_unexpected_error_get_bytes, uri.toString()), e)
            showToast(getString(R.string.upload_file_error_message, e.localizedMessage ?: getString(R.string.unknown_error)))
            return null
        }
    }

    // --- Implementación de AudioRecordListener ---
    override fun onAudioRecorded(uri: Uri?, originalFileName: String?) {
        Log.i(TAG, getString(R.string.log_audio_recorded_received, uri.toString(), originalFileName))
        recordedAudioUri = uri
        recordedAudioOriginalName = originalFileName
        if (uri != null) { // Si se grabó un audio, limpiar el adjunto
            attachedAudioUri = null
            attachedAudioOriginalName = null
            getFragmentAtIndex<AttachAudioFragment>(2)?.resetState() // Notificar al fragmento de adjuntar
            Log.d(TAG, getString(R.string.log_attached_audio_reset_due_to_new_recording))
        }
        updateAudioWarningVisibility()
    }

    override fun onRecordingStateChanged(isRecording: Boolean) {
        Log.i(TAG, getString(R.string.log_recording_state_changed, isRecording.toString()))
        val attachAudioTab = binding.tabLayoutStoryInput.getTabAt(2) // Pestaña de Adjuntar Audio
        val writeStoryTab = binding.tabLayoutStoryInput.getTabAt(0) // Pestaña de Escribir Relato

        if (isRecording) {
            // Si se empieza a grabar, limpiar cualquier audio adjunto
            attachedAudioUri = null
            attachedAudioOriginalName = null
            getFragmentAtIndex<AttachAudioFragment>(2)?.resetState() // Notificar al fragmento de adjuntar
            Log.d(TAG, getString(R.string.log_attached_audio_reset_recording_started))

            // Deshabilitar otras pestañas durante la grabación
            attachAudioTab?.view?.isClickable = false
            attachAudioTab?.view?.alpha = 0.5f
            writeStoryTab?.view?.isClickable = false
            writeStoryTab?.view?.alpha = 0.5f
        } else {
            // Habilitar pestañas cuando la grabación no está activa
            attachAudioTab?.view?.isClickable = true
            attachAudioTab?.view?.alpha = 1.0f
            writeStoryTab?.view?.isClickable = true
            writeStoryTab?.view?.alpha = 1.0f
        }
        updateAudioWarningVisibility()
    }
    override fun onAudioDeleted() { // Desde RecordAudioFragment
        Log.i(TAG, getString(R.string.log_recorded_audio_deleted_from_fragment))
        recordedAudioUri = null
        recordedAudioOriginalName = null
        updateAudioWarningVisibility()
    }

    // --- Implementación de AudioAttachListener ---
    override fun onAudioAttached(uri: Uri?, originalFileName: String?) {
        Log.i(TAG, getString(R.string.log_audio_attached_received, uri.toString(), originalFileName))
        attachedAudioUri = uri
        attachedAudioOriginalName = originalFileName
        if (uri != null) { // Si se adjuntó un audio, limpiar el grabado
            recordedAudioUri = null
            recordedAudioOriginalName = null
            getFragmentAtIndex<RecordAudioFragment>(1)?.resetState() // Notificar al fragmento de grabar
            Log.d(TAG, getString(R.string.log_recorded_audio_reset_due_to_new_attachment))
        }
        updateAudioWarningVisibility()
    }
    override fun onAttachedAudioDeleted() { // Desde AttachAudioFragment
        Log.i(TAG, getString(R.string.log_attached_audio_deleted_from_fragment))
        attachedAudioUri = null
        attachedAudioOriginalName = null
        updateAudioWarningVisibility()
    }

    private fun updateAudioWarningVisibility() {
        val recordTab = binding.tabLayoutStoryInput.getTabAt(1) // Pestaña Grabar
        val attachTab = binding.tabLayoutStoryInput.getTabAt(2) // Pestaña Adjuntar

        val isCurrentlyRecording = getFragmentAtIndex<RecordAudioFragment>(1)?.isRecording ?: false

        if (isCurrentlyRecording) {
            binding.tvAudioSelectionWarning.text = getString(R.string.warning_recording_in_progress)
            binding.tvAudioSelectionWarning.isVisible = true
            attachTab?.view?.isClickable = false // Deshabilitar adjuntar mientras se graba
            attachTab?.view?.alpha = 0.5f
        } else if (recordedAudioUri != null) { // Hay un audio grabado, pero no se está grabando activamente
            binding.tvAudioSelectionWarning.text = getString(R.string.warning_recorded_audio_active)
            binding.tvAudioSelectionWarning.isVisible = true
            attachTab?.view?.isClickable = false // Deshabilitar adjuntar si hay audio grabado
            attachTab?.view?.alpha = 0.5f
            recordTab?.view?.isClickable = true // Permitir interactuar con la pestaña de grabación (para eliminarlo, etc.)
            recordTab?.view?.alpha = 1.0f
        } else if (attachedAudioUri != null) { // Hay un audio adjunto
            binding.tvAudioSelectionWarning.text = getString(R.string.warning_attached_audio_active)
            binding.tvAudioSelectionWarning.isVisible = true
            recordTab?.view?.isClickable = false // Deshabilitar grabar si hay audio adjunto
            recordTab?.view?.alpha = 0.5f
            attachTab?.view?.isClickable = true // Permitir interactuar con la pestaña de adjuntar
            attachTab?.view?.alpha = 1.0f
        } else { // No hay audio grabado ni adjunto, ni se está grabando
            binding.tvAudioSelectionWarning.isVisible = false
            recordTab?.view?.isClickable = true
            recordTab?.view?.alpha = 1.0f
            attachTab?.view?.isClickable = true
            attachTab?.view?.alpha = 1.0f
        }
        Log.d(TAG, getString(R.string.log_audio_warning_visibility_updated, isCurrentlyRecording.toString(), recordedAudioUri.toString(), attachedAudioUri.toString()))
    }

    // Helper para obtener fragmentos del ViewPager2
    internal inline fun <reified T : Fragment> getFragmentAtIndex(index: Int): T? {
        // El ViewPager2 crea fragmentos con un tag "f" + índice.
        val fragmentByTag = supportFragmentManager.findFragmentByTag("f$index")
        return if (fragmentByTag is T) {
            fragmentByTag
        } else {
            // Registrar si el fragmento no es del tipo esperado o no se encuentra
            if (fragmentByTag != null) {
                Log.e(TAG, getString(R.string.log_error_fragment_type_mismatch, index.toString(), T::class.java.simpleName, fragmentByTag.javaClass.simpleName))
            } else {
                Log.w(TAG, getString(R.string.log_warning_fragment_not_found_by_tag, index.toString(), "f$index"))
            }
            null
        }
    }

    // Definición de showAlertDialog para esta actividad (si no está ya en una clase base o helper)
    private fun showAlertDialog(title: String, message: String) {
        if (isFinishing || isDestroyed) { // Evitar mostrar diálogo si la actividad está finalizando
            Log.w(TAG, getString(R.string.log_activity_finishing_dialog_not_shown_story_alert))
            return
        }
        AlertDialog.Builder(this)
            .setTitle(title)
            .setMessage(message)
            .setPositiveButton(getString(R.string.dialog_ok), null) // Usar string resource
            .show()
    }
}


===== Archivo: app\src\main\java\com\example\mexicoparanormal\UploadVideoActivity.kt =====


package com.example.mexicoparanormal

import android.app.Activity
import android.content.ContentResolver
import android.content.Intent
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.graphics.Matrix
import androidx.exifinterface.media.ExifInterface
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.provider.OpenableColumns
import android.text.Editable
import android.text.TextWatcher
import android.util.Log
import android.util.Patterns
import android.view.View
import android.widget.*
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AlertDialog // Cambiado a androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
// import androidx.core.net.toUri // No se usa directamente
import androidx.core.view.isVisible
import com.cloudinary.android.MediaManager
import com.cloudinary.android.callback.ErrorInfo
import com.cloudinary.android.callback.UploadCallback
import com.example.mexicoparanormal.databinding.ActivityUploadVideoBinding
import com.google.android.material.textfield.TextInputLayout
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.firestore.FieldValue
import com.google.firebase.firestore.FirebaseFirestore
import java.io.ByteArrayOutputStream
import java.io.FileNotFoundException
import java.io.IOException
import java.io.InputStream
import java.text.ParseException
import java.text.SimpleDateFormat
import java.util.*
import kotlin.collections.HashMap
// import kotlin.math.max // No se usa directamente
import kotlin.math.roundToInt

class UploadVideoActivity : AppCompatActivity(), DialogCustomDatePicker.OnDateSelectedListener {
    private lateinit var binding: ActivityUploadVideoBinding
    private lateinit var auth: FirebaseAuth
    private lateinit var firestore: FirebaseFirestore
    private var videoUri: Uri? = null
    private var complementaryImageUri: Uri? = null
    private var isSubmitting = false

    private var selectedLatitude: Double? = null
    private var selectedLongitude: Double? = null
    private var selectedCityName: String? = null

    private lateinit var mapsActivityResultLauncher: ActivityResultLauncher<Intent>

    private var isPlaying = false // Para el reproductor de video
    private val MIN_YEAR_VIDEO = 1896 // Año mínimo para fecha de video
    private val dateFormatVideo = SimpleDateFormat("dd/MM/yyyy", Locale.getDefault())

    private var currentVideoUploadRequestId: String? = null
    private var currentComplementaryImageUploadRequestId: String? = null

    companion object {
        private const val TAG = "UploadVideoActivity"
        private const val MAX_VIDEO_FILE_SIZE_MB = 10 // MB
        private const val MAX_IMAGE_FILE_SIZE_MB = 10 // MB para imagen complementaria
    }


    private val selectVideoLauncher = registerForActivityResult(ActivityResultContracts.GetContent()) { uri: Uri? ->
        if (uri != null) {
            try {
                val contentResolver: ContentResolver = applicationContext.contentResolver
                val type = contentResolver.getType(uri)
                if (type != null && type.startsWith("video/")) {
                    val fileSize = getFileSize(uri, contentResolver)
                    val maxFileSizeInBytes = MAX_VIDEO_FILE_SIZE_MB * 1024 * 1024
                    if (fileSize > maxFileSizeInBytes) {
                        showToast(getString(R.string.error_audio_file_too_large_detailed, MAX_VIDEO_FILE_SIZE_MB, fileSize / (1024 * 1024)))
                        clearVideoSelection()
                        return@registerForActivityResult
                    }
                    videoUri = uri
                    binding.editTextAttachVideo.setText(getFileName(uri)) // Mostrar nombre del archivo
                    prepareVideoPreview(uri) // Preparar vista previa
                    Log.i(TAG, getString(R.string.log_video_selected, uri.toString(), binding.editTextAttachVideo.text))
                    showToast(getString(R.string.video_selected))
                } else {
                    Log.w(TAG, getString(R.string.log_invalid_file_type_for_video, uri.toString(), type))
                    showToast(getString(R.string.error_invalid_video_type))
                    clearVideoSelection()
                }
            } catch (e: SecurityException) {
                Log.e(TAG, getString(R.string.log_security_exception_validating_video, uri.toString()), e)
                showToast(getString(R.string.error_accessing_file_permission, uri.lastPathSegment ?: getString(R.string.selected_video_default_name)))
                clearVideoSelection()
            } catch (e: IllegalArgumentException) {
                Log.e(TAG, getString(R.string.log_illegal_argument_validating_video, uri.toString()), e)
                showToast(getString(R.string.error_invalid_video_type)) // Mensaje más genérico
                clearVideoSelection()
            } catch (e: Exception) {
                Log.e(TAG, getString(R.string.log_unexpected_error_validating_video, uri.toString()), e)
                showToast(getString(R.string.upload_file_error_message, e.localizedMessage ?: getString(R.string.unknown_error)))
                clearVideoSelection()
            }
        } else {
            Log.d(TAG, getString(R.string.log_video_selection_cancelled))
            showToast(getString(R.string.video_selection_cancelled))
            clearVideoSelection() // Asegurar que se limpia si el URI es nulo
        }
    }

    private val selectComplementaryImageLauncher = registerForActivityResult(ActivityResultContracts.GetContent()) { uri: Uri? ->
        if (uri != null) {
            try {
                val contentResolver: ContentResolver = applicationContext.contentResolver
                val type = contentResolver.getType(uri)
                val allowedMimeTypes = listOf("image/jpeg", "image/png", "image/jfif", "image/webp")

                if (type != null && allowedMimeTypes.contains(type.lowercase(Locale.getDefault()))) {
                    val fileSize = getFileSize(uri, contentResolver)
                    val maxFileSizeInBytes = MAX_IMAGE_FILE_SIZE_MB * 1024 * 1024
                    if (fileSize > maxFileSizeInBytes) {
                        showToast(getString(R.string.error_audio_file_too_large_detailed, MAX_IMAGE_FILE_SIZE_MB, fileSize / (1024*1024)))
                        clearComplementaryImageSelection()
                        return@registerForActivityResult
                    }
                    complementaryImageUri = uri
                    binding.imageViewCoverPreviewVideo.setImageURI(uri)
                    binding.imageViewCoverPreviewVideo.isVisible = true
                    binding.textViewCoverPreviewLabelVideo.isVisible = true
                    Log.i(TAG, getString(R.string.log_complementary_image_selected, uri.toString()))
                    showToast(getString(R.string.image_selection_successful))
                } else {
                    val allowedFormats = allowedMimeTypes.joinToString(", ") { it.substringAfter("/") }
                    Log.w(TAG, getString(R.string.log_invalid_file_type_complementary_image, uri.toString(), type))
                    showToast(getString(R.string.error_invalid_file_type_specific, allowedFormats))
                    clearComplementaryImageSelection()
                }
            } catch (e: SecurityException) {
                Log.e(TAG, getString(R.string.log_security_exception_validating_complementary_image, uri.toString()), e)
                showToast(getString(R.string.error_accessing_file_permission, uri.lastPathSegment ?: getString(R.string.selected_image_default_name)))
                clearComplementaryImageSelection()
            } catch (e: IllegalArgumentException) {
                Log.e(TAG, getString(R.string.log_illegal_argument_validating_complementary_image, uri.toString()), e)
                showToast(getString(R.string.error_invalid_file_type_specific, getString(R.string.unknown_format)))
                clearComplementaryImageSelection()
            } catch (e: Exception) {
                Log.e(TAG, getString(R.string.log_unexpected_error_validating_complementary_image, uri.toString()), e)
                showToast(getString(R.string.upload_file_error_message, e.localizedMessage ?: getString(R.string.unknown_error)))
                clearComplementaryImageSelection()
            }
        } else {
            Log.d(TAG, getString(R.string.log_complementary_image_selection_cancelled))
            showToast(getString(R.string.image_selection_cancelled))
            clearComplementaryImageSelection()
        }
    }


    private fun getFileName(uri: Uri): String {
        var name = getString(R.string.video_selected) // Nombre por defecto
        try {
            contentResolver.query(uri, arrayOf(OpenableColumns.DISPLAY_NAME), null, null, null)?.use { cursor ->
                if (cursor.moveToFirst()) {
                    val nameIndex = cursor.getColumnIndex(OpenableColumns.DISPLAY_NAME)
                    if (nameIndex != -1) {
                        name = cursor.getString(nameIndex)
                    }
                }
            }
        } catch (e: SecurityException) {
            Log.e(TAG, getString(R.string.log_security_exception_get_filename_video, uri.toString()), e)
            // No mostrar Toast aquí para no interrumpir el flujo si es un error menor
        } catch (e: IllegalArgumentException) {
            Log.e(TAG, getString(R.string.log_illegal_argument_get_filename_video, uri.toString()), e)
        } catch (e: Exception) {
            Log.e(TAG, getString(R.string.log_error_get_filename_video, uri.toString()), e)
        }
        return name
    }

    private fun getFileSize(uri: Uri, resolver: ContentResolver): Long {
        var size = 0L
        try {
            resolver.query(uri, arrayOf(OpenableColumns.SIZE), null, null, null)?.use { cursor ->
                if (cursor.moveToFirst()) {
                    val sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE)
                    if (sizeIndex != -1) size = cursor.getLong(sizeIndex)
                }
            }
        } catch (e: SecurityException) {
            Log.e(TAG, getString(R.string.log_security_exception_get_filesize_video, uri.toString()), e)
            showToast(getString(R.string.error_accessing_file_permission, uri.lastPathSegment ?: getString(R.string.default_file_name)))
        } catch (e: IllegalArgumentException) {
            Log.e(TAG, getString(R.string.log_illegal_argument_get_filesize_video, uri.toString()), e)
            showToast(getString(R.string.error_invalid_file_type_specific, getString(R.string.unknown_format)))
        }
        catch (e: Exception) {
            Log.e(TAG, getString(R.string.log_error_get_filesize_video, uri.toString()), e)
            showToast(getString(R.string.upload_file_error_message, e.localizedMessage ?: getString(R.string.unknown_error)))
        }
        return size
    }


    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityUploadVideoBinding.inflate(layoutInflater)
        setContentView(binding.root)

        auth = FirebaseAuth.getInstance()
        firestore = FirebaseFirestore.getInstance()
        dateFormatVideo.isLenient = false // Para validación estricta de fechas

        if (auth.currentUser == null) {
            Log.w(TAG, getString(R.string.log_user_not_authenticated_oncreate_video))
            Toast.makeText(this, getString(R.string.error_user_not_authenticated), Toast.LENGTH_LONG).show()
            finish()
            return
        }

        mapsActivityResultLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result ->
            if (result.resultCode == Activity.RESULT_OK) {
                result.data?.let { data ->
                    selectedLatitude = data.getDoubleExtra(getString(R.string.intent_extra_latitude_result), 0.0).takeIf { lat -> lat != 0.0 }
                    selectedLongitude = data.getDoubleExtra(getString(R.string.intent_extra_longitude_result), 0.0).takeIf { lon -> lon != 0.0 }
                    selectedCityName = data.getStringExtra(getString(R.string.intent_extra_cityname_result))
                    Log.i(TAG, getString(R.string.log_coordinates_received_video, selectedLatitude.toString(), selectedLongitude.toString(), selectedCityName))
                    actualizarUIcoordenadas()
                }
            } else {
                Log.d(TAG, getString(R.string.log_map_selection_cancelled_video))
            }
        }

        if (savedInstanceState != null) {
            selectedLatitude = savedInstanceState.getDouble("selectedLatitude", 0.0).takeIf { it != 0.0 }
            selectedLongitude = savedInstanceState.getDouble("selectedLongitude", 0.0).takeIf { it != 0.0 }
            selectedCityName = savedInstanceState.getString("selectedCityName")
            videoUri = savedInstanceState.getString("videoUriKey")?.let { Uri.parse(it) }
            complementaryImageUri = savedInstanceState.getString("complementaryImageUriKey")?.let { Uri.parse(it) }
            if (videoUri != null) {
                binding.editTextAttachVideo.setText(getFileName(videoUri!!))
                prepareVideoPreview(videoUri!!)
            }
            if (complementaryImageUri != null) {
                binding.imageViewCoverPreviewVideo.setImageURI(complementaryImageUri)
                binding.imageViewCoverPreviewVideo.isVisible = true
                binding.textViewCoverPreviewLabelVideo.isVisible = true
            }
            Log.d(TAG, getString(R.string.log_state_restored_upload_video, videoUri.toString(), complementaryImageUri.toString(), selectedLatitude.toString()))
        }

        setupUI()
        checkCloudinaryInitialization()
    }

    private fun setupUI() {
        setupTextWatchers()
        binding.btnBack.setOnClickListener { onBackPressedDispatcher.onBackPressed() }
        binding.infoIconDateLabel.setOnClickListener { if (it.isEnabled) showDateFormatInfoDialog() }
        setupLocationSpinner()
        binding.editTextAttachVideo.setOnClickListener { if (it.isEnabled) selectVideoLauncher.launch("video/*") }
        binding.btnSelectCoverImageVideo.setOnClickListener { if (it.isEnabled) selectComplementaryImageLauncher.launch("image/*") }
        setupVideoPlayerControls()
        setupDateSelection()
        binding.btnBorrarTodoVideo.setOnClickListener { clearAllFields() }
        binding.btnEnviarVideo.setOnClickListener { processVideoSubmission() }
        setupCoordinatesSection()
        setupUploadCancelButton()


        // Visibilidad inicial de los campos
        binding.textInputLayoutYear.isVisible = false
        binding.textInputLayoutExactDate.isVisible = false
        binding.dateRangeLayout.isVisible = false
        binding.dateInputFieldsContainer.isVisible = false
        binding.videoPreviewContainer.isVisible = false // Contenedor de VideoView
        binding.imageViewCoverPreviewVideo.isVisible = false // Vista previa de imagen complementaria
        binding.textViewCoverPreviewLabelVideo.isVisible = false // Etiqueta de vista previa de imagen
        binding.uploadProgressOverlayVideo.isVisible = false // Overlay de progreso
        binding.mapSelectionContainer.isVisible = binding.switchCoordinates.isChecked
        actualizarUIcoordenadas()
    }

    private fun checkCloudinaryInitialization() {
        try {
            if (MediaManager.get().cloudinary == null) {
                Log.e(TAG, getString(R.string.log_error_cloudinary_not_configured_video))
                Toast.makeText(this, getString(R.string.cloudinary_config_error), Toast.LENGTH_LONG).show()
                binding.btnEnviarVideo.isEnabled = false // Deshabilitar botón de envío
            }
        } catch (e: IllegalStateException) {
            Log.e(TAG, getString(R.string.log_error_cloudinary_not_initialized_video), e)
            Toast.makeText(this, getString(R.string.cloudinary_init_error), Toast.LENGTH_LONG).show()
            binding.btnEnviarVideo.isEnabled = false
        } catch (e: Exception) {
            Log.e(TAG, getString(R.string.log_error_cloudinary_unknown_check_video), e)
            Toast.makeText(this, getString(R.string.cloudinary_check_error), Toast.LENGTH_LONG).show()
            binding.btnEnviarVideo.isEnabled = false
        }
    }

    private fun setupUploadCancelButton() {
        binding.btnCancelUploadVideo.setOnClickListener {
            currentVideoUploadRequestId?.let { reqId ->
                try {
                    MediaManager.get().cancelRequest(reqId)
                    Log.i(TAG, getString(R.string.log_video_upload_cancellation_sent, reqId))
                } catch (e: Exception) {
                    Log.e(TAG, getString(R.string.log_error_cancelling_video_upload, reqId), e)
                }
            }
            currentComplementaryImageUploadRequestId?.let { reqId ->
                try {
                    MediaManager.get().cancelRequest(reqId)
                    Log.i(TAG, getString(R.string.log_complementary_image_upload_cancellation_sent, reqId))
                } catch (e: Exception) {
                    Log.e(TAG, getString(R.string.log_error_cancelling_complementary_image_upload, reqId), e)
                }
            }
            handleUploadError(getString(R.string.upload_cancelled)) // Mensaje genérico de cancelación
        }
    }

    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        selectedLatitude?.let { outState.putDouble("selectedLatitude", it) }
        selectedLongitude?.let { outState.putDouble("selectedLongitude", it) }
        outState.putString("selectedCityName", selectedCityName)
        videoUri?.let { outState.putString("videoUriKey", it.toString()) }
        complementaryImageUri?.let { outState.putString("complementaryImageUriKey", it.toString()) }
    }

    private fun setupLocationSpinner() {
        val locations = resources.getStringArray(R.array.locations_array)
        val adapter = ArrayAdapter(this, R.layout.spinner_item, locations)
        adapter.setDropDownViewResource(R.layout.spinner_dropdown_item)
        binding.spinnerLocation.adapter = adapter
        binding.spinnerLocation.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
            override fun onItemSelected(parent: AdapterView<*>?, view: View?, position: Int, id: Long) {
                if (position <= 1) { // "Seleccione una ubicación" o "desconocido"
                    if (binding.switchCoordinates.isChecked) {
                        binding.switchCoordinates.isChecked = false // Desactivar si se selecciona opción inválida
                    } else {
                        binding.mapSelectionContainer.isVisible = false // Si ya estaba desactivado, solo ocultar
                        resetCoordinates()
                    }
                }
            }
            override fun onNothingSelected(p0: AdapterView<*>?) { /* No se necesita acción */ }
        }
    }

    private fun setupCoordinatesSection() {
        binding.switchCoordinates.setOnCheckedChangeListener { _, isChecked ->
            if (isChecked) {
                if (binding.spinnerLocation.selectedItemPosition <= 1) { // No permitir si no hay estado válido
                    showToast(getString(R.string.error_select_state_first))
                    binding.switchCoordinates.isChecked = false // Revertir el switch
                    return@setOnCheckedChangeListener
                }
                binding.mapSelectionContainer.isVisible = true
            } else {
                binding.mapSelectionContainer.isVisible = false
                resetCoordinates() // Limpiar coordenadas si se apaga el switch
            }
            actualizarUIcoordenadas() // Actualizar la UI en ambos casos
        }

        binding.textViewSelectCoordinates.setOnClickListener {
            if (binding.spinnerLocation.selectedItemPosition > 1) { // Solo si hay un estado válido seleccionado
                openMapForSelection()
            } else {
                showToast(getString(R.string.error_select_state_first))
            }
        }
        binding.btnEditCoordinates.setOnClickListener {
            if (binding.spinnerLocation.selectedItemPosition > 1) { // Solo si hay un estado válido seleccionado
                openMapForSelection()
            }
            // No es necesario un 'else' aquí si el botón solo es visible cuando hay un estado
        }
    }

    private fun openMapForSelection() {
        val intent = Intent(this, MapsActivity::class.java).apply {
            putExtra(getString(R.string.intent_extra_selected_state), binding.spinnerLocation.selectedItem.toString())
            selectedLatitude?.let { putExtra(getString(R.string.intent_extra_latitude), it) }
            selectedLongitude?.let { putExtra(getString(R.string.intent_extra_longitude), it) }
        }
        mapsActivityResultLauncher.launch(intent)
    }


    private fun actualizarUIcoordenadas() {
        val coordinatesAvailable = selectedLatitude != null && selectedLongitude != null
        val switchIsOn = binding.switchCoordinates.isChecked

        if (switchIsOn) {
            binding.mapSelectionContainer.isVisible = true // Asegurar que el contenedor sea visible si el switch está ON
            if (coordinatesAvailable) {
                binding.textViewSelectedCoordinates.text = getString(R.string.selected_coordinates_format, selectedLatitude, selectedLongitude)
                binding.textViewSelectedCoordinates.isVisible = true
                binding.textViewCityName.text = selectedCityName ?: ""
                binding.textViewCityName.isVisible = !selectedCityName.isNullOrEmpty()
                binding.btnEditCoordinates.isVisible = true
                binding.textViewSelectCoordinates.isVisible = false
            } else {
                binding.textViewSelectedCoordinates.isVisible = false
                binding.textViewCityName.isVisible = false
                binding.btnEditCoordinates.isVisible = false
                binding.textViewSelectCoordinates.isVisible = true
            }
        } else {
            binding.mapSelectionContainer.isVisible = false // Ocultar si el switch está OFF
        }
    }

    private fun resetCoordinates() {
        selectedLatitude = null
        selectedLongitude = null
        selectedCityName = null
        actualizarUIcoordenadas() // Actualizar la UI para reflejar el reseteo
    }

    private fun prepareVideoPreview(uri: Uri) {
        binding.videoPreviewContainer.isVisible = true
        binding.videoViewPreview.setVideoURI(uri)
        binding.videoViewPreview.setOnPreparedListener { mp ->
            mp.isLooping = false // No hacer loop por defecto
            binding.btnPlay.isEnabled = true // Habilitar play una vez preparado
            updatePlayPauseButtons() // Actualizar UI de botones
        }
        binding.videoViewPreview.setOnErrorListener { _, what, extra ->
            Log.e(TAG, getString(R.string.log_error_loading_video_preview, uri.toString(), what.toString(), extra.toString()))
            showToast(getString(R.string.error_loading_video_preview))
            clearVideoSelection() // Limpiar si hay error
            true // Indicar que el error fue manejado
        }
        binding.btnPlay.isEnabled = false // Deshabilitar play hasta que esté preparado
        updatePlayPauseButtons() // Actualizar UI
    }


    private fun setupVideoPlayerControls() {
        binding.btnCloseVideo.setOnClickListener { clearVideoSelection() } // Botón para cerrar/limpiar video
        binding.btnPlay.setOnClickListener {
            if (videoUri != null && binding.videoViewPreview.duration > 0) { // Asegurar que hay video y está preparado
                binding.videoViewPreview.start()
                isPlaying = true
                updatePlayPauseButtons()
            } else if (videoUri != null) { // Si hay URI pero no está preparado, intentar prepararlo
                prepareVideoPreview(videoUri!!)
            } else {
                Log.w(TAG, getString(R.string.log_play_button_clicked_video_uri_null))
            }
        }
        binding.btnPause.setOnClickListener {
            if (isPlaying && binding.videoViewPreview.isPlaying) {
                binding.videoViewPreview.pause()
                isPlaying = false
                updatePlayPauseButtons()
            }
        }
        binding.btnStop.setOnClickListener {
            if (videoUri != null) { // Solo si hay un video cargado
                binding.videoViewPreview.stopPlayback() // Detener reproducción
                binding.videoViewPreview.setVideoURI(videoUri) // Recargar el URI para reiniciar
                binding.videoViewPreview.seekTo(0) // Ir al inicio
                isPlaying = false
                updatePlayPauseButtons()
            }
        }
        binding.videoViewPreview.setOnCompletionListener { // Cuando el video termina
            isPlaying = false
            updatePlayPauseButtons()
            binding.videoViewPreview.seekTo(0) // Volver al inicio
        }
    }

    private fun updatePlayPauseButtons() {
        val videoIsPrepared = videoUri != null && binding.videoViewPreview.duration > 0

        binding.btnPlay.isVisible = !isPlaying
        binding.btnPause.isVisible = isPlaying
        binding.btnStop.isVisible = (isPlaying || binding.videoViewPreview.currentPosition > 0) // Mostrar stop si está reproduciendo o pausado no al inicio

        // Habilitar botones solo si el video está preparado
        binding.btnPlay.isEnabled = videoIsPrepared && !isPlaying
        binding.btnPause.isEnabled = videoIsPrepared && isPlaying
        binding.btnStop.isEnabled = videoIsPrepared && (isPlaying || binding.videoViewPreview.currentPosition > 0)
    }


    private fun setupDateSelection() {
        binding.radioGroupDateType.setOnCheckedChangeListener { _, checkedId ->
            binding.textInputLayoutYear.isVisible = false
            binding.textInputLayoutExactDate.isVisible = false
            binding.dateRangeLayout.isVisible = false
            binding.dateInputFieldsContainer.isVisible = true // Mostrar contenedor de campos de fecha

            if (checkedId != -1) binding.radioUnknown.isChecked = false // Desmarcar "Desconocido" si se selecciona otro
            clearDateErrors() // Limpiar errores al cambiar tipo

            when (checkedId) {
                R.id.radioYear -> binding.textInputLayoutYear.isVisible = true
                R.id.radioExactDate -> binding.textInputLayoutExactDate.isVisible = true
                R.id.radioDateRange -> binding.dateRangeLayout.isVisible = true
                else -> binding.dateInputFieldsContainer.isVisible = false // Ocultar si no hay nada seleccionado
            }
        }
        binding.radioUnknown.setOnCheckedChangeListener { _, isChecked ->
            if (isChecked) {
                binding.radioGroupDateType.clearCheck() // Desmarcar otros tipos de fecha
                binding.textInputLayoutYear.isVisible = false
                binding.textInputLayoutExactDate.isVisible = false
                binding.dateRangeLayout.isVisible = false
                binding.dateInputFieldsContainer.isVisible = false // Ocultar contenedor
                clearDateFields() // Limpiar campos de fecha
                clearDateErrors() // Limpiar errores
            }
        }
        binding.editTextExactDate.setOnClickListener { if (it.isEnabled) showCustomDatePickerVideoFragment() }

        // Asegurar visibilidad inicial correcta basada en el estado guardado o por defecto
        val initiallyCheckedId = binding.radioGroupDateType.checkedRadioButtonId
        if (initiallyCheckedId != -1) {
            binding.dateInputFieldsContainer.isVisible = true
            when (initiallyCheckedId) {
                R.id.radioYear -> binding.textInputLayoutYear.isVisible = true
                R.id.radioExactDate -> binding.textInputLayoutExactDate.isVisible = true
                R.id.radioDateRange -> binding.dateRangeLayout.isVisible = true
            }
        } else if (binding.radioUnknown.isChecked) {
            binding.dateInputFieldsContainer.isVisible = false
        } else {
            // Por defecto, si nada está seleccionado, el contenedor de campos de fecha debería estar oculto
            binding.dateInputFieldsContainer.isVisible = false
        }
    }

    private fun clearDateErrors() {
        binding.textInputLayoutYear.error = null
        binding.textInputLayoutExactDate.error = null
        binding.textInputLayoutStartYear.error = null
        binding.textInputLayoutEndYear.error = null
        binding.textDateMessage.isVisible = false // Ocultar mensaje de error de fecha
    }

    private fun showCustomDatePickerVideoFragment() {
        val cal = Calendar.getInstance()
        var currentDay = cal.get(Calendar.DAY_OF_MONTH)
        var currentMonth = cal.get(Calendar.MONTH) // 0-11
        var currentYear = cal.get(Calendar.YEAR)

        val dateStr = binding.editTextExactDate.text.toString()
        if (dateStr.isNotEmpty()) {
            try {
                val date = dateFormatVideo.parse(dateStr)
                date?.let {
                    val selectedCal = Calendar.getInstance().apply { time = it }
                    currentDay = selectedCal.get(Calendar.DAY_OF_MONTH)
                    currentMonth = selectedCal.get(Calendar.MONTH)
                    currentYear = selectedCal.get(Calendar.YEAR)
                }
            } catch (e: ParseException) {
                Log.w(TAG, getString(R.string.log_error_parsing_date_datepicker_video, dateStr), e)
                // No es necesario mostrar un Toast aquí, el diálogo usará la fecha actual
            }
        }

        val dialog = DialogCustomDatePicker.newInstance(
            initialDay = currentDay,
            initialMonth = currentMonth,
            initialYear = currentYear,
            minYear = MIN_YEAR_VIDEO, // minYear específico para videos
            title = getString(R.string.dialog_title_video_date) // Título específico
        )
        dialog.show(supportFragmentManager, "customDatePickerVideoDialog")
    }


    override fun onDateSelected(day: Int, month: Int, year: Int) {
        val cal = Calendar.getInstance().apply { set(year, month, day, 0, 0, 0) } // Asegurar hora 00:00:00
        binding.editTextExactDate.setText(dateFormatVideo.format(cal.time))
        binding.textInputLayoutExactDate.error = null // Limpiar error al seleccionar
    }

    private fun clearVideoSelection() {
        videoUri = null
        binding.videoPreviewContainer.isVisible = false
        if (binding.videoViewPreview.isPlaying) {
            binding.videoViewPreview.stopPlayback()
        }
        binding.videoViewPreview.setVideoURI(null) // Limpiar URI del VideoView
        binding.editTextAttachVideo.setText("") // Limpiar el campo de texto
        isPlaying = false
        updatePlayPauseButtons() // Actualizar UI de botones
    }

    private fun clearComplementaryImageSelection() {
        complementaryImageUri = null
        binding.imageViewCoverPreviewVideo.setImageDrawable(null) // Limpiar la imagen
        binding.imageViewCoverPreviewVideo.isVisible = false
        binding.textViewCoverPreviewLabelVideo.isVisible = false
    }


    private fun clearAllFields() {
        binding.editTextVideoTitle.text?.clear()
        binding.textInputLayoutVideoTitle.error = null
        binding.editTextVideoDescription.text?.clear()
        binding.textInputLayoutVideoDescription.error = null
        binding.spinnerLocation.setSelection(0) // Resetear spinner
        binding.radioGroupDateType.clearCheck() // Limpiar selección de tipo de fecha
        binding.radioUnknown.isChecked = false // Desmarcar "Desconocido"
        clearDateFields() // Limpiar campos de fecha individuales
        clearVideoSelection() // Limpiar selección de video
        clearComplementaryImageSelection() // Limpiar selección de imagen complementaria
        binding.editTextYoutubeLink.text?.clear()
        binding.textInputLayoutYoutubeLink.error = null
        binding.switchCoordinates.isChecked = false // Resetear switch de coordenadas

        // Resetear estado de subida
        binding.uploadProgressOverlayVideo.isVisible = false
        setUiEnabled(true)
        isSubmitting = false
        currentVideoUploadRequestId = null
        currentComplementaryImageUploadRequestId = null
        Log.d(TAG, getString(R.string.log_all_fields_cleared_video))
    }

    private fun clearDateFields() {
        binding.editTextYear.text?.clear()
        binding.editTextExactDate.text?.clear()
        binding.editTextStartYear.text?.clear()
        binding.editTextEndYear.text?.clear()
        clearDateErrors() // También limpiar errores de fecha
    }

    private fun showDateFormatInfoDialog() {
        AlertDialog.Builder(this) // Usar androidx.appcompat.app.AlertDialog
            .setTitle(R.string.desc_info_date_format_title)
            .setMessage(R.string.desc_info_date_format_message)
            .setPositiveButton(R.string.dialog_positive_button_understood, null)
            .show()
    }

    private fun setupTextWatchers() {
        fun createWatcher(layout: TextInputLayout) = object : TextWatcher {
            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}
            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) { layout.error = null }
            override fun afterTextChanged(s: Editable?) {}
        }
        binding.editTextVideoTitle.addTextChangedListener(createWatcher(binding.textInputLayoutVideoTitle))
        binding.editTextVideoDescription.addTextChangedListener(createWatcher(binding.textInputLayoutVideoDescription))
        binding.editTextYoutubeLink.addTextChangedListener(createWatcher(binding.textInputLayoutYoutubeLink))
        binding.editTextYear.addTextChangedListener(createWatcher(binding.textInputLayoutYear))
        binding.editTextExactDate.addTextChangedListener(createWatcher(binding.textInputLayoutExactDate))
        binding.editTextStartYear.addTextChangedListener(createWatcher(binding.textInputLayoutStartYear))
        binding.editTextEndYear.addTextChangedListener(createWatcher(binding.textInputLayoutEndYear))
    }

    private fun processVideoSubmission() {
        if (isSubmitting) {
            Log.d(TAG, getString(R.string.log_submission_already_in_progress_video))
            return
        }

        if (!validateForm()) {
            Log.w(TAG, getString(R.string.log_form_not_valid_video))
            return
        }

        setUiEnabled(false) // Deshabilitar UI
        isSubmitting = true

        binding.uploadProgressOverlayVideo.isVisible = true
        binding.progressBarUploadVideo.progress = 0
        binding.textProgressVideo.text = getString(R.string.uploading_video_progress_percent, 0)

        val currentUser = auth.currentUser ?: run {
            Log.e(TAG, getString(R.string.log_error_user_not_authenticated_submission_video))
            handleUploadError(getString(R.string.error_user_not_authenticated))
            return
        }
        val userId = currentUser.uid

        firestore.collection(getString(R.string.firestore_collection_users)).document(userId).get()
            .addOnSuccessListener { userDocument ->
                val authorUsername = userDocument.getString(getString(R.string.firestore_field_username))?.takeIf { it.isNotEmpty() } ?: currentUser.displayName ?: getString(R.string.unknown_user)
                val authorProfileImageUrl = userDocument.getString(getString(R.string.firestore_field_profileImageUrl))?.takeIf { it.isNotEmpty() } ?: currentUser.photoUrl?.toString() ?: ""

                val videoTitle = binding.editTextVideoTitle.text.toString().trim()
                val videoDescription = binding.editTextVideoDescription.text.toString().trim()
                val location = binding.spinnerLocation.selectedItem.toString()
                val youtubeLink = binding.editTextYoutubeLink.text.toString().trim()
                val dateData = getDateFromInputs()

                val videoData = hashMapOf<String, Any?>(
                    getString(R.string.firestore_field_userId) to userId,
                    getString(R.string.firestore_field_authorUsername) to authorUsername,
                    getString(R.string.firestore_field_authorProfileImageUrl) to authorProfileImageUrl,
                    getString(R.string.firestore_field_title) to videoTitle,
                    getString(R.string.firestore_field_description) to videoDescription,
                    getString(R.string.firestore_field_type) to getString(R.string.content_type_video), // Tipo de contenido
                    getString(R.string.firestore_field_location) to location,
                    getString(R.string.firestore_field_date) to dateData, // Mapa de datos de fecha
                    getString(R.string.firestore_field_timestamp) to FieldValue.serverTimestamp(),
                    getString(R.string.firestore_field_status) to getString(R.string.status_pending_value), // Estado inicial
                    getString(R.string.firestore_field_isVisible) to false, // No visible hasta aprobación
                    getString(R.string.firestore_field_likes) to 0,
                    getString(R.string.firestore_field_commentsCount) to 0,
                    getString(R.string.firestore_field_youtubeLink) to if (youtubeLink.isNotEmpty()) youtubeLink else null,
                    getString(R.string.firestore_field_videoUrl) to null, // Se llenará después de subir a Cloudinary si aplica
                    getString(R.string.firestore_field_complementaryImageUrl) to null, // Se llenará si se sube imagen
                    getString(R.string.firestore_field_latitude) to selectedLatitude,
                    getString(R.string.firestore_field_longitude) to selectedLongitude,
                    getString(R.string.firestore_field_cityName) to selectedCityName,
                    getString(R.string.firestore_field_moderatedBy) to null,
                    getString(R.string.firestore_field_moderationTimestamp) to null,
                    getString(R.string.firestore_field_rejectionReason) to null
                )

                if (videoUri != null) {
                    Log.i(TAG, getString(R.string.log_starting_cloudinary_video_upload, videoUri.toString()))
                    uploadVideoAndProceed(videoUri!!, videoData)
                } else if (complementaryImageUri != null) { // Si no hay video local pero sí imagen complementaria (y hay link de YT)
                    Log.i(TAG, getString(R.string.log_starting_complementary_image_upload_no_local_video, complementaryImageUri.toString()))
                    uploadComplementaryImageAndSaveData(complementaryImageUri!!, videoData)
                } else if (youtubeLink.isNotEmpty()) { // Solo link de YouTube, sin video local ni imagen complementaria
                    Log.i(TAG, getString(R.string.log_saving_video_data_youtube_link_only, youtubeLink))
                    runOnUiThread { binding.textProgressVideo.text = getString(R.string.uploading_content_progress) } // Mensaje genérico
                    saveVideoDataToFirestore(videoData)
                } else {
                    // Este caso no debería ocurrir si validateForm() es correcto
                    Log.e(TAG, getString(R.string.log_error_no_video_source_after_validation))
                    handleUploadError(getString(R.string.error_no_video_source))
                }
            }
            .addOnFailureListener { e ->
                Log.e(TAG, getString(R.string.log_error_getting_user_data_for_authorship_video), e)
                handleUploadError(getString(R.string.submission_generic_error_message_upload) + getString(R.string.error_suffix_user_data_fetch))
            }
    }

    private fun validateForm(): Boolean {
        var isValid = true
        val videoTitle = binding.editTextVideoTitle.text.toString().trim()
        if (videoTitle.isBlank()) {
            binding.textInputLayoutVideoTitle.error = getString(R.string.error_video_title_required)
            isValid = false
        } else if (videoTitle.length > 37) { // Asumiendo que 37 es el límite
            binding.textInputLayoutVideoTitle.error = getString(R.string.error_title_length)
            isValid = false
        } else {
            binding.textInputLayoutVideoTitle.error = null
        }

        val videoDescription = binding.editTextVideoDescription.text.toString().trim()
        if (videoDescription.isBlank()) {
            binding.textInputLayoutVideoDescription.error = getString(R.string.error_video_description_required)
            isValid = false
        } else if (videoDescription.length > 666) { // Asumiendo que 666 es el límite
            binding.textInputLayoutVideoDescription.error = getString(R.string.error_description_length, 666)
            isValid = false
        } else {
            binding.textInputLayoutVideoDescription.error = null
        }

        if (binding.spinnerLocation.selectedItemPosition == 0) { // "Seleccione una ubicación"
            showToast(getString(R.string.error_location_required))
            isValid = false
        }

        val youtubeLink = binding.editTextYoutubeLink.text.toString().trim()
        if (videoUri == null && youtubeLink.isEmpty()) {
            showToast(getString(R.string.error_video_or_youtube_link_required))
            // Marcar ambos campos como requeridos visualmente si es posible
            binding.textInputLayoutAttachVideo.error = getString(R.string.error_field_required) // O un mensaje más específico
            binding.textInputLayoutYoutubeLink.error = getString(R.string.error_field_required) // O un mensaje más específico
            isValid = false
        } else if (videoUri != null && youtubeLink.isNotEmpty()) {
            showToast(getString(R.string.error_video_and_youtube_link_provided))
            isValid = false
        } else if (youtubeLink.isNotEmpty() && !Patterns.WEB_URL.matcher(youtubeLink).matches()) {
            binding.textInputLayoutYoutubeLink.error = getString(R.string.error_invalid_youtube_link)
            isValid = false
        } else {
            // Limpiar errores si la condición es válida
            binding.textInputLayoutAttachVideo.error = null
            binding.textInputLayoutYoutubeLink.error = null
        }

        if (!validateDateSelection()) isValid = false

        if (binding.switchCoordinates.isChecked && (selectedLatitude == null || selectedLongitude == null)) {
            showToast(getString(R.string.error_select_coordinates_on_map))
            isValid = false
        }
        return isValid
    }

    private fun validateDateSelection(): Boolean {
        var dateValid = true
        clearDateErrors() // Limpiar errores previos
        val checkedId = binding.radioGroupDateType.checkedRadioButtonId

        // Si no se ha seleccionado ningún tipo de fecha Y "Desconocido" no está marcado
        if (checkedId == -1 && !binding.radioUnknown.isChecked) {
            binding.textDateMessage.text = getString(R.string.error_select_date_type_or_unknown)
            binding.textDateMessage.isVisible = true
            return false // No es válido si no se selecciona nada
        }
        // Si "Desconocido" está marcado, es válido
        if (binding.radioUnknown.isChecked) return true

        // Validaciones para los tipos de fecha específicos
        val currentYear = Calendar.getInstance().get(Calendar.YEAR)
        val minDateCalVideo = Calendar.getInstance().apply { set(MIN_YEAR_VIDEO, Calendar.JANUARY, 1,0,0,0) } // Para comparación


        when (checkedId) {
            R.id.radioYear -> {
                val yearStr = binding.editTextYear.text.toString()
                val year = yearStr.toIntOrNull()
                if (yearStr.isEmpty() || year == null || year < MIN_YEAR_VIDEO || year > currentYear) {
                    binding.textInputLayoutYear.error = getString(R.string.error_invalid_year_range_simple, MIN_YEAR_VIDEO, currentYear)
                    dateValid = false
                }
            }
            R.id.radioExactDate -> {
                val dateStr = binding.editTextExactDate.text.toString()
                if (dateStr.isEmpty()) {
                    binding.textInputLayoutExactDate.error = getString(R.string.error_select_exact_date)
                    dateValid = false
                } else {
                    try {
                        val date = dateFormatVideo.parse(dateStr) // dateFormatVideo ya es lenient = false
                        val selectedCal = Calendar.getInstance().apply { time = date!! ; set(Calendar.HOUR_OF_DAY,0); set(Calendar.MINUTE,0); set(Calendar.SECOND,0); set(Calendar.MILLISECOND,0) }
                        val todayCal = Calendar.getInstance().apply {set(Calendar.HOUR_OF_DAY,0); set(Calendar.MINUTE,0); set(Calendar.SECOND,0); set(Calendar.MILLISECOND,0) }

                        if (selectedCal.before(minDateCalVideo) || selectedCal.after(todayCal)) {
                            binding.textInputLayoutExactDate.error = getString(R.string.error_invalid_date_range, dateFormatVideo.format(minDateCalVideo.time), dateFormatVideo.format(todayCal.time))
                            dateValid = false
                        }
                    } catch (e: ParseException) {
                        binding.textInputLayoutExactDate.error = getString(R.string.error_invalid_date_format)
                        dateValid = false
                    }
                }
            }
            R.id.radioDateRange -> {
                val startYearStr = binding.editTextStartYear.text.toString()
                val endYearStr = binding.editTextEndYear.text.toString()
                val startYear = startYearStr.toIntOrNull()
                val endYear = endYearStr.toIntOrNull()

                var individualYearsValid = true
                if (startYearStr.isEmpty() || startYear == null || startYear < MIN_YEAR_VIDEO || startYear > currentYear) {
                    binding.textInputLayoutStartYear.error = getString(R.string.error_invalid_year_range_simple, MIN_YEAR_VIDEO, currentYear)
                    individualYearsValid = false
                }
                if (endYearStr.isEmpty() || endYear == null || endYear < MIN_YEAR_VIDEO || endYear > currentYear) {
                    binding.textInputLayoutEndYear.error = getString(R.string.error_invalid_year_range_simple, MIN_YEAR_VIDEO, currentYear)
                    individualYearsValid = false
                }

                if (individualYearsValid && startYear != null && endYear != null && startYear > endYear) {
                    binding.textInputLayoutStartYear.error = getString(R.string.error_year_range_order)
                    binding.textInputLayoutEndYear.error = getString(R.string.error_year_range_order) // Mostrar error en ambos
                    dateValid = false
                } else if (!individualYearsValid) { // Si alguno de los años individuales no es válido
                    dateValid = false
                }
            }
        }
        if (!dateValid) { // Si alguna validación falló, mostrar mensaje general
            binding.textDateMessage.text = getString(R.string.error_correct_date_errors)
            binding.textDateMessage.isVisible = true
        }
        return dateValid
    }

    private fun getDateFromInputs(): Map<String, Any?> {
        val dateMap = mutableMapOf<String, Any?>()
        if (binding.radioUnknown.isChecked) {
            dateMap[getString(R.string.firestore_field_date_type)] = getString(R.string.date_type_value_unknown)
            dateMap[getString(R.string.firestore_field_date_value)] = getString(R.string.date_type_unknown) // Valor textual para "Desconocido"
        } else {
            when (binding.radioGroupDateType.checkedRadioButtonId) {
                R.id.radioYear -> {
                    dateMap[getString(R.string.firestore_field_date_type)] = getString(R.string.date_type_value_year)
                    dateMap[getString(R.string.firestore_field_date_value)] = binding.editTextYear.text.toString().toIntOrNull()
                }
                R.id.radioExactDate -> {
                    dateMap[getString(R.string.firestore_field_date_type)] = getString(R.string.date_type_value_exact)
                    dateMap[getString(R.string.firestore_field_date_value)] = binding.editTextExactDate.text.toString() // Guardar como String dd/MM/yyyy
                }
                R.id.radioDateRange -> {
                    dateMap[getString(R.string.firestore_field_date_type)] = getString(R.string.date_type_value_range)
                    dateMap[getString(R.string.firestore_field_date_startYear)] = binding.editTextStartYear.text.toString().toIntOrNull()
                    dateMap[getString(R.string.firestore_field_date_endYear)] = binding.editTextEndYear.text.toString().toIntOrNull()
                }
                else -> dateMap[getString(R.string.firestore_field_date_type)] = getString(R.string.date_type_value_none) // Caso por defecto
            }
        }
        return dateMap
    }

    private fun uploadVideoAndProceed(videoUriToUpload: Uri, videoData: HashMap<String, Any?>) {
        runOnUiThread { binding.textProgressVideo.text = getString(R.string.uploading_video_progress_percent, 0) }
        val videoBytes = getVideoByteArray(videoUriToUpload) ?: run {
            Log.e(TAG, getString(R.string.log_error_getting_bytes_from_video_uri, videoUriToUpload.toString()))
            handleUploadError(getString(R.string.error_reading_video_file))
            return
        }
        val options = HashMap<String, Any>().apply {
            put(getString(R.string.cloudinary_option_folder), getString(R.string.cloudinary_folder_video_uploads, videoData[getString(R.string.firestore_field_userId)]))
            put(getString(R.string.cloudinary_option_public_id), getString(R.string.cloudinary_public_id_video_prefix) + System.currentTimeMillis() + "_" + UUID.randomUUID())
            put(getString(R.string.cloudinary_option_resource_type), getString(R.string.cloudinary_resource_type_video)) // Importante para Cloudinary
        }

        currentVideoUploadRequestId = MediaManager.get().upload(videoBytes)
            .options(options)
            .callback(object : UploadCallback {
                override fun onStart(requestId: String?) { Log.i(TAG, getString(R.string.log_cloudinary_video_upload_started, requestId)) }
                override fun onProgress(requestId: String?, bytes: Long, totalBytes: Long) {
                    val progress = if (totalBytes > 0) (bytes.toDouble() / totalBytes * 100).toInt() else 0
                    runOnUiThread {
                        binding.progressBarUploadVideo.progress = progress
                        binding.textProgressVideo.text = getString(R.string.uploading_video_progress_percent, progress)
                    }
                }
                override fun onSuccess(requestId: String?, resultData: MutableMap<Any?, Any?>?) {
                    currentVideoUploadRequestId = null
                    val url = resultData?.get(getString(R.string.cloudinary_result_secure_url)) as? String
                    if (url != null) {
                        Log.i(TAG, getString(R.string.log_cloudinary_video_upload_success, url))
                        videoData[getString(R.string.firestore_field_videoUrl)] = url
                        if (complementaryImageUri != null) { // Si hay imagen complementaria, subirla ahora
                            uploadComplementaryImageAndSaveData(complementaryImageUri!!, videoData)
                        } else { // Si no, guardar datos directamente
                            runOnUiThread { binding.textProgressVideo.text = getString(R.string.uploading_content_progress) }
                            saveVideoDataToFirestore(videoData)
                        }
                    } else {
                        Log.e(TAG, getString(R.string.log_error_cloudinary_video_url_null))
                        handleUploadError(getString(R.string.submission_generic_error_message_upload) + getString(R.string.error_suffix_cloudinary_video_url_null))
                    }
                }
                override fun onError(requestId: String?, error: ErrorInfo?) {
                    currentVideoUploadRequestId = null
                    val errorMessage = error?.description ?: getString(R.string.error_unknown_upload)
                    Log.e(TAG, getString(R.string.log_error_cloudinary_video_upload, requestId, errorMessage, error?.code.toString()))
                    if (error?.code == ErrorInfo.REQUEST_CANCELLED) {
                        handleUploadError(getString(R.string.upload_cancelled) + getString(R.string.error_suffix_video_upload))
                    } else {
                        handleUploadError(getString(R.string.upload_error_prefix,errorMessage) + getString(R.string.error_suffix_video_upload))
                    }
                }
                override fun onReschedule(requestId: String?, error: ErrorInfo?) {
                    currentVideoUploadRequestId = null
                    Log.w(TAG, getString(R.string.log_cloudinary_video_upload_rescheduled, requestId, error?.description, error?.code.toString()))
                    handleUploadError(getString(R.string.error_unknown_upload) + getString(R.string.error_suffix_upload_rescheduled_video, error?.description))
                }
            })
            .dispatch()
    }

    private fun uploadComplementaryImageAndSaveData(imageUriToUpload: Uri, videoData: HashMap<String, Any?>) {
        runOnUiThread { binding.textProgressVideo.text = getString(R.string.uploading_image_progress_percent, 0) } // Actualizar texto de progreso

        val imageBytes = compressImageToWebP(imageUriToUpload, 70, 1280) ?: run {
            Log.e(TAG, getString(R.string.log_error_compressing_complementary_image_uri, imageUriToUpload.toString()))
            handleUploadError(getString(R.string.error_image_compression_failed) + getString(R.string.error_suffix_complementary_image))
            // Si falla la imagen complementaria pero el video ya se subió (o es un link de YT), intentar guardar sin la imagen
            if (videoData[getString(R.string.firestore_field_videoUrl)] != null || videoData[getString(R.string.firestore_field_youtubeLink)] != null) {
                Log.w(TAG, getString(R.string.log_complementary_image_compression_failed_saving_video_data_without_it))
                runOnUiThread { binding.textProgressVideo.text = getString(R.string.uploading_content_progress) }
                saveVideoDataToFirestore(videoData) // Guardar sin complementaryImageUrl
            }
            return
        }

        val options = HashMap<String, Any>().apply {
            put(getString(R.string.cloudinary_option_folder), getString(R.string.cloudinary_folder_video_complementary_images, videoData[getString(R.string.firestore_field_userId)]))
            put(getString(R.string.cloudinary_option_public_id), getString(R.string.cloudinary_public_id_video_comp_img_prefix) + System.currentTimeMillis() + "_" + UUID.randomUUID())
            put(getString(R.string.cloudinary_option_resource_type), getString(R.string.cloudinary_resource_type_image))
        }

        currentComplementaryImageUploadRequestId = MediaManager.get().upload(imageBytes)
            .options(options)
            .callback(object : UploadCallback {
                override fun onStart(requestId: String?) { Log.i(TAG, getString(R.string.log_cloudinary_complementary_image_upload_started, requestId)) }
                override fun onProgress(requestId: String?, bytes: Long, totalBytes: Long) {
                    val progress = if (totalBytes > 0) (bytes.toDouble() / totalBytes * 100).toInt() else 0
                    runOnUiThread {
                        binding.progressBarUploadVideo.progress = progress // Usar la misma barra de progreso
                        binding.textProgressVideo.text = getString(R.string.uploading_image_progress_percent, progress)
                    }
                }
                override fun onSuccess(requestId: String?, resultData: MutableMap<Any?, Any?>?) {
                    currentComplementaryImageUploadRequestId = null
                    val url = resultData?.get(getString(R.string.cloudinary_result_secure_url)) as? String
                    if (url != null) {
                        Log.i(TAG, getString(R.string.log_cloudinary_complementary_image_upload_success, url))
                        videoData[getString(R.string.firestore_field_complementaryImageUrl)] = url
                    } else {
                        Log.w(TAG, getString(R.string.log_cloudinary_complementary_image_url_null))
                        // videoData["complementaryImageUrl"] permanecerá null
                    }
                    runOnUiThread { binding.textProgressVideo.text = getString(R.string.uploading_content_progress) }
                    saveVideoDataToFirestore(videoData) // Guardar datos del video (con o sin URL de imagen complementaria)
                }
                override fun onError(requestId: String?, error: ErrorInfo?) {
                    currentComplementaryImageUploadRequestId = null
                    val errorMessage = error?.description ?: getString(R.string.error_unknown_upload)
                    Log.e(TAG, getString(R.string.log_error_cloudinary_complementary_image_upload, requestId, errorMessage, error?.code.toString()))
                    // Si la imagen complementaria falla, igual intentamos guardar el video si ya se subió o es un link de YT
                    if (error?.code == ErrorInfo.REQUEST_CANCELLED) {
                        if (videoData[getString(R.string.firestore_field_videoUrl)] != null || videoData[getString(R.string.firestore_field_youtubeLink)] != null) {
                            Log.w(TAG, getString(R.string.log_complementary_image_upload_cancelled_saving_video_data))
                            runOnUiThread { binding.textProgressVideo.text = getString(R.string.uploading_content_progress) }
                            saveVideoDataToFirestore(videoData)
                        } else {
                            handleUploadError(getString(R.string.upload_cancelled) + getString(R.string.error_suffix_complementary_image_upload))
                        }
                    } else {
                        Log.e(TAG, getString(R.string.log_error_uploading_complementary_image_saving_without_it, errorMessage))
                        if (videoData[getString(R.string.firestore_field_videoUrl)] != null || videoData[getString(R.string.firestore_field_youtubeLink)] != null) {
                            runOnUiThread { binding.textProgressVideo.text = getString(R.string.uploading_content_progress) }
                            saveVideoDataToFirestore(videoData)
                        } else {
                            handleUploadError(getString(R.string.upload_error_prefix, errorMessage) + getString(R.string.error_suffix_complementary_image_upload))
                        }
                    }
                }
                override fun onReschedule(requestId: String?, error: ErrorInfo?) {
                    currentComplementaryImageUploadRequestId = null
                    Log.w(TAG, getString(R.string.log_cloudinary_complementary_image_upload_rescheduled, requestId, error?.description, error?.code.toString()))
                    // Tratar como un error y guardar sin la imagen si es posible
                    if (videoData[getString(R.string.firestore_field_videoUrl)] != null || videoData[getString(R.string.firestore_field_youtubeLink)] != null) {
                        runOnUiThread { binding.textProgressVideo.text = getString(R.string.uploading_content_progress) }
                        saveVideoDataToFirestore(videoData)
                    } else {
                        handleUploadError(getString(R.string.error_unknown_upload) + getString(R.string.error_suffix_upload_rescheduled_comp_image, error?.description))
                    }
                }
            })
            .dispatch()
    }


    private fun getVideoByteArray(uri: Uri): ByteArray? {
        try {
            contentResolver.openInputStream(uri)?.use { inputStream ->
                ByteArrayOutputStream().use { outputStream ->
                    inputStream.copyTo(outputStream)
                    return outputStream.toByteArray()
                }
            } ?: run { // Si openInputStream devuelve null
                Log.e(TAG, getString(R.string.log_error_inputstream_null_for_uri_video, uri.toString()))
                return null
            }
        } catch (fnfe: FileNotFoundException) {
            Log.e(TAG, getString(R.string.log_error_file_not_found_get_video_bytes, uri.toString()), fnfe)
            showToast(getString(R.string.error_file_not_found_for_compression, uri.lastPathSegment ?: getString(R.string.selected_video_default_name)))
            return null
        } catch (ioe: IOException) {
            Log.e(TAG, getString(R.string.log_error_io_get_video_bytes, uri.toString()), ioe)
            showToast(getString(R.string.error_io_compressing_image)) // Reutilizar string de imagen si es genérico
            return null
        } catch (e: Exception) { // Captura más genérica
            Log.e(TAG, getString(R.string.log_unexpected_error_get_video_bytes, uri.toString()), e)
            showToast(getString(R.string.upload_file_error_message, e.localizedMessage ?: getString(R.string.unknown_error)))
            return null
        }
    }

    private fun resizeBitmapKeepingAspectRatio(bitmap: Bitmap, maxSideLength: Int): Bitmap {
        val currentWidth = bitmap.width
        val currentHeight = bitmap.height

        if (currentWidth <= maxSideLength && currentHeight <= maxSideLength) {
            return bitmap // No necesita redimensionamiento
        }

        val ratio = currentWidth.toFloat() / currentHeight.toFloat()
        var newWidth: Int
        var newHeight: Int

        if (currentWidth > currentHeight) {
            newWidth = maxSideLength
            newHeight = (maxSideLength / ratio).roundToInt()
        } else {
            newHeight = maxSideLength
            newWidth = (maxSideLength * ratio).roundToInt()
        }
        // Asegurar que las nuevas dimensiones no sean cero
        if (newWidth <= 0) newWidth = 1
        if (newHeight <= 0) newHeight = 1

        return Bitmap.createScaledBitmap(bitmap, newWidth, newHeight, true)
    }

    private fun compressImageToWebP(uri: Uri, quality: Int, maxSideLength: Int): ByteArray? {
        var inputStream: InputStream? = null
        var exifInputStream: InputStream? = null
        try {
            inputStream = contentResolver.openInputStream(uri) ?: throw FileNotFoundException(getString(R.string.error_inputstream_null_for_uri_compress_video, uri.toString()))
            val originalBitmap = BitmapFactory.decodeStream(inputStream)
                ?: throw IOException(getString(R.string.error_failed_decode_bitmap_from_uri_compress_video, uri.toString()))

            exifInputStream = contentResolver.openInputStream(uri) ?: throw FileNotFoundException(getString(R.string.error_exif_inputstream_null_for_uri_compress_video, uri.toString()))
            val exif = ExifInterface(exifInputStream)
            val orientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL)

            val matrix = Matrix()
            when (orientation) {
                ExifInterface.ORIENTATION_ROTATE_90 -> matrix.postRotate(90f)
                ExifInterface.ORIENTATION_ROTATE_180 -> matrix.postRotate(180f)
                ExifInterface.ORIENTATION_ROTATE_270 -> matrix.postRotate(270f)
                ExifInterface.ORIENTATION_FLIP_HORIZONTAL -> matrix.postScale(-1f, 1f)
                ExifInterface.ORIENTATION_FLIP_VERTICAL -> matrix.postScale(1f, -1f)
                ExifInterface.ORIENTATION_TRANSPOSE -> { matrix.postRotate(90f); matrix.postScale(-1f, 1f) }
                ExifInterface.ORIENTATION_TRANSVERSE -> { matrix.postRotate(-90f); matrix.postScale(-1f, 1f) }
            }
            val rotatedBitmap = Bitmap.createBitmap(originalBitmap, 0, 0, originalBitmap.width, originalBitmap.height, matrix, true)
            if (originalBitmap != rotatedBitmap) { // Solo reciclar si se creó un nuevo bitmap
                originalBitmap.recycle()
            }

            val resizedBitmap = resizeBitmapKeepingAspectRatio(rotatedBitmap, maxSideLength)
            if (rotatedBitmap != resizedBitmap) { // Solo reciclar si se creó un nuevo bitmap
                rotatedBitmap.recycle()
            }

            ByteArrayOutputStream().use { outputStream ->
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
                    resizedBitmap.compress(Bitmap.CompressFormat.WEBP_LOSSY, quality, outputStream)
                } else {
                    @Suppress("DEPRECATION") // WEBP_LOSSY es preferido en R+, pero WEBP es la opción para < R
                    resizedBitmap.compress(Bitmap.CompressFormat.WEBP, quality, outputStream)
                }
                resizedBitmap.recycle() // Reciclar el bitmap final
                return outputStream.toByteArray()
            }
        } catch (fnfe: FileNotFoundException) {
            Log.e(TAG, getString(R.string.log_error_file_not_found_compress_webp_video, uri.toString()), fnfe)
            showToast(getString(R.string.error_file_not_found_for_compression, uri.lastPathSegment ?: getString(R.string.selected_image_default_name)))
            return null
        } catch (ioe: IOException) {
            Log.e(TAG, getString(R.string.log_error_io_compress_webp_video, uri.toString()), ioe)
            showToast(getString(R.string.error_io_compressing_image))
            return null
        } catch (e: Exception) { // Captura más genérica para otros errores
            Log.e(TAG, getString(R.string.log_error_unexpected_compress_webp_video, uri.toString()), e)
            showToast(getString(R.string.error_unknown_compressing_image))
            return null
        } finally {
            try {
                inputStream?.close()
                exifInputStream?.close()
            } catch (ioe: IOException) {
                Log.e(TAG, getString(R.string.log_error_closing_streams_compress_webp_uri_video, uri.toString()), ioe)
            }
        }
    }

    private fun saveVideoDataToFirestore(videoData: HashMap<String, Any?>) {
        firestore.collection(getString(R.string.firestore_collection_videos_pending)).add(videoData)
            .addOnSuccessListener { documentReference ->
                Log.i(TAG, getString(R.string.log_firestore_video_data_saved, documentReference.id))
                runOnUiThread {
                    binding.uploadProgressOverlayVideo.isVisible = false
                    showSubmissionConfirmationDialog(getString(R.string.video_upload_success), getString(R.string.video_upload_message))
                }
            }
            .addOnFailureListener { e ->
                Log.e(TAG, getString(R.string.log_error_firestore_saving_video_data), e)
                handleUploadError(getString(R.string.save_story_error_message, e.localizedMessage) + getString(R.string.error_suffix_firestore_save_video)) // Reutilizar string si es genérico
            }
    }

    private fun handleUploadError(errorMessage: String) {
        Log.e(TAG, getString(R.string.log_handling_upload_error_video, errorMessage))
        currentVideoUploadRequestId = null // Limpiar IDs
        currentComplementaryImageUploadRequestId = null
        runOnUiThread {
            binding.uploadProgressOverlayVideo.isVisible = false
            showAlertDialog(getString(R.string.error_dialog_title), getString(R.string.upload_error_prefix, errorMessage))
            setUiEnabled(true) // Reactivar UI
            isSubmitting = false
        }
    }

    private fun showSubmissionConfirmationDialog(title: String, message: String) {
        if (isFinishing || isDestroyed) { // Evitar mostrar diálogo si la actividad está finalizando
            Log.w(TAG, getString(R.string.log_activity_finishing_dialog_not_shown_video))
            return
        }
        AlertDialog.Builder(this) // Usar androidx.appcompat.app.AlertDialog
            .setTitle(title)
            .setMessage(message)
            .setPositiveButton(R.string.dialog_positive_button_understood) { _, _ ->
                finish()
            }
            .setCancelable(false) // No permitir cancelar el diálogo con back button
            .show()
    }

    private fun setUiEnabled(enabled: Boolean) {
        binding.btnEnviarVideo.isEnabled = enabled
        binding.btnBorrarTodoVideo.isEnabled = enabled

        val formElementsEnabled = enabled
        binding.editTextVideoTitle.isEnabled = formElementsEnabled
        binding.editTextVideoDescription.isEnabled = formElementsEnabled
        binding.editTextYoutubeLink.isEnabled = formElementsEnabled
        binding.editTextAttachVideo.isEnabled = formElementsEnabled // El EditText para mostrar nombre de archivo
        binding.btnSelectCoverImageVideo.isEnabled = formElementsEnabled
        binding.spinnerLocation.isEnabled = formElementsEnabled

        binding.radioGroupDateType.isEnabled = formElementsEnabled
        for (i in 0 until binding.radioGroupDateType.childCount) {
            binding.radioGroupDateType.getChildAt(i).isEnabled = formElementsEnabled
        }
        binding.radioUnknown.isEnabled = formElementsEnabled

        binding.editTextYear.isEnabled = formElementsEnabled && binding.textInputLayoutYear.isVisible
        binding.editTextExactDate.isEnabled = formElementsEnabled && binding.textInputLayoutExactDate.isVisible
        binding.editTextStartYear.isEnabled = formElementsEnabled && binding.dateRangeLayout.isVisible
        binding.editTextEndYear.isEnabled = formElementsEnabled && binding.dateRangeLayout.isVisible
        binding.infoIconDateLabel.isEnabled = formElementsEnabled

        binding.switchCoordinates.isEnabled = formElementsEnabled
        binding.textViewSelectCoordinates.isEnabled = formElementsEnabled && binding.mapSelectionContainer.isVisible && binding.textViewSelectCoordinates.isVisible
        binding.btnEditCoordinates.isEnabled = formElementsEnabled && binding.mapSelectionContainer.isVisible && binding.btnEditCoordinates.isVisible

        // Habilitar controles del reproductor de video solo si hay un video y la UI general está habilitada
        val videoPlayerControlsShouldBeEnabled = enabled && (videoUri != null)
        binding.btnPlay.isEnabled = videoPlayerControlsShouldBeEnabled && binding.btnPlay.isVisible // Solo si es visible y habilitado
        binding.btnPause.isEnabled = videoPlayerControlsShouldBeEnabled && binding.btnPause.isVisible
        binding.btnStop.isEnabled = videoPlayerControlsShouldBeEnabled && binding.btnStop.isVisible
        binding.btnCloseVideo.isEnabled = enabled // El botón de cerrar siempre sigue el estado general 'enabled'
    }

    private fun showToast(message: String) {
        Toast.makeText(this, message, Toast.LENGTH_SHORT).show()
    }

    private fun showAlertDialog(title: String, message: String) {
        if (isFinishing || isDestroyed) {
            Log.w(TAG, getString(R.string.log_activity_finishing_dialog_not_shown_video_alert))
            return
        }
        AlertDialog.Builder(this) // Usar androidx.appcompat.app.AlertDialog
            .setTitle(title)
            .setMessage(message)
            .setPositiveButton(getString(R.string.dialog_ok), null)
            .show()
    }
}


===== Archivo: app\src\main\java\com\example\mexicoparanormal\UserProfileActivity.kt =====


package com.example.mexicoparanormal

import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import androidx.viewpager2.adapter.FragmentStateAdapter
import androidx.viewpager2.widget.ViewPager2
import com.google.android.material.tabs.TabLayout
import com.google.android.material.tabs.TabLayoutMediator
import com.example.mexicoparanormal.databinding.ActivityUserProfileBinding
import androidx.activity.OnBackPressedCallback // Importar para manejar el botón de retroceso
import androidx.fragment.app.Fragment // Importar Fragment

class UserProfileActivity : AppCompatActivity() {

    private lateinit var binding: ActivityUserProfileBinding

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityUserProfileBinding.inflate(layoutInflater)
        setContentView(binding.root)

        // Botón "X" para volver a MainActivity (pantalla de bienvenida)
        binding.btnBack.setOnClickListener {
            // Simplemente finaliza esta actividad para regresar a la anterior en la pila (MainActivity)
            finish()
        }

        // Configurar ViewPager2 y TabLayout
        val viewPager: ViewPager2 = binding.viewPager
        val tabLayout: TabLayout = binding.tabLayout
        viewPager.adapter = UserProfilePagerAdapter(this)

        TabLayoutMediator(tabLayout, viewPager) { tab, position ->
            tab.text = when (position) {
                0 -> getString(R.string.uploads) // Asumo que la pestaña 0 es "Subidas"
                1 -> getString(R.string.settings) // Asumo que la pestaña 1 es "Personalización"
                else -> null
            }
        }.attach()

        // --- Manejo del botón de retroceso del sistema ---
        val callback = object : OnBackPressedCallback(true) {
            override fun handleOnBackPressed() {
                // Si estamos en la primera pestaña (Subidas), salir de la actividad
                if (binding.viewPager.currentItem == 0) {
                    finish() // Finaliza UserProfileActivity para volver a MainActivity
                } else {
                    // Si no estamos en la primera pestaña, ir a la pestaña anterior
                    binding.viewPager.currentItem = binding.viewPager.currentItem - 1
                }
            }
        }
        // Añadir el callback al despachador de retroceso de la actividad
        this.onBackPressedDispatcher.addCallback(this, callback)

    }

    private inner class UserProfilePagerAdapter(activity: AppCompatActivity) : FragmentStateAdapter(activity) {
        override fun getItemCount(): Int = 2 // Hay dos pestañas: Subidas y Personalización
        override fun createFragment(position: Int): Fragment {
            return when (position) {
                0 -> UploadsFragment() // Fragmento para la pestaña "Subidas"
                1 -> SettingsFragment() // Fragmento para la pestaña "Personalización"
                else -> throw IllegalStateException(getString(R.string.error_invalid_fragment_position, position))
            }
        }
    }
}


===== Archivo: app\src\main\java\com\example\mexicoparanormal\VideoViewerActivity.kt =====


package com.example.mexicoparanormal

import android.os.Bundle
import android.util.Log
import android.view.View
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import com.bumptech.glide.Glide
import com.example.mexicoparanormal.databinding.ActivityVideoViewerBinding
import com.google.firebase.firestore.FirebaseFirestore
import com.google.android.exoplayer2.ExoPlayer
import com.google.android.exoplayer2.MediaItem
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale

class VideoViewerActivity : AppCompatActivity() {

    private lateinit var binding: ActivityVideoViewerBinding
    private lateinit var firestore: FirebaseFirestore
    private var videoDocumentId: String? = null
    private var isPendingReview: Boolean = false
    private var exoPlayer: ExoPlayer? = null

    companion object {
        private const val TAG = "VideoViewerActivity" // Etiqueta para logs
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityVideoViewerBinding.inflate(layoutInflater)
        setContentView(binding.root)

        firestore = FirebaseFirestore.getInstance()
        videoDocumentId = intent.getStringExtra(getString(R.string.intent_extra_video_id_key))
        isPendingReview = intent.getBooleanExtra(getString(R.string.intent_extra_is_pending_review_key), false)

        binding.btnBackVideoViewer.setOnClickListener {
            finish()
        }

        if (videoDocumentId == null) {
            Toast.makeText(this, getString(R.string.content_not_found), Toast.LENGTH_LONG).show()
            finish()
            return
        }

        setupUIForPendingStatus()
        loadVideoData()
    }

    private fun setupUIForPendingStatus() {
        if (isPendingReview) {
            binding.textViewPendingReviewStatusVideo.visibility = View.VISIBLE
            binding.interactionLayoutVideo.visibility = View.GONE
        } else {
            binding.textViewPendingReviewStatusVideo.visibility = View.GONE
            binding.interactionLayoutVideo.visibility = View.VISIBLE
        }
    }

    private fun loadVideoData() {
        val collectionPath = if (isPendingReview) getString(R.string.firestore_collection_videos_pending) else getString(R.string.firestore_collection_videos_approved)
        videoDocumentId?.let { id ->
            firestore.collection(collectionPath).document(id)
                .get()
                .addOnSuccessListener { document ->
                    if (document != null && document.exists()) {
                        val title = document.getString(getString(R.string.firestore_field_title)) ?: getString(R.string.title_not_available)
                        binding.videoTitleTextViewer.text = title
                        binding.screenTitleVideoViewer.text = title

                        val videoUrl = document.getString(getString(R.string.firestore_field_videoUrl))
                        val complementaryImageUrl = document.getString(getString(R.string.firestore_field_complementaryImageUrl))
                        // La lógica de youtubeLink se omite según la solicitud

                        if (!videoUrl.isNullOrEmpty()) {
                            initializeExoPlayer(videoUrl)
                            binding.exoPlayerView.visibility = View.VISIBLE
                        } else {
                            // Si no hay videoUrl directo y no manejamos youtubeLink aquí, mostramos error
                            Toast.makeText(this, getString(R.string.error_video_source_not_found), Toast.LENGTH_SHORT).show()
                            binding.exoPlayerView.visibility = View.GONE
                        }

                        if (!complementaryImageUrl.isNullOrEmpty()) {
                            binding.labelComplementaryImageVideo.visibility = View.VISIBLE
                            binding.imageViewComplementaryVideoViewer.visibility = View.VISIBLE
                            Glide.with(this)
                                .load(complementaryImageUrl)
                                .placeholder(R.drawable.placeholder_image)
                                .error(R.drawable.placeholder_image)
                                .into(binding.imageViewComplementaryVideoViewer)
                        } else {
                            binding.labelComplementaryImageVideo.visibility = View.GONE
                            binding.imageViewComplementaryVideoViewer.visibility = View.GONE
                        }

                        binding.videoAuthorTextViewer.text = getString(R.string.author_format, document.getString(getString(R.string.firestore_field_authorUsername)) ?: getString(R.string.unknown_user))
                        val timestamp = document.getTimestamp(getString(R.string.firestore_field_timestamp))?.toDate()
                        if (timestamp != null) {
                            val sdf = SimpleDateFormat(getString(R.string.date_format_dd_mm_yyyy_hh_mm), Locale.getDefault())
                            binding.videoDateTextViewer.text = getString(R.string.date_format_viewer, sdf.format(timestamp))
                        } else {
                            binding.videoDateTextViewer.text = getString(R.string.date_format_viewer, getString(R.string.date_type_unknown))
                        }
                        binding.videoDescriptionTextViewer.text = document.getString(getString(R.string.firestore_field_description)) ?: ""
                        binding.videoLocationTextViewer.text = document.getString(getString(R.string.firestore_field_location)) ?: getString(R.string.location_unknown)

                    } else {
                        Log.e(TAG, getString(R.string.log_document_not_found_in_collection_video, collectionPath, id))
                        Toast.makeText(this, getString(R.string.content_not_found), Toast.LENGTH_LONG).show()
                        finish()
                    }
                }
                .addOnFailureListener { exception ->
                    Log.e(TAG, getString(R.string.log_error_loading_video_with_id, id), exception)
                    Toast.makeText(this, getString(R.string.error_loading_content), Toast.LENGTH_LONG).show()
                    finish()
                }
        }
    }

    private fun initializeExoPlayer(videoUrl: String) {
        try {
            exoPlayer = ExoPlayer.Builder(this).build()
            binding.exoPlayerView.player = exoPlayer

            val mediaItem = MediaItem.fromUri(videoUrl)
            exoPlayer?.setMediaItem(mediaItem)
            exoPlayer?.prepare()
            exoPlayer?.playWhenReady = true // Iniciar reproducción automáticamente

        } catch (e: Exception) {
            Log.e(TAG, getString(R.string.log_error_initializing_exoplayer), e)
            Toast.makeText(this, getString(R.string.error_initializing_exoplayer_message), Toast.LENGTH_SHORT).show()
            binding.exoPlayerView.visibility = View.GONE // Ocultar si falla
        }
    }

    override fun onPause() {
        super.onPause()
        exoPlayer?.pause() // Pausar ExoPlayer si está reproduciendo
    }

    override fun onDestroy() {
        super.onDestroy()
        exoPlayer?.release() // Liberar ExoPlayer para evitar fugas de memoria
        exoPlayer = null
    }
}


===== Archivo: app\src\main\java\com\example\mexicoparanormal\WaveformView.kt =====


package com.example.mexicoparanormal

import android.annotation.SuppressLint
import android.content.Context
import android.graphics.Canvas
// import android.graphics.Color // Ya no es necesario para parseColor
import android.graphics.Paint
import android.graphics.Path
import android.util.AttributeSet
import android.util.Log
import android.view.MotionEvent
import android.view.View
import androidx.core.content.ContextCompat // Import para ContextCompat
import java.util.LinkedList
import kotlin.math.max

class WaveformView @JvmOverloads constructor(
    context: Context, // [cite: 1159]
    attrs: AttributeSet? = null,
    defStyleAttr: Int = 0
) : View(context, attrs, defStyleAttr) {

    // --- Listener para interacción ---
    interface OnWaveformInteractionListener {
        fun onWaveformSeek(progressRatio: Float)
    }
    var onWaveformInteractionListener: OnWaveformInteractionListener? = null

    // --- Colores Personalizables (cargados desde resources) ---
    private var waveColor: Int
    private var waveformBackgroundColor: Int // Renombrado para evitar conflicto con View.getBackgroundColor()
    private var gridColor: Int
    private var indicatorColor: Int
    private var centerLineGridColor: Int // [cite: 1160]

    // --- Paints ---
    private val wavePaint = Paint().apply {
        // el color se establecerá en init
        style = Paint.Style.FILL
        isAntiAlias = true
    }

    private val gridPaint = Paint().apply {
        // el color se establecerá en init
        strokeWidth = dpToPx(0.5f)
        isAntiAlias = true
    } // [cite: 1161]

    private val centerLineGridPaint = Paint().apply {
        // el color se establecerá en init
        strokeWidth = dpToPx(0.75f) // Línea central ligeramente más gruesa
        isAntiAlias = true
    }

    private val indicatorPaint = Paint().apply {
        // el color se establecerá en init
        strokeWidth = dpToPx(1.5f) // Indicador más visible
        isAntiAlias = true
    }

    private val amplitudes = LinkedList<Float>() // Normalizadas 0.0f a 1.0f // [cite: 1162]
    private var maxDisplayablePoints = WAVEFORM_SAMPLES_CONST // MODIFICACIÓN: Inicializar directamente
    // maxReportableAmplitude ya no se usa aquí para normalizar, se hace antes.
    // private val maxReportableAmplitude = 32767f

    private var currentPlaybackProgressRatio: Float? = null // Rango de 0.0f a 1.0f

    // --- Para la cuadrícula ---
    private val gridLinesHorizontal = 4 // Número de líneas internas horizontales (resulta en 5 secciones)
    private val gridLinesVertical = 10  // Número de líneas internas verticales (resulta en 11 secciones)

    companion object { // [cite: 1163]
        private const val TAG = "WaveformView" // Etiqueta para logs
        const val WAVEFORM_SAMPLES_CONST = 100 // Número de puntos/muestras a mostrar en la forma de onda
    }

    init {
        // Cargar colores desde resources
        waveColor = ContextCompat.getColor(context, R.color.waveform_wave_color)
        waveformBackgroundColor = ContextCompat.getColor(context, R.color.waveform_background_color)
        gridColor = ContextCompat.getColor(context, R.color.waveform_grid_color)
        indicatorColor = ContextCompat.getColor(context, R.color.waveform_indicator_color) // [cite: 1164]
        centerLineGridColor = ContextCompat.getColor(context, R.color.waveform_center_line_grid_color)

        // Asignar colores a los Paints
        wavePaint.color = waveColor
        gridPaint.color = gridColor
        centerLineGridPaint.color = centerLineGridColor
        indicatorPaint.color = indicatorColor

        setupTouchListener()
        contentDescription = context.getString(R.string.cd_waveform_visualizer) // Descripción de contenido por defecto
    }

    private fun dpToPx(dp: Float): Float {
        return dp * resources.displayMetrics.density // [cite: 1165]
    }

    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {
        super.onSizeChanged(w, h, oldw, oldh)
        // maxDisplayablePoints ya está inicializado con WAVEFORM_SAMPLES_CONST.
        // Si se quisiera que dependa del ancho, aquí se calcularía.
        Log.d(TAG, context.getString(R.string.log_waveform_size_changed, w, h, maxDisplayablePoints))
    }

    /**
     * Añade una nueva amplitud cruda (de MediaRecorder.maxAmplitude) a la forma de onda.
     * La amplitud se normaliza y se añade a la lista. Si la lista excede // [cite: 1166]
     * `maxDisplayablePoints`, se elimina el punto más antiguo.
     * @param rawAmplitude La amplitud cruda (ej. de MediaRecorder).
     */
    fun addAmplitude(rawAmplitude: Int) {
        // Normalizar la amplitud a un rango de 0.0f a 1.0f usando el valor máximo teórico de un Short.
        // Esto es para la grabación en tiempo real. Para archivos adjuntos, la normalización ya se hizo.
        val maxTheoreticalAmplitude = 32767f
        val normalizedAmplitude = (rawAmplitude.toFloat().coerceIn(0f, maxTheoreticalAmplitude)) / maxTheoreticalAmplitude
        synchronized(amplitudes) { // [cite: 1167]
            amplitudes.add(normalizedAmplitude)
            // Mantener solo el número máximo de puntos visibles
            if (amplitudes.size > maxDisplayablePoints && maxDisplayablePoints > 0) {
                amplitudes.removeFirst()
            }
        }
        postInvalidate() // Solicitar redibujado
    }

    /** // [cite: 1168]
     * Establece los datos completos de la forma de onda a partir de una lista de amplitudes ya normalizadas.
     * Se espera que la lista ya esté submuestreada/interpolada al número correcto de puntos (maxDisplayablePoints).
     * @param normalizedAmplitudes Lista de amplitudes normalizadas (0.0f a 1.0f).
     */
    fun setWaveformData(normalizedAmplitudes: List<Float>) {
        if (maxDisplayablePoints <= 0) { // Esta condición ahora será menos probable que sea true
            Log.w(TAG, context.getString(R.string.log_waveform_setdata_empty_or_no_points) + " (maxDisplayablePoints es $maxDisplayablePoints)")
            synchronized(amplitudes) {
                amplitudes.clear() // [cite: 1169]
            }
            currentPlaybackProgressRatio = null
            postInvalidate()
            return
        }

        synchronized(amplitudes) {
            amplitudes.clear()
            if (normalizedAmplitudes.isNotEmpty()) {
                // Simplemente toma los primeros 'maxDisplayablePoints' o todos si son menos.
                // Se asume que normalizedAmplitudes ya tiene el tamaño correcto o cercano.
                amplitudes.addAll(normalizedAmplitudes.take(maxDisplayablePoints)) // [cite: 1170]
            }
        }

        // Si después de tomar los puntos, aún no llegamos a maxDisplayablePoints (porque la lista de entrada era más corta),
        // y tenemos al menos un punto, rellenamos con el último valor.
        // Esto es más un fallback, idealmente normalizedAmplitudes ya tiene WAVEFORM_SAMPLES_CONST elementos. // [cite: 1171]
        if (amplitudes.isNotEmpty() && amplitudes.size < maxDisplayablePoints) {
            val lastVal = amplitudes.last()
            while(amplitudes.size < maxDisplayablePoints) {
                amplitudes.add(lastVal)
            }
        }


        currentPlaybackProgressRatio = if (amplitudes.isNotEmpty()) 0f else null // Resetear indicador al inicio si hay datos // [cite: 1172]
        Log.d(TAG, context.getString(R.string.log_waveform_setdata_processed, amplitudes.size))
        postInvalidate()
    }


    /**
     * Actualiza la posición del indicador de reproducción.
     * @param currentPositionMillis Posición actual de reproducción en milisegundos.
     * @param totalDurationMillis Duración total del audio en milisegundos.
     */
    fun updatePlaybackIndicator(currentPositionMillis: Long, totalDurationMillis: Long) {
        if (totalDurationMillis > 0) {
            currentPlaybackProgressRatio = (currentPositionMillis.toFloat() / totalDurationMillis).coerceIn(0f, 1f)
        } else {
            currentPlaybackProgressRatio = 0f // O null si se prefiere no mostrarlo si no hay duración // [cite: 1173]
        }
        postInvalidate()
    }

    /**
     * Limpia la forma de onda y el indicador de reproducción.
     */
    fun clearWaveform() {
        synchronized(amplitudes) {
            amplitudes.clear()
        }
        currentPlaybackProgressRatio = null // [cite: 1174]
        postInvalidate()
        Log.d(TAG, context.getString(R.string.log_waveform_cleared))
    }

    @SuppressLint("ClickableViewAccessibility")
    private fun setupTouchListener() {
        setOnTouchListener { _, event ->
            when (event.action) {
                MotionEvent.ACTION_DOWN, MotionEvent.ACTION_MOVE -> {
                    if (width > 0) { // Asegurar que la vista tiene ancho // [cite: 1175]
                        val progressRatio = (event.x / width.toFloat()).coerceIn(0f, 1f)
                        onWaveformInteractionListener?.onWaveformSeek(progressRatio)
                        // Actualizar el indicador visualmente de inmediato si se desea,
                        // aunque el reproductor debería hacerlo a través de updatePlaybackIndicator // [cite: 1176]
                        // currentPlaybackProgressRatio = progressRatio
                        // postInvalidate()
                    }
                    true // Consumir el evento // [cite: 1177]
                }
                else -> false // No consumir otros eventos
            }
        }
    }

    override fun onDraw(canvas: Canvas) {
        super.onDraw(canvas)
        val width = width.toFloat()
        val height = height.toFloat() // [cite: 1178]
        val centerY = height / 2f

        // 1. Dibujar fondo
        canvas.drawColor(waveformBackgroundColor)

        // 2. Dibujar cuadrícula
        // Líneas horizontales
        val horizontalStep = height / (gridLinesHorizontal + 1)
        for (i in 1..gridLinesHorizontal) {
            val y = i * horizontalStep
            canvas.drawLine(0f, y, width, y, gridPaint) // [cite: 1179]
        }
        // Línea central (más gruesa)
        canvas.drawLine(0f, centerY, width, centerY, centerLineGridPaint)

        // Líneas verticales
        val verticalStep = width / (gridLinesVertical + 1)
        for (i in 1..gridLinesVertical) {
            val x = i * verticalStep
            canvas.drawLine(x, 0f, x, height, gridPaint) // [cite: 1180]
        }

        // 3. Dibujar forma de onda
        val wavePath = Path()
        synchronized(amplitudes) {
            if (amplitudes.isNotEmpty()) {
                // Si solo hay un punto, dibuja una línea horizontal en el centro.
                // Si hay más, calcula pointWidth.
                val pointWidth = if (amplitudes.size > 1) width / (amplitudes.size - 1).toFloat() else width // [cite: 1181]

                wavePath.moveTo(0f, centerY) // Empezar en el centro a la izquierda

                // Dibujar la parte superior de la onda
                for ((index, normalizedAmplitude) in amplitudes.withIndex()) {
                    val xPos = index * pointWidth
                    // Asegurar que la amplitud normalizada esté entre 0 y 1
                    val clampedAmplitude = normalizedAmplitude.coerceIn(0f, 1f) // [cite: 1182]
                    val peakHeight = clampedAmplitude * centerY // Altura del pico basada en la amplitud normalizada
                    wavePath.lineTo(xPos, centerY - peakHeight)
                } // [cite: 1183]
                // Conectar el último punto superior al centro a la derecha
                wavePath.lineTo(width, centerY)

                // Dibujar la parte inferior de la onda (en reversa para cerrar el path)
                for (index in (amplitudes.size - 1) downTo 0) { // [cite: 1184]
                    val xPos = index * pointWidth
                    val normalizedAmplitude = amplitudes[index]
                    val clampedAmplitude = normalizedAmplitude.coerceIn(0f, 1f)
                    val peakHeight = clampedAmplitude * centerY
                    wavePath.lineTo(xPos, centerY + peakHeight) // [cite: 1185]
                }
                wavePath.close() // Cerrar el path para rellenar
                canvas.drawPath(wavePath, wavePaint)
            }
        }

        // 4. Dibujar indicador de reproducción
        currentPlaybackProgressRatio?.let { ratio -> // [cite: 1186]
            val indicatorX = ratio * width
            canvas.drawLine(indicatorX, 0f, indicatorX, height, indicatorPaint)
        }
    }
}


===== Archivo: app\src\main\java\com\example\mexicoparanormal\WriteStoryFragment.kt =====


package com.example.mexicoparanormal // Asegúrate de que el paquete sea el correcto

import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.fragment.app.Fragment
import com.example.mexicoparanormal.databinding.FragmentWriteStoryBinding // Importa el ViewBinding generado

/**
 * Fragmento para la pestaña "Escribir Relato".
 * Permite al usuario ingresar el texto de su relato.
 */
class WriteStoryFragment : Fragment() {

    private var _binding: FragmentWriteStoryBinding? = null
    // Esta propiedad solo es válida entre onCreateView y onDestroyView.
    private val binding get() = _binding!!

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        _binding = FragmentWriteStoryBinding.inflate(inflater, container, false)
        return binding.root
    }

    /**
     * Obtiene el texto actual del relato ingresado por el usuario.
     * @return El texto del relato como String.
     */
    fun getStoryText(): String {
        return binding.editTextStoryText.text.toString()
    }

    /**
     * Establece el texto en el campo del relato.
     * Esto podría ser útil si, por ejemplo, se implementa la transcripción
     * y se quiere poblar este campo desde la actividad.
     * @param text El texto a establecer.
     */
    fun setStoryText(text: CharSequence?) {
        binding.editTextStoryText.setText(text)
    }


    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null // Importante para evitar fugas de memoria con ViewBinding
    }

    companion object {
        /**
         * Crea una nueva instancia de WriteStoryFragment.
         */
        @JvmStatic
        fun newInstance() = WriteStoryFragment()
    }
}


===== Archivo: app\src\main\res\anim\slide_in_right.xml =====


<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android"
    android:shareInterpolator="false">
    <translate
        android:duration="300" android:fromXDelta="100%p"
        android:toXDelta="0%" />
    <alpha
        android:duration="300"
        android:fromAlpha="0.0"
        android:toAlpha="1.0" />
</set>


===== Archivo: app\src\main\res\anim\slide_out_left.xml =====


<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android"
    android:shareInterpolator="false">
    <translate
        android:duration="300" android:fromXDelta="0%"
        android:toXDelta="-100%p" />
    <alpha
        android:duration="300"
        android:fromAlpha="1.0"
        android:toAlpha="0.0" />
</set>


===== Archivo: app\src\main\res\drawable\bg_record_button.xml =====


<!-- res/drawable/bg_record_button.xml -->
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">
    <solid android:color="#D32F2F" /> <!-- Rojo fuerte -->
    <corners android:radius="24dp" />
    <padding android:left="16dp"
        android:top="12dp"
        android:right="16dp"
        android:bottom="12dp" />
</shape>


===== Archivo: app\src\main\res\drawable\divider_vertical.xml =====


<shape xmlns:android="http://schemas.android.com/apk/res/android">
    <size android:width="1dp" />
    <solid android:color="@color/glass_hint" />
</shape>


===== Archivo: app\src\main\res\drawable\glassmorphism_background.xml =====


<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">
    <solid android:color="@color/glass_background"/>
    <corners android:radius="16dp" />
    <stroke
        android:width="1dp"
        android:color="@color/glass_stroke"/>
</shape>


===== Archivo: app\src\main\res\drawable\gradient_background.xml =====


<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">
    <gradient
        android:startColor="@color/purple_dark"
        android:endColor="@color/black"
        android:angle="90" />
</shape>


===== Archivo: app\src\main\res\drawable\ic_admin.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M17,11c0.34,0 0.67,0.04 1,0.09V6.27L10.5,3L3,6.27v4.91c0,4.54 3.2,8.79 7.5,9.82c0.55,-0.13 1.08,-0.32 1.6,-0.55C11.41,19.47 11,18.28 11,17C11,13.69 13.69,11 17,11z"/>
      
    <path android:fillColor="@android:color/white" android:pathData="M17,13c-2.21,0 -4,1.79 -4,4c0,2.21 1.79,4 4,4s4,-1.79 4,-4C21,14.79 19.21,13 17,13zM17,14.38c0.62,0 1.12,0.51 1.12,1.12s-0.51,1.12 -1.12,1.12s-1.12,-0.51 -1.12,-1.12S16.38,14.38 17,14.38zM17,19.75c-0.93,0 -1.74,-0.46 -2.24,-1.17c0.05,-0.72 1.51,-1.08 2.24,-1.08s2.19,0.36 2.24,1.08C18.74,19.29 17.93,19.75 17,19.75z"/>
    
</vector>


===== Archivo: app\src\main\res\drawable\ic_approved.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M19,1L5,1c-1.1,0 -1.99,0.9 -1.99,2L3,15.93c0,0.69 0.35,1.3 0.88,1.66L12,23l8.11,-5.41c0.53,-0.36 0.88,-0.97 0.88,-1.66L21,3c0,-1.1 -0.9,-2 -2,-2zM10,16l-5,-5 1.41,-1.41L10,13.17l7.59,-7.59L19,7l-9,9z"/>
    
</vector>


===== Archivo: app\src\main\res\drawable\ic_arrow_back.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android" android:autoMirrored="true" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M22,3L7,3c-0.69,0 -1.23,0.35 -1.59,0.88L0,12l5.41,8.11c0.36,0.53 0.9,0.89 1.59,0.89h15c1.1,0 2,-0.9 2,-2L24,5c0,-1.1 -0.9,-2 -2,-2zM19,15.59L17.59,17 14,13.41 10.41,17 9,15.59 12.59,12 9,8.41 10.41,7 14,10.59 17.59,7 19,8.41 15.41,12 19,15.59z"/>
    
</vector>


===== Archivo: app\src\main\res\drawable\ic_arrow_left.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M17.59,18l1.41,-1.41l-4.58,-4.59l4.58,-4.59l-1.41,-1.41l-6,6z"/>
      
    <path android:fillColor="@android:color/white" android:pathData="M11,18l1.41,-1.41l-4.58,-4.59l4.58,-4.59l-1.41,-1.41l-6,6z"/>
    
</vector>


===== Archivo: app\src\main\res\drawable\ic_arrow_right.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M6.41,6l-1.41,1.41l4.58,4.59l-4.58,4.59l1.41,1.41l6,-6z"/>
      
    <path android:fillColor="@android:color/white" android:pathData="M13,6l-1.41,1.41l4.58,4.59l-4.58,4.59l1.41,1.41l6,-6z"/>
    
</vector>


===== Archivo: app\src\main\res\drawable\ic_attachment.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M16.5,6v11.5c0,2.21 -1.79,4 -4,4s-4,-1.79 -4,-4V5c0,-1.38 1.12,-2.5 2.5,-2.5s2.5,1.12 2.5,2.5v10.5c0,0.55 -0.45,1 -1,1s-1,-0.45 -1,-1V6H10v9.5c0,1.38 1.12,2.5 2.5,2.5s2.5,-1.12 2.5,-2.5V5c0,-2.21 -1.79,-4 -4,-4S7,2.79 7,5v12.5c0,3.04 2.46,5.5 5.5,5.5s5.5,-2.46 5.5,-5.5V6h-1.5z"/>
    
</vector>


===== Archivo: app\src\main\res\drawable\ic_audio_waves.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M10,9m-4,0a4,4 0,1 1,8 0a4,4 0,1 1,-8 0"/>
      
    <path android:fillColor="@android:color/white" android:pathData="M16.39,15.56C14.71,14.7 12.53,14 10,14c-2.53,0 -4.71,0.7 -6.39,1.56C2.61,16.07 2,17.1 2,18.22V21h16v-2.78C18,17.1 17.39,16.07 16.39,15.56z"/>
      
    <path android:fillColor="@android:color/white" android:pathData="M16,1h-2c0,4.97 4.03,9 9,9V8C19.14,8 16,4.86 16,1z"/>
      
    <path android:fillColor="@android:color/white" android:pathData="M20,1h-2c0,2.76 2.24,5 5,5V4C21.35,4 20,2.65 20,1z"/>
    
</vector>


===== Archivo: app\src\main\res\drawable\ic_book.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android" android:autoMirrored="true" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M21,5c-1.11,-0.35 -2.33,-0.5 -3.5,-0.5c-1.95,0 -4.05,0.4 -5.5,1.5c-1.45,-1.1 -3.55,-1.5 -5.5,-1.5S2.45,4.9 1,6v14.65c0,0.25 0.25,0.5 0.5,0.5c0.1,0 0.15,-0.05 0.25,-0.05C3.1,20.45 5.05,20 6.5,20c1.95,0 4.05,0.4 5.5,1.5c1.35,-0.85 3.8,-1.5 5.5,-1.5c1.65,0 3.35,0.3 4.75,1.05c0.1,0.05 0.15,0.05 0.25,0.05c0.25,0 0.5,-0.25 0.5,-0.5V6C22.4,5.55 21.75,5.25 21,5zM21,18.5c-1.1,-0.35 -2.3,-0.5 -3.5,-0.5c-1.7,0 -4.15,0.65 -5.5,1.5V8c1.35,-0.85 3.8,-1.5 5.5,-1.5c1.2,0 2.4,0.15 3.5,0.5V18.5z"/>
      
    <path android:fillColor="@android:color/white" android:pathData="M17.5,10.5c0.88,0 1.73,0.09 2.5,0.26V9.24C19.21,9.09 18.36,9 17.5,9c-1.7,0 -3.24,0.29 -4.5,0.83v1.66C14.13,10.85 15.7,10.5 17.5,10.5z"/>
      
    <path android:fillColor="@android:color/white" android:pathData="M13,12.49v1.66c1.13,-0.64 2.7,-0.99 4.5,-0.99c0.88,0 1.73,0.09 2.5,0.26V11.9c-0.79,-0.15 -1.64,-0.24 -2.5,-0.24C15.8,11.66 14.26,11.96 13,12.49z"/>
      
    <path android:fillColor="@android:color/white" android:pathData="M17.5,14.33c-1.7,0 -3.24,0.29 -4.5,0.83v1.66c1.13,-0.64 2.7,-0.99 4.5,-0.99c0.88,0 1.73,0.09 2.5,0.26v-1.52C19.21,14.41 18.36,14.33 17.5,14.33z"/>
    
</vector>


===== Archivo: app\src\main\res\drawable\ic_close.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M19,6.41L17.59,5 12,10.59 6.41,5 5,6.41 10.59,12 5,17.59 6.41,19 12,13.41 17.59,19 19,17.59 13.41,12z"/>
    
</vector>


===== Archivo: app\src\main\res\drawable\ic_comment.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android" android:autoMirrored="true" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M21.99,4c0,-1.1 -0.89,-2 -1.99,-2L4,2c-1.1,0 -2,0.9 -2,2v12c0,1.1 0.9,2 2,2h14l4,4 -0.01,-18zM18,14L6,14v-2h12v2zM18,11L6,11L6,9h12v2zM18,8L6,8L6,6h12v2z"/>
    
</vector>


===== Archivo: app\src\main\res\drawable\ic_coo.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:fillType="evenOdd" android:pathData="M12,2C6.48,2 2,6.48 2,12c0,1.54 0.36,2.98 0.97,4.29L1,23l6.71,-1.97C9.02,21.64 10.46,22 12,22c5.52,0 10,-4.48 10,-10C22,6.48 17.52,2 12,2zM16,13h-3v3h-2v-3H8v-2h3V8h2v3h3V13z"/>
    
</vector>


===== Archivo: app\src\main\res\drawable\ic_corazon.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M12,21.35l-1.45,-1.32C5.4,15.36 2,12.28 2,8.5 2,5.42 4.42,3 7.5,3c1.74,0 3.41,0.81 4.5,2.09C13.09,3.81 14.76,3 16.5,3 19.58,3 22,5.42 22,8.5c0,3.78 -3.4,6.86 -8.55,11.54L12,21.35z"/>
    
</vector>


===== Archivo: app\src\main\res\drawable\ic_delete.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M6,19c0,1.1 0.9,2 2,2h8c1.1,0 2,-0.9 2,-2L18,7L6,7v12zM8.46,11.88l1.41,-1.41L12,12.59l2.12,-2.12 1.41,1.41L13.41,14l2.12,2.12 -1.41,1.41L12,15.41l-2.12,2.12 -1.41,-1.41L10.59,14l-2.13,-2.12zM15.5,4l-1,-1h-5l-1,1L5,4v2h14L19,4z"/>
    
</vector>


===== Archivo: app\src\main\res\drawable\ic_emojis.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M9,13m-1.25,0a1.25,1.25 0,1 1,2.5 0a1.25,1.25 0,1 1,-2.5 0"/>
      
    <path android:fillColor="@android:color/white" android:pathData="M20.77,8.58l-0.92,2.01c0.09,0.46 0.15,0.93 0.15,1.41 0,4.41 -3.59,8 -8,8s-8,-3.59 -8,-8c0,-0.05 0.01,-0.1 0,-0.14 2.6,-0.98 4.69,-2.99 5.74,-5.55C11.58,8.56 14.37,10 17.5,10c0.45,0 0.89,-0.04 1.33,-0.1l-0.6,-1.32 -0.88,-1.93 -1.93,-0.88 -2.79,-1.27 2.79,-1.27 0.71,-0.32C14.87,2.33 13.47,2 12,2 6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10c0,-1.47 -0.33,-2.87 -0.9,-4.13l-0.33,0.71z"/>
      
    <path android:fillColor="@android:color/white" android:pathData="M15,13m-1.25,0a1.25,1.25 0,1 1,2.5 0a1.25,1.25 0,1 1,-2.5 0"/>
      
    <path android:fillColor="@android:color/white" android:pathData="M20.6,5.6L19.5,8l-1.1,-2.4L16,4.5l2.4,-1.1L19.5,1l1.1,2.4L23,4.5z"/>
    
</vector>


===== Archivo: app\src\main\res\drawable\ic_favorite.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:autoMirrored="true"
    android:height="35dp"
    android:tint="#FFFFFF"
    android:viewportHeight="24"
    android:viewportWidth="24"
    android:width="35dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M22,9.24l-7.19,-0.62L12,2L9.19,8.63L2,9.24l5.46,4.73L5.82,21L12,17.27L18.18,21l-1.63,-7.03L22,9.24zM12,15.4V6.1l1.71,4.04l4.38,0.38l-3.32,2.88l1,4.28L12,15.4z"/>
    
</vector>


===== Archivo: app\src\main\res\drawable\ic_info.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM13,17h-2v-6h2v6zM13,9h-2L11,7h2v2z"/>
    
</vector>


===== Archivo: app\src\main\res\drawable\ic_launcher_background.xml =====


<?xml version="1.0" encoding="utf-8"?>
<vector
    android:height="108dp"
    android:width="108dp"
    android:viewportHeight="108"
    android:viewportWidth="108"
    xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="#3DDC84"
          android:pathData="M0,0h108v108h-108z"/>
    <path android:fillColor="#00000000" android:pathData="M9,0L9,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,0L19,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M29,0L29,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M39,0L39,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M49,0L49,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M59,0L59,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M69,0L69,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M79,0L79,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M89,0L89,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M99,0L99,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,9L108,9"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,19L108,19"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,29L108,29"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,39L108,39"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,49L108,49"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,59L108,59"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,69L108,69"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,79L108,79"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,89L108,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,99L108,99"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,29L89,29"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,39L89,39"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,49L89,49"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,59L89,59"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,69L89,69"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,79L89,79"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M29,19L29,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M39,19L39,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M49,19L49,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M59,19L59,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M69,19L69,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M79,19L79,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
</vector>


===== Archivo: app\src\main\res\drawable\ic_launcher_foreground.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="108"
    android:viewportHeight="108">
    <path android:pathData="M31,63.928c0,0 6.4,-11 12.1,-13.1c7.2,-2.6 26,-1.4 26,-1.4l38.1,38.1L107,108.928l-32,-1L31,63.928z">
        <aapt:attr name="android:fillColor">
            <gradient
                android:endX="85.84757"
                android:endY="92.4963"
                android:startX="42.9492"
                android:startY="49.59793"
                android:type="linear">
                <item
                    android:color="#44000000"
                    android:offset="0.0" />
                <item
                    android:color="#00000000"
                    android:offset="1.0" />
            </gradient>
        </aapt:attr>
    </path>
    <path
        android:fillColor="#FFFFFF"
        android:fillType="nonZero"
        android:pathData="M65.3,45.828l3.8,-6.6c0.2,-0.4 0.1,-0.9 -0.3,-1.1c-0.4,-0.2 -0.9,-0.1 -1.1,0.3l-3.9,6.7c-6.3,-2.8 -13.4,-2.8 -19.7,0l-3.9,-6.7c-0.2,-0.4 -0.7,-0.5 -1.1,-0.3C38.8,38.328 38.7,38.828 38.9,39.228l3.8,6.6C36.2,49.428 31.7,56.028 31,63.928h46C76.3,56.028 71.8,49.428 65.3,45.828zM43.4,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2c-0.3,-0.7 -0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C45.3,56.528 44.5,57.328 43.4,57.328L43.4,57.328zM64.6,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2s-0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C66.5,56.528 65.6,57.328 64.6,57.328L64.6,57.328z"
        android:strokeWidth="1"
        android:strokeColor="#00000000" />
</vector>


===== Archivo: app\src\main\res\drawable\ic_logout.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android" android:autoMirrored="true" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M17,7l-1.41,1.41L18.17,11H8v2h10.17l-2.58,2.58L17,17l5,-5zM4,5h8V3H4c-1.1,0 -2,0.9 -2,2v14c0,1.1 0.9,2 2,2h8v-2H4V5z"/>
    
</vector>


===== Archivo: app\src\main\res\drawable\ic_map.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:height="35dp"
    android:tint="@android:color/white"
    android:viewportHeight="24"
    android:viewportWidth="24"
    android:width="35dp">

    <path
        android:fillColor="@android:color/white"
        android:pathData="M20.5,3l-0.16,0.03L15,5.1 9,3 3.36,4.9c-0.21,0.07 -0.36,0.25 -0.36,0.48V20.5c0,0.28 0.22,0.5 0.5,0.5l0.16,-0.03L9,18.9l6,2.1 5.64,-1.9c0.21,-0.07 0.36,-0.25 0.36,-0.48V3.5c0,-0.28 -0.22,-0.5 -0.5,-0.5zM15,19l-6,-2.11V5l6,2.11V19z"/>

</vector>


===== Archivo: app\src\main\res\drawable\ic_megusta.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M1,21h4L5,9L1,9v12zM23,10c0,-1.1 -0.9,-2 -2,-2h-6.31l0.95,-4.57 0.03,-0.32c0,-0.41 -0.17,-0.79 -0.44,-1.06L14.17,1 7.59,7.59C7.22,7.95 7,8.45 7,9v10c0,1.1 0.9,2 2,2h9c0.83,0 1.54,-0.5 1.84,-1.22l3.02,-7.05c0.09,-0.23 0.14,-0.47 0.14,-0.73v-2z"/>
    
</vector>


===== Archivo: app\src\main\res\drawable\ic_notifications.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">

    <path android:fillColor="@android:color/white" android:pathData="M12,22c1.1,0 2,-0.9 2,-2h-4c0,1.1 0.89,2 2,2zM18,16v-5c0,-3.07 -1.64,-5.64 -4.5,-6.32L13.5,4c0,-0.83 -0.67,-1.5 -1.5,-1.5s-1.5,0.67 -1.5,1.5v0.68C7.63,5.36 6,7.92 6,11v5l-2,2v1h16v-1l-2,-2z"/>

</vector>


===== Archivo: app\src\main\res\drawable\ic_pause.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M6,19h4L10,5L6,5v14zM14,5v14h4L18,5h-4z"/>
    
</vector>


===== Archivo: app\src\main\res\drawable\ic_pause_red.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="#FFFFFF"
        android:pathData="M6,5h4v14H6zM14,5h4v14h-4z" />
</vector>


===== Archivo: app\src\main\res\drawable\ic_pending.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M17,12c-2.76,0 -5,2.24 -5,5s2.24,5 5,5c2.76,0 5,-2.24 5,-5S19.76,12 17,12zM18.65,19.35l-2.15,-2.15V14h1v2.79l1.85,1.85L18.65,19.35zM18,3h-3.18C14.4,1.84 13.3,1 12,1S9.6,1.84 9.18,3H6C4.9,3 4,3.9 4,5v15c0,1.1 0.9,2 2,2h6.11c-0.59,-0.57 -1.07,-1.25 -1.42,-2H6V5h2v3h8V5h2v5.08c0.71,0.1 1.38,0.31 2,0.6V5C20,3.9 19.1,3 18,3zM12,5c-0.55,0 -1,-0.45 -1,-1c0,-0.55 0.45,-1 1,-1c0.55,0 1,0.45 1,1C13,4.55 12.55,5 12,5z"/>
    
</vector>


===== Archivo: app\src\main\res\drawable\ic_perfil.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M19,3h-4.18C14.4,1.84 13.3,1 12,1c-1.3,0 -2.4,0.84 -2.82,2L5,3c-1.1,0 -2,0.9 -2,2v14c0,1.1 0.9,2 2,2h14c1.1,0 2,-0.9 2,-2L21,5c0,-1.1 -0.9,-2 -2,-2zM12,3c0.55,0 1,0.45 1,1s-0.45,1 -1,1 -1,-0.45 -1,-1 0.45,-1 1,-1zM12,7c1.66,0 3,1.34 3,3s-1.34,3 -3,3 -3,-1.34 -3,-3 1.34,-3 3,-3zM18,19L6,19v-1.4c0,-2 4,-3.1 6,-3.1s6,1.1 6,3.1L18,19z"/>
    
</vector>


===== Archivo: app\src\main\res\drawable\ic_photo.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M12,12m-3.2,0a3.2,3.2 0,1 1,6.4 0a3.2,3.2 0,1 1,-6.4 0"/>
      
    <path android:fillColor="@android:color/white" android:pathData="M9,2L7.17,4L4,4c-1.1,0 -2,0.9 -2,2v12c0,1.1 0.9,2 2,2h16c1.1,0 2,-0.9 2,-2L22,6c0,-1.1 -0.9,-2 -2,-2h-3.17L15,2L9,2zM12,17c-2.76,0 -5,-2.24 -5,-5s2.24,-5 5,-5 5,2.24 5,5 -2.24,5 -5,5z"/>
    
</vector>


===== Archivo: app\src\main\res\drawable\ic_places.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:height="35dp"
    android:tint="#FFFFFF"
    android:viewportHeight="24"
    android:viewportWidth="24"
    android:width="35dp">

    <path android:fillColor="@android:color/white" android:pathData="M20.54,5.23l-1.39,-1.68C18.88,3.21 18.47,3 18,3H6c-0.47,0 -0.88,0.21 -1.16,0.55L3.46,5.23C3.17,5.57 3,6.02 3,6.5V19c0,1.1 0.9,2 2,2h14c1.1,0 2,-0.9 2,-2V6.5c0,-0.48 -0.17,-0.93 -0.46,-1.27zM12,17.5L6.5,12H10v-2h4v2h3.5L12,17.5zM5.12,5l0.81,-1h12l0.94,1H5.12z"/>

</vector>


===== Archivo: app\src\main\res\drawable\ic_play.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M8,5v14l11,-7z"/>
    
</vector>


===== Archivo: app\src\main\res\drawable\ic_recent.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:height="35dp"
    android:tint="#FFFFFF"
    android:viewportHeight="24"
    android:viewportWidth="24"
    android:width="35dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M11.71,17.99C8.53,17.84 6,15.22 6,12c0,-3.31 2.69,-6 6,-6c3.22,0 5.84,2.53 5.99,5.71l-2.1,-0.63C15.48,9.31 13.89,8 12,8c-2.21,0 -4,1.79 -4,4c0,1.89 1.31,3.48 3.08,3.89L11.71,17.99zM22,12c0,0.3 -0.01,0.6 -0.04,0.9l-1.97,-0.59C20,12.21 20,12.1 20,12c0,-4.42 -3.58,-8 -8,-8s-8,3.58 -8,8s3.58,8 8,8c0.1,0 0.21,0 0.31,-0.01l0.59,1.97C12.6,21.99 12.3,22 12,22C6.48,22 2,17.52 2,12C2,6.48 6.48,2 12,2S22,6.48 22,12zM18.23,16.26L22,15l-10,-3l3,10l1.26,-3.77l4.27,4.27l1.98,-1.98L18.23,16.26z"/>
    
</vector>


===== Archivo: app\src\main\res\drawable\ic_record.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M19,3L5,3c-1.1,0 -2,0.9 -2,2v7c0,1.1 0.9,2 2,2h14c1.1,0 2,-0.9 2,-2L21,5c0,-1.1 -0.9,-2 -2,-2zM19,9h-4c0,1.62 -1.38,3 -3,3s-3,-1.38 -3,-3L5,9L5,5h14v4zM15,16h6v3c0,1.1 -0.9,2 -2,2L5,21c-1.1,0 -2,-0.9 -2,-2v-3h6c0,1.66 1.34,3 3,3s3,-1.34 3,-3z"/>
    
</vector>


===== Archivo: app\src\main\res\drawable\ic_record_red.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="#FFFFFF"
        android:pathData="M12,8a4,4 0 1,0 0,8a4,4 0 0,0 0,-8z" />
</vector>


===== Archivo: app\src\main\res\drawable\ic_rejected.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M12,2C6.47,2 2,6.47 2,12s4.47,10 10,10 10,-4.47 10,-10S17.53,2 12,2zM17,15.59L15.59,17 12,13.41 8.41,17 7,15.59 10.59,12 7,8.41 8.41,7 12,10.59 15.59,7 17,8.41 13.41,12 17,15.59z"/>
    
</vector>


===== Archivo: app\src\main\res\drawable\ic_reply.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android" android:autoMirrored="true" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M10,9V5l-7,7 7,7v-4.1c5,0 8.5,1.6 11,5.1 -1,-5 -4,-10 -11,-11z"/>
    
</vector>


===== Archivo: app\src\main\res\drawable\ic_save_audio.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M17,3L5,3c-1.11,0 -2,0.9 -2,2v14c0,1.1 0.89,2 2,2h14c1.1,0 2,-0.9 2,-2L21,7l-4,-4zM12,19c-1.66,0 -3,-1.34 -3,-3s1.34,-3 3,-3 3,1.34 3,3 -1.34,3 -3,3zM15,9L5,9L5,5h10v4z"/>
    
</vector>


===== Archivo: app\src\main\res\drawable\ic_search.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android" android:autoMirrored="true" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M7,9H2V7h5V9zM7,12H2v2h5V12zM20.59,19l-3.83,-3.83C15.96,15.69 15.02,16 14,16c-2.76,0 -5,-2.24 -5,-5s2.24,-5 5,-5s5,2.24 5,5c0,1.02 -0.31,1.96 -0.83,2.75L22,17.59L20.59,19zM17,11c0,-1.65 -1.35,-3 -3,-3s-3,1.35 -3,3s1.35,3 3,3S17,12.65 17,11zM2,19h10v-2H2V19z"/>
    
</vector>


===== Archivo: app\src\main\res\drawable\ic_search_action.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android" android:autoMirrored="true" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M2.01,21L23,12 2.01,3 2,10l15,2 -15,2z"/>
    
</vector>


===== Archivo: app\src\main\res\drawable\ic_send.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android" android:autoMirrored="true" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M2.01,21L23,12 2.01,3 2,10l15,2 -15,2z"/>
    
</vector>


===== Archivo: app\src\main\res\drawable\ic_settings.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M19.14,12.94c0.04,-0.3 0.06,-0.61 0.06,-0.94c0,-0.32 -0.02,-0.64 -0.07,-0.94l2.03,-1.58c0.18,-0.14 0.23,-0.41 0.12,-0.61l-1.92,-3.32c-0.12,-0.22 -0.37,-0.29 -0.59,-0.22l-2.39,0.96c-0.5,-0.38 -1.03,-0.7 -1.62,-0.94L14.4,2.81c-0.04,-0.24 -0.24,-0.41 -0.48,-0.41h-3.84c-0.24,0 -0.43,0.17 -0.47,0.41L9.25,5.35C8.66,5.59 8.12,5.92 7.63,6.29L5.24,5.33c-0.22,-0.08 -0.47,0 -0.59,0.22L2.74,8.87C2.62,9.08 2.66,9.34 2.86,9.48l2.03,1.58C4.84,11.36 4.8,11.69 4.8,12s0.02,0.64 0.07,0.94l-2.03,1.58c-0.18,0.14 -0.23,0.41 -0.12,0.61l1.92,3.32c0.12,0.22 0.37,0.29 0.59,0.22l2.39,-0.96c0.5,0.38 1.03,0.7 1.62,0.94l0.36,2.54c0.05,0.24 0.24,0.41 0.48,0.41h3.84c0.24,0 0.44,-0.17 0.47,-0.41l0.36,-2.54c0.59,-0.24 1.13,-0.56 1.62,-0.94l2.39,0.96c0.22,0.08 0.47,0 0.59,-0.22l1.92,-3.32c0.12,-0.22 0.07,-0.47 -0.12,-0.61L19.14,12.94zM12,15.6c-1.98,0 -3.6,-1.62 -3.6,-3.6s1.62,-3.6 3.6,-3.6s3.6,1.62 3.6,3.6S13.98,15.6 12,15.6z"/>
    
</vector>


===== Archivo: app\src\main\res\drawable\ic_sound_off.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android" android:autoMirrored="true" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M16.5,12c0,-1.77 -1.02,-3.29 -2.5,-4.03v2.21l2.45,2.45c0.03,-0.2 0.05,-0.41 0.05,-0.63zM19,12c0,0.94 -0.2,1.82 -0.54,2.64l1.51,1.51C20.63,14.91 21,13.5 21,12c0,-4.28 -2.99,-7.86 -7,-8.77v2.06c2.89,0.86 5,3.54 5,6.71zM4.27,3L3,4.27 7.73,9L3,9v6h4l5,5v-6.73l4.25,4.25c-0.67,0.52 -1.42,0.93 -2.25,1.18v2.06c1.38,-0.31 2.63,-0.95 3.69,-1.81L19.73,21 21,19.73l-9,-9L4.27,3zM12,4L9.91,6.09 12,8.18L12,4z"/>
    
</vector>


===== Archivo: app\src\main\res\drawable\ic_sound_on.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android" android:autoMirrored="true" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M3,9v6h4l5,5L12,4L7,9L3,9zM16.5,12c0,-1.77 -1.02,-3.29 -2.5,-4.03v8.05c1.48,-0.73 2.5,-2.25 2.5,-4.02zM14,3.23v2.06c2.89,0.86 5,3.54 5,6.71s-2.11,5.85 -5,6.71v2.06c4.01,-0.91 7,-4.49 7,-8.77s-2.99,-7.86 -7,-8.77z"/>
    
</vector>


===== Archivo: app\src\main\res\drawable\ic_stop.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M6,6h12v12H6z"/>
    
</vector>


===== Archivo: app\src\main\res\drawable\ic_stop_red.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="#FFFFFF"
        android:pathData="M6,6h12v12H6z" />
</vector>


===== Archivo: app\src\main\res\drawable\ic_supervised.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M11.99,2c-5.52,0 -10,4.48 -10,10s4.48,10 10,10 10,-4.48 10,-10 -4.48,-10 -10,-10zM15.6,8.34c1.07,0 1.93,0.86 1.93,1.93 0,1.07 -0.86,1.93 -1.93,1.93 -1.07,0 -1.93,-0.86 -1.93,-1.93 -0.01,-1.07 0.86,-1.93 1.93,-1.93zM9.6,6.76c1.3,0 2.36,1.06 2.36,2.36 0,1.3 -1.06,2.36 -2.36,2.36s-2.36,-1.06 -2.36,-2.36c0,-1.31 1.05,-2.36 2.36,-2.36zM9.6,15.89v3.75c-2.4,-0.75 -4.3,-2.6 -5.14,-4.96 1.05,-1.12 3.67,-1.69 5.14,-1.69 0.53,0 1.2,0.08 1.9,0.22 -1.64,0.87 -1.9,2.02 -1.9,2.68zM11.99,20c-0.27,0 -0.53,-0.01 -0.79,-0.04v-4.07c0,-1.42 2.94,-2.13 4.4,-2.13 1.07,0 2.92,0.39 3.84,1.15 -1.17,2.97 -4.06,5.09 -7.45,5.09z"/>
    
</vector>


===== Archivo: app\src\main\res\drawable\ic_text_format.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M2.5,4v3h5v12h3V7h5V4H2.5zM21.5,9h-9v3h3v7h3v-7h3V9z"/>
    
</vector>


===== Archivo: app\src\main\res\drawable\ic_upload.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M14,2L6,2c-1.1,0 -1.99,0.9 -1.99,2L4,20c0,1.1 0.89,2 1.99,2L18,22c1.1,0 2,-0.9 2,-2L20,8l-6,-6zM18,20L6,20L6,4h7v5h5v11zM8,15.01l1.41,1.41L11,14.84L11,19h2v-4.16l1.59,1.59L16,15.01 12.01,11z"/>
    
</vector>


===== Archivo: app\src\main\res\drawable\ic_video.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M4,6L2,6v14c0,1.1 0.9,2 2,2h14v-2L4,20L4,6zM20,2L8,2c-1.1,0 -2,0.9 -2,2v12c0,1.1 0.9,2 2,2h12c1.1,0 2,-0.9 2,-2L22,4c0,-1.1 -0.9,-2 -2,-2zM12,14.5v-9l6,4.5 -6,4.5z"/>
    
</vector>


===== Archivo: app\src\main\res\drawable\ic_zoom_in_out.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M15,3l2.3,2.3l-2.89,2.87l1.42,1.42L18.7,6.7L21,9V3H15zM3,9l2.3,-2.3l2.87,2.89l1.42,-1.42L6.7,5.3L9,3H3V9zM9,21l-2.3,-2.3l2.89,-2.87l-1.42,-1.42L5.3,17.3L3,15v6H9zM21,15l-2.3,2.3l-2.87,-2.89l-1.42,1.42l2.89,2.87L15,21h6V15z"/>
    
</vector>


===== Archivo: app\src\main\res\drawable\placeholder_image.xml =====


<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M21,19V5c0,-1.1 -0.9,-2 -2,-2H5c-1.1,0 -2,0.9 -2,2v14c0,1.1 0.9,2 2,2h14c1.1,0 2,-0.9 2,-2zM8.5,13.5l2.5,3.01L14.5,12l4.5,6H5l3.5,-4.5z"/>
    
</vector>


===== Archivo: app\src\main\res\drawable\spinner_background.xml =====


<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle">
    <stroke android:width="1dp" android:color="@color/white"/>
    <corners android:radius="4dp"/>
    <padding android:left="12dp" android:right="12dp" android:top="12dp" android:bottom="12dp"/>
</shape>


===== Archivo: app\src\main\res\layout\activity_admin_profile.xml =====


<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/admin_profile_main"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@drawable/gradient_background"
    tools:context=".AdminProfileActivity">

    <androidx.constraintlayout.widget.ConstraintLayout
        android:id="@+id/header_container_admin"
        android:layout_width="0dp"
        android:layout_height="?attr/actionBarSize"
        android:paddingHorizontal="16dp"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

        <ImageButton
            android:id="@+id/btn_back_admin"
            android:layout_width="48dp"
            android:layout_height="48dp"
            android:src="@drawable/ic_arrow_back"
            android:background="?attr/selectableItemBackgroundBorderless"
            android:contentDescription="@string/back_button_desc"
            app:tint="@color/white"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintBottom_toBottomOf="parent"/>

        <ImageView
            android:id="@+id/icon_admin_profile"
            android:layout_width="24dp"
            android:layout_height="24dp"
            android:src="@drawable/ic_admin"
            android:contentDescription="@string/admin_icon_desc"
            app:tint="@color/white"
            app:layout_constraintStart_toEndOf="@id/btn_back_admin"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintBottom_toBottomOf="parent"
            android:layout_marginStart="8dp"/>

        <TextView
            android:id="@+id/title_admin_profile"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:text="@string/admin_profile_activity_title"
            android:textColor="@color/white"
            android:textSize="20sp"
            android:textStyle="bold"
            android:gravity="center_horizontal"
            app:layout_constraintStart_toEndOf="@id/icon_admin_profile"
            app:layout_constraintEnd_toStartOf="@+id/icon_notification_admin"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintBottom_toBottomOf="parent"
            android:layout_marginStart="8dp"
            android:layout_marginEnd="8dp"/>

        <ImageView
            android:id="@+id/icon_notification_admin"
            android:layout_width="48dp"
            android:layout_height="48dp"
            android:src="@drawable/ic_notifications"
            android:contentDescription="@string/notifications"
            app:tint="@color/white"
            android:padding="6dp"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintBottom_toBottomOf="parent"/>

    </androidx.constraintlayout.widget.ConstraintLayout>

    <LinearLayout
        android:layout_width="0dp"
        android:layout_height="0dp"
        android:orientation="vertical"
        app:layout_constraintTop_toBottomOf="@id/header_container_admin"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintBottom_toBottomOf="parent">

        <com.google.android.material.tabs.TabLayout
            android:id="@+id/tab_layout_admin"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:background="@drawable/gradient_background"
            app:tabTextColor="@color/grey_light"
            app:tabSelectedTextColor="@color/white"
            app:tabIndicatorColor="@color/blue_primary"
            app:tabIndicatorHeight="2dp"
            app:tabGravity="fill"
            app:tabMode="fixed"/>

        <androidx.viewpager2.widget.ViewPager2
            android:id="@+id/view_pager_admin"
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_weight="1"/>

    </LinearLayout>

</androidx.constraintlayout.widget.ConstraintLayout>


===== Archivo: app\src\main\res\layout\activity_comment.xml =====


<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@drawable/gradient_background"
    android:orientation="vertical">

    <!-- Barra de navegación con título y número de publicación -->
    <androidx.appcompat.widget.Toolbar
        android:id="@+id/toolbar_comment"
        android:layout_width="match_parent"
        android:layout_height="?attr/actionBarSize"
        app:navigationIcon="@drawable/ic_arrow_back">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:gravity="center_vertical"
            android:orientation="horizontal">

            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:text="Título de la Publicación/Imagen/Video"
                android:textColor="#FFFFFF"
                android:textSize="18sp"
                android:textStyle="bold"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text=" # Publicación"
                android:textColor="#E1E1E1"
                android:textSize="14sp"
                android:layout_marginStart="8dp"/>
        </LinearLayout>
    </androidx.appcompat.widget.Toolbar>

    <!-- Contadores y metadatos -->
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:padding="16dp">

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="😃 99"
            android:textColor="#FFFFFF"
            android:textSize="16sp"/>

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="  👍 1.5K"
            android:textColor="#FFFFFF"
            android:textSize="16sp"
            android:layout_marginStart="16dp"/>

        <TextView
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Ubicación: Ejemplo | Fecha: 2024"
            android:textColor="#E1E1E1"
            android:textSize="14sp"
            android:gravity="end"/>
    </LinearLayout>

    <View
        android:layout_width="match_parent"
        android:layout_height="1dp"
        android:background="#44FFFFFF"/>

    <!-- Filtros -->
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:padding="16dp">

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Filtrar:"
            android:textColor="#FFFFFF"
            android:textSize="16sp"/>

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text=" Recientes"
            android:textColor="#E1E1E1"
            android:textSize="16sp"
            android:layout_marginStart="8dp"/>

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text=" | Populares"
            android:textColor="#E1E1E1"
            android:textSize="16sp"/>

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text=" | Todos"
            android:textColor="#E1E1E1"
            android:textSize="16sp"/>
    </LinearLayout>

    <View
        android:layout_width="match_parent"
        android:layout_height="1dp"
        android:background="#44FFFFFF"/>

    <!-- Lista de comentarios -->
    <ScrollView
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical">

            <!-- Comentario de ejemplo 1 -->
            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="vertical"
                android:padding="16dp">

                <TextView
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:text="Usuario1"
                    android:textColor="#FFFFFF"
                    android:textSize="16sp"
                    android:textStyle="bold"/>

                <TextView
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:text="Este es un comentario..."
                    android:textColor="#E1E1E1"
                    android:textSize="16sp"
                    android:layout_marginTop="4dp"/>

                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="horizontal"
                    android:layout_marginTop="8dp">

                    <ImageView
                        android:layout_width="24dp"
                        android:layout_height="24dp"
                        android:src="@drawable/ic_reply"
                        app:tint="#FFFFFF"/>

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Responder"
                        android:textColor="#B3FFFFFF"
                        android:textSize="14sp"
                        android:layout_marginStart="4dp"/>

                    <ImageView
                        android:layout_width="24dp"
                        android:layout_height="24dp"
                        android:src="@drawable/ic_megusta"
                        app:tint="#FFFFFF"
                        android:layout_marginStart="16dp"/>

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Me gusta"
                        android:textColor="#B3FFFFFF"
                        android:textSize="14sp"
                        android:layout_marginStart="4dp"/>

                    <ImageView
                        android:layout_width="24dp"
                        android:layout_height="24dp"
                        android:src="@drawable/ic_emojis"
                        app:tint="#FFFFFF"
                        android:layout_marginStart="16dp"/>

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Emoji"
                        android:textColor="#B3FFFFFF"
                        android:textSize="14sp"
                        android:layout_marginStart="4dp"/>
                </LinearLayout>

                <TextView
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:text="Fecha: 2024-04-21  Hora: 15:30"
                    android:textColor="#B3FFFFFF"
                    android:textSize="12sp"
                    android:layout_marginTop="8dp"
                    android:gravity="end"/>
            </LinearLayout>

            <View
                android:layout_width="match_parent"
                android:layout_height="1dp"
                android:background="#44FFFFFF"/>

            <!-- Comentario de ejemplo 2 -->
            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="vertical"
                android:padding="16dp">

                <TextView
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:text="Usuario2"
                    android:textColor="#FFFFFF"
                    android:textSize="16sp"
                    android:textStyle="bold"/>

                <TextView
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:text="Otro comentario aquí"
                    android:textColor="#E1E1E1"
                    android:textSize="16sp"
                    android:layout_marginTop="4dp"/>

                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="horizontal"
                    android:layout_marginTop="8dp">

                    <ImageView
                        android:layout_width="24dp"
                        android:layout_height="24dp"
                        android:src="@drawable/ic_reply"
                        app:tint="#FFFFFF"/>

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Responder"
                        android:textColor="#B3FFFFFF"
                        android:textSize="14sp"
                        android:layout_marginStart="4dp"/>

                    <ImageView
                        android:layout_width="24dp"
                        android:layout_height="24dp"
                        android:src="@drawable/ic_megusta"
                        app:tint="#FFFFFF"
                        android:layout_marginStart="16dp"/>

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Me gusta"
                        android:textColor="#B3FFFFFF"
                        android:textSize="14sp"
                        android:layout_marginStart="4dp"/>

                    <ImageView
                        android:layout_width="24dp"
                        android:layout_height="24dp"
                        android:src="@drawable/ic_emojis"
                        app:tint="#FFFFFF"
                        android:layout_marginStart="16dp"/>

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Emoji"
                        android:textColor="#B3FFFFFF"
                        android:textSize="14sp"
                        android:layout_marginStart="4dp"/>
                </LinearLayout>

                <TextView
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:text="Fecha: 2024-04-21  Hora: 14:00"
                    android:textColor="#B3FFFFFF"
                    android:textSize="12sp"
                    android:layout_marginTop="8dp"
                    android:gravity="end"/>
            </LinearLayout>
        </LinearLayout>
    </ScrollView>

    <!-- Barra de entrada de comentario -->
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:padding="8dp">

        <EditText
            android:id="@+id/editText_comment"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:hint="Escribir un comentario"
            android:background="@drawable/glassmorphism_background"
            android:padding="12dp"
            android:textColor="#FFFFFF"
            android:textColorHint="#B3FFFFFF"/>

        <ImageView
            android:id="@+id/button_send_comment"
            android:layout_width="48dp"
            android:layout_height="48dp"
            android:layout_marginStart="8dp"
            android:background="?attr/selectableItemBackgroundBorderless"
            android:clickable="true"
            android:focusable="true"
            android:contentDescription="@string/enviar_comentario"
            android:padding="8dp"
            android:src="@drawable/ic_send"
            app:tint="#FFFFFF"/>
    </LinearLayout>

</LinearLayout>


===== Archivo: app\src\main\res\layout\activity_edit_profile.xml =====


<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@drawable/gradient_background"
    tools:context=".EditProfileActivity">

    <androidx.constraintlayout.widget.ConstraintLayout
        android:id="@+id/header_container_edit_profile"
        android:layout_width="0dp"
        android:layout_height="?attr/actionBarSize"
        android:paddingHorizontal="16dp"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

        <ImageButton
            android:id="@+id/btn_back_edit_profile"
            android:layout_width="48dp"
            android:layout_height="48dp"
            android:src="@drawable/ic_arrow_back"
            android:background="?attr/selectableItemBackgroundBorderless"
            android:contentDescription="@string/back_button_desc"
            app:tint="@color/white"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintBottom_toBottomOf="parent"/>

        <TextView
            android:id="@+id/title_edit_profile"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/edit_profile"
            android:textColor="@color/white"
            android:textSize="20sp"
            android:textStyle="bold"
            app:layout_constraintStart_toEndOf="@id/btn_back_edit_profile"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintHorizontal_bias="0.4"/>

    </androidx.constraintlayout.widget.ConstraintLayout>

    <ScrollView
        android:layout_width="0dp"
        android:layout_height="0dp"
        app:layout_constraintTop_toBottomOf="@id/header_container_edit_profile"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintBottom_toBottomOf="parent">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:padding="16dp"
            android:gravity="center_horizontal">

            <FrameLayout
                android:id="@+id/profile_picture_container"
                android:layout_width="120dp"
                android:layout_height="120dp"
                android:layout_marginTop="24dp"
                android:layout_marginBottom="8dp"
                android:background="@drawable/glassmorphism_background"
                android:padding="4dp"
                android:clickable="true"
                android:focusable="true"
                android:foreground="?attr/selectableItemBackgroundBorderless">

                <ImageView
                    android:id="@+id/image_profile_picture"
                    android:layout_width="match_parent"
                    android:layout_height="match_parent"
                    android:src="@drawable/ic_perfil"
                    android:contentDescription="@string/my_profile"
                    android:scaleType="centerCrop"
                    android:background="@android:color/transparent"
                    tools:src="@drawable/ic_perfil"/>

                <ImageView
                    android:layout_width="36dp"
                    android:layout_height="36dp"
                    android:src="@drawable/ic_photo"
                    android:layout_gravity="bottom|end"
                    android:layout_margin="4dp"
                    app:tint="@color/blue_primary"
                    android:background="@drawable/glassmorphism_background"
                    android:padding="4dp"
                    android:elevation="2dp"
                    android:contentDescription="@string/change_profile_picture_desc"/>

                <!-- El ImageButton para eliminar foto se mantiene como 'gone' por ahora,
                     ya que la lógica de eliminación de foto no se ha implementado completamente. -->
                <ImageButton
                    android:id="@+id/imageButtonDeleteProfilePicture"
                    android:layout_width="36dp"
                    android:layout_height="36dp"
                    android:layout_gravity="top|end"
                    android:layout_margin="4dp"
                    android:padding="4dp"
                    android:src="@drawable/ic_delete"
                    android:background="@drawable/glassmorphism_background"
                    android:elevation="2dp"
                    android:contentDescription="@string/delete_profile_picture_desc"
                    android:visibility="gone" />
            </FrameLayout>

            <com.google.android.material.textfield.TextInputLayout
                android:id="@+id/textInputLayoutUsername"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="24dp"
                android:layout_marginHorizontal="24dp"
                android:hint="@string/hint_username_edit"
                style="@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox"
                app:hintTextColor="@color/hint_text_color_light"
                app:boxStrokeColor="@color/blue_primary"
                app:boxBackgroundMode="outline"
                app:boxBackgroundColor="@color/glass_background">

                <com.google.android.material.textfield.TextInputEditText
                    android:id="@+id/edit_text_username"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:textColor="@color/glass_text"
                    android:textColorHint="@color/glass_hint"
                    android:inputType="textPersonName"
                    android:backgroundTint="@color/blue_primary"/>
            </com.google.android.material.textfield.TextInputLayout>

            <TextView
                android:id="@+id/textViewUsernamePermanentInfo"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="4dp"
                android:layout_marginHorizontal="28dp"
                android:text="@string/username_already_set_info"
                android:textColor="@color/blue_light"
                android:textSize="12sp"
                android:visibility="gone"
                tools:visibility="visible"/>

            <TextView
                android:id="@+id/textViewLocationLabel"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="16dp"
                android:layout_marginHorizontal="28dp"
                android:text="@string/label_location_edit_profile"
                android:textColor="@color/glass_hint"
                android:textSize="12sp"/>

            <Spinner
                android:id="@+id/spinner_location_edit_profile"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:minHeight="48dp"
                android:layout_marginTop="4dp"
                android:layout_marginHorizontal="24dp"
                android:background="@drawable/spinner_background"
                android:paddingStart="12dp"
                android:paddingEnd="12dp"
                android:paddingTop="12dp"
                android:paddingBottom="12dp"
                android:popupBackground="@color/glass_background"
                android:spinnerMode="dropdown"
                android:contentDescription="@string/content_desc_select_state_edit_profile"/>

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="horizontal"
                android:layout_marginTop="32dp"
                android:gravity="center">

                <com.google.android.material.button.MaterialButton
                    android:id="@+id/btn_cancel_edit"
                    style="@style/Widget.MaterialComponents.Button.TextButton"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/cancelar"
                    android:textColor="@color/grey_light"
                    android:layout_marginEnd="16dp"/>

                <com.google.android.material.button.MaterialButton
                    android:id="@+id/btn_save_profile"
                    style="@style/Widget.App.Button.Primary"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/save_changes" />
            </LinearLayout>
        </LinearLayout>
    </ScrollView>
</androidx.constraintlayout.widget.ConstraintLayout>


===== Archivo: app\src\main\res\layout\activity_image_viewer.xml =====


<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@drawable/gradient_background"
    tools:context=".ImageViewerActivity">

    <LinearLayout
        android:id="@+id/headerLayoutImageViewer"
        android:layout_width="0dp"
        android:layout_height="?attr/actionBarSize"
        android:orientation="horizontal"
        android:gravity="center_vertical"
        android:paddingHorizontal="16dp"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

        <ImageView
            android:id="@+id/btnBackImageViewer"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:minWidth="48dp"
            android:minHeight="48dp"
            android:padding="12dp"
            android:src="@drawable/ic_arrow_back"
            android:contentDescription="@string/back_button_desc"
            android:background="?attr/selectableItemBackgroundBorderless"
            android:clickable="true"
            android:focusable="true"/>

        <TextView
            android:id="@+id/screenTitleImageViewer"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="@string/title_detail_image"
            android:textColor="@color/white"
            android:textSize="20sp"
            android:textStyle="bold"
            android:gravity="center_vertical"
            android:paddingStart="16dp"
            android:paddingEnd="16dp"/>
    </LinearLayout>

    <TextView
        android:id="@+id/textViewPendingReviewStatusImage"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:text="@string/status_pending_review_message"
        android:textColor="@color/blue_light"
        android:background="#40000000"
        android:padding="8dp"
        android:gravity="center"
        android:textSize="14sp"
        android:textStyle="italic"
        android:visibility="gone"
        app:layout_constraintTop_toBottomOf="@id/headerLayoutImageViewer"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        tools:visibility="visible"/>

    <ScrollView
        android:id="@+id/scrollViewImageViewerContent"
        android:layout_width="0dp"
        android:layout_height="0dp"
        app:layout_constraintTop_toBottomOf="@id/textViewPendingReviewStatusImage"
        app:layout_constraintBottom_toTopOf="@+id/interactionLayoutImage"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:padding="16dp">

            <TextView
                android:id="@+id/imageTitleTextViewer"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textColor="@color/white"
                android:textSize="22sp"
                android:textStyle="bold"
                android:layout_marginBottom="8dp"
                tools:text="Título de la Imagen"/>

            <TextView
                android:id="@+id/imageAuthorTextViewer"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textColor="@color/glass_hint"
                android:textSize="14sp"
                android:layout_marginBottom="4dp"
                tools:text="Autor: Usuario Ejemplo"/>

            <TextView
                android:id="@+id/imageDateTextViewer"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textColor="@color/glass_hint"
                android:textSize="14sp"
                android:layout_marginBottom="16dp"
                tools:text="Fecha: 01/01/2024"/>

            <ImageView
                android:id="@+id/imageViewerView"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:adjustViewBounds="true"
                android:scaleType="fitCenter"
                tools:src="@drawable/placeholder_image"
                android:layout_marginBottom="16dp"
                android:contentDescription="@string/content_desc_main_image"/>

            <TextView
                android:id="@+id/imageLocationTextViewer"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textColor="@color/glass_hint"
                android:textSize="14sp"
                android:layout_marginBottom="16dp"
                tools:text="Ubicación: Ciudad de México"/>

            <TextView
                android:id="@+id/imageDescriptionTextViewer"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textColor="@color/white"
                android:textSize="16sp"
                android:lineSpacingMultiplier="1.2"
                tools:text="Descripción detallada de la imagen paranormal..."/>

        </LinearLayout>
    </ScrollView>

    <LinearLayout
        android:id="@+id/interactionLayoutImage"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:padding="8dp"
        android:gravity="center_vertical"
        android:background="@color/glass_background"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        tools:visibility="visible">

        <ImageButton
            android:id="@+id/likeButtonImage"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:src="@drawable/ic_megusta"
            app:tint="@color/white"
            android:background="?attr/selectableItemBackgroundBorderless"
            android:padding="8dp"
            android:contentDescription="@string/me_gusta"/>

        <TextView
            android:id="@+id/likesCountImage"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textColor="@color/white"
            android:layout_marginStart="4dp"
            android:layout_marginEnd="16dp"
            tools:text="123"/>

        <ImageButton
            android:id="@+id/commentButtonImage"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:src="@drawable/ic_comment"
            app:tint="@color/white"
            android:background="?attr/selectableItemBackgroundBorderless"
            android:padding="8dp"
            android:contentDescription="@string/ver_comentarios"/>
        <TextView
            android:id="@+id/commentsCountImage"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textColor="@color/white"
            android:layout_marginStart="4dp"
            tools:text="45"/>

    </LinearLayout>

</androidx.constraintlayout.widget.ConstraintLayout>


===== Archivo: app\src\main\res\layout\activity_main.xml =====


<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/main"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@drawable/gradient_background"
    tools:context=".MainActivity">

    <LinearLayout
        android:id="@+id/top_icons_container"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:layout_marginTop="16dp"
        android:layout_marginEnd="16dp"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

        <ImageView
            android:id="@+id/icon_sound"
            android:layout_width="46dp"
            android:layout_height="46dp"
            android:src="@drawable/ic_sound_on"
            android:contentDescription="@string/sound_on"
            android:padding="6dp"
            android:layout_gravity="center"
            app:tint="#FFFFFF"/> <ImageView
        android:id="@+id/icon_notification"
        android:layout_width="46dp"
        android:layout_height="46dp"
        android:src="@drawable/ic_notifications"
        android:contentDescription="@string/notifications"
        android:padding="6dp"
        android:layout_marginStart="16dp"
        android:layout_gravity="center"
        app:tint="#FFFFFF"/>

    </LinearLayout>

    <LinearLayout
        android:id="@+id/header_container"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:gravity="center_horizontal"
        android:layout_marginTop="32dp"
        app:layout_constraintTop_toBottomOf="@id/top_icons_container"
        app:layout_constraintBottom_toTopOf="@+id/search_bar_container"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintVertical_chainStyle="spread_inside"
        app:layout_constraintVertical_bias="0.2">

        <LinearLayout
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:gravity="center_vertical">

            <ImageView
                android:id="@+id/logo_calavera"
                android:layout_width="72dp"
                android:layout_height="72dp"
                android:src="@drawable/calaverita"
                android:contentDescription="@string/logo_mexico_paranormal"/>

            <LinearLayout
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:orientation="vertical"
                android:layout_marginStart="16dp">

                <TextView
                    android:id="@+id/text_mexico"
                    style="@style/TextAppearance.Headline"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/mexico"
                    android:textColor="#FFFFFF"
                    android:textSize="28sp"
                    android:fontFamily="@font/weiss_antiqua"/>

                <TextView
                    android:id="@+id/text_paranormal"
                    style="@style/TextAppearance.Headline"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/paranormal"
                    android:textColor="#FFFFFF"
                    android:textSize="20sp"
                    android:fontFamily="@font/weiss_antiqua"/>
            </LinearLayout>
        </LinearLayout>

        <TextView
            android:id="@+id/text_slogan"
            style="@style/TextAppearance.Slogan"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/slogan"
            android:textColor="#E1E1E1"
            android:layout_marginTop="8dp"
            android:layout_gravity="center_horizontal"/>
    </LinearLayout>

    <androidx.constraintlayout.widget.ConstraintLayout
        android:id="@+id/search_bar_container"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:background="@drawable/glassmorphism_background"
        android:layout_marginTop="24dp"
        android:layout_marginHorizontal="16dp"
        android:paddingVertical="8dp"
        android:paddingStart="12dp"
        android:paddingEnd="12dp"
        app:layout_constraintTop_toBottomOf="@id/header_container"
        app:layout_constraintBottom_toTopOf="@id/categories_chip_group"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintWidth_max="488dp">

        <ImageView
            android:id="@+id/icon_search"
            android:layout_width="24dp"
            android:layout_height="24dp"
            android:src="@drawable/ic_search"
            android:contentDescription="@string/search"
            app:tint="#FFFFFF"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintBottom_toBottomOf="parent" />

        <EditText
            android:id="@+id/editTextSearch"
            android:layout_width="0dp"
            android:layout_height="48dp"
            android:layout_marginStart="8dp"
            android:background="@android:color/transparent"
            android:hint="@string/search_hint"
            android:textColor="#FFFFFF"
            android:textColorHint="#B3FFFFFF"
            android:inputType="text"
            android:imeOptions="actionSearch"
            android:autofillHints="search"
            android:importantForAutofill="yes"
            app:layout_constraintStart_toEndOf="@id/icon_search"
            app:layout_constraintEnd_toStartOf="@id/touch_container"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintBottom_toBottomOf="parent"
            android:layout_marginEnd="8dp"/>

        <FrameLayout
            android:id="@+id/touch_container"
            android:layout_width="48dp"
            android:layout_height="48dp"
            android:clickable="true"
            android:focusable="true"
            android:background="?attr/selectableItemBackgroundBorderless"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintBottom_toBottomOf="parent">

            <ImageView
                android:id="@+id/icon_search_action"
                android:layout_width="24dp"
                android:layout_height="24dp"
                android:layout_gravity="center"
                android:src="@drawable/ic_search_action"
                android:contentDescription="@string/search_action_desc"
                app:tint="#FFFFFF" />
        </FrameLayout>
    </androidx.constraintlayout.widget.ConstraintLayout>

    <LinearLayout
        android:id="@+id/categories_chip_group" android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:layout_marginTop="24dp"
        app:layout_constraintTop_toBottomOf="@id/search_bar_container"
        app:layout_constraintBottom_toTopOf="@id/dashboard_grid"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

        <LinearLayout
            android:id="@+id/custom_chip_fotos"
            android:layout_width="90dp"
            android:layout_height="wrap_content"
            android:minHeight="48dp"
            android:background="@drawable/glassmorphism_background"
            android:gravity="center"
            android:orientation="horizontal"
            android:paddingVertical="10dp"
            android:clickable="true"
            android:focusable="true"
            android:foreground="?attr/selectableItemBackground"
            android:layout_marginEnd="12dp">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/fotos"
                android:textColor="@color/white"
                android:textSize="15sp"
                android:textStyle="bold"
                android:fontFamily="@font/montserratbold" />
        </LinearLayout>

        <LinearLayout
            android:id="@+id/custom_chip_videos"
            android:layout_width="90dp"
            android:layout_height="wrap_content"
            android:minHeight="48dp"
            android:background="@drawable/glassmorphism_background"
            android:gravity="center"
            android:orientation="horizontal"
            android:paddingVertical="10dp"
            android:clickable="true"
            android:focusable="true"
            android:foreground="?attr/selectableItemBackground"
            android:layout_marginEnd="12dp">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/videos"
                android:textColor="@color/white"
                android:textSize="15sp"
                android:textStyle="bold"
                android:fontFamily="@font/montserratbold" />
        </LinearLayout>

        <LinearLayout
            android:id="@+id/custom_chip_relatos"
            android:layout_width="90dp"
            android:layout_height="wrap_content"
            android:minHeight="48dp"
            android:background="@drawable/glassmorphism_background"
            android:gravity="center"
            android:orientation="horizontal"
            android:paddingVertical="10dp"
            android:clickable="true"
            android:focusable="true"
            android:foreground="?attr/selectableItemBackground">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/relatos"
                android:textColor="@color/white"
                android:textSize="15sp"
                android:textStyle="bold"
                android:fontFamily="@font/montserratbold" />
        </LinearLayout>
    </LinearLayout>

    <androidx.constraintlayout.widget.ConstraintLayout
        android:id="@+id/dashboard_grid"
        android:layout_width="0dp"
        android:layout_height="0dp"
        android:layout_marginTop="20dp"
        android:layout_marginBottom="24dp" android:layout_marginStart="16dp"
        android:layout_marginEnd="16dp"
        app:layout_constrainedHeight="true"
        app:layout_constraintTop_toBottomOf="@id/categories_chip_group"
        app:layout_constraintBottom_toTopOf="@id/btn_iniciar_sesion"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

        <androidx.constraintlayout.widget.ConstraintLayout
            android:id="@+id/recent_container"
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:layout_marginEnd="6dp" android:layout_marginBottom="6dp" android:background="@drawable/glassmorphism_background"
            android:foreground="?attr/selectableItemBackground"
            android:clickable="true"
            android:focusable="true"
            android:contentDescription="@string/recientes"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toStartOf="@id/favorites_container"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintBottom_toTopOf="@id/places_container"
            app:layout_constraintWidth_percent="0.46" app:layout_constraintHeight_percent="0.46">

            <TextView
                android:id="@+id/text_recent"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/recientes"
                android:textColor="#FFFFFF"
                android:textSize="13sp"
                android:textStyle="bold"
                app:drawableTopCompat="@drawable/ic_recent"
                app:drawableTint="#FFFFFF"
                android:drawablePadding="6dp"
                android:gravity="center_horizontal"
                app:layout_constraintTop_toTopOf="parent"
                app:layout_constraintBottom_toBottomOf="parent"
                app:layout_constraintStart_toStartOf="parent"
                app:layout_constraintEnd_toEndOf="parent" />

        </androidx.constraintlayout.widget.ConstraintLayout>

        <androidx.constraintlayout.widget.ConstraintLayout
            android:id="@+id/favorites_container"
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:layout_marginStart="6dp" android:layout_marginBottom="6dp" android:background="@drawable/glassmorphism_background"
            android:foreground="?attr/selectableItemBackground"
            android:clickable="true"
            android:focusable="true"
            android:contentDescription="@string/favoritos"
            app:layout_constraintStart_toEndOf="@id/recent_container"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintBottom_toTopOf="@id/map_container"
            app:layout_constraintWidth_percent="0.46" app:layout_constraintHeight_percent="0.46">

            <TextView
                android:id="@+id/text_favorites"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/favoritos"
                android:textColor="#FFFFFF"
                android:textSize="13sp"
                android:textStyle="bold"
                app:drawableTopCompat="@drawable/ic_favorite"
                app:drawableTint="#FFFFFF"
                android:drawablePadding="6dp"
                android:gravity="center_horizontal"
                app:layout_constraintTop_toTopOf="parent"
                app:layout_constraintBottom_toBottomOf="parent"
                app:layout_constraintStart_toStartOf="parent"
                app:layout_constraintEnd_toEndOf="parent" />

        </androidx.constraintlayout.widget.ConstraintLayout>

        <androidx.constraintlayout.widget.ConstraintLayout
            android:id="@+id/places_container"
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:layout_marginTop="6dp" android:layout_marginEnd="6dp" android:background="@drawable/glassmorphism_background"
            android:foreground="?attr/selectableItemBackground"
            android:clickable="true"
            android:focusable="true"
            android:contentDescription="@string/lugares_investigados"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintEnd_toStartOf="@id/map_container"
            app:layout_constraintTop_toBottomOf="@id/recent_container"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintWidth_percent="0.46" app:layout_constraintHeight_percent="0.46">

            <TextView
                android:id="@+id/text_places"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/lugares_investigados"
                android:textColor="#FFFFFF"
                android:textSize="13sp"
                android:textStyle="bold"
                app:drawableTopCompat="@drawable/ic_places"
                app:drawableTint="#FFFFFF"
                android:drawablePadding="6dp"
                android:gravity="center_horizontal"
                app:layout_constraintTop_toTopOf="parent"
                app:layout_constraintBottom_toBottomOf="parent"
                app:layout_constraintStart_toStartOf="parent"
                app:layout_constraintEnd_toEndOf="parent" />

        </androidx.constraintlayout.widget.ConstraintLayout>

        <androidx.constraintlayout.widget.ConstraintLayout
            android:id="@+id/map_container"
            android:layout_width="0dp"
            android:layout_height="0dp"
            android:layout_marginTop="6dp" android:layout_marginStart="6dp" android:background="@drawable/glassmorphism_background"
            android:foreground="?attr/selectableItemBackground"
            android:clickable="true"
            android:focusable="true"
            android:contentDescription="@string/mapa_paranormal"
            app:layout_constraintStart_toEndOf="@id/places_container"
            app:layout_constraintEnd_toEndOf="parent"
            app:layout_constraintTop_toBottomOf="@id/favorites_container"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintWidth_percent="0.46" app:layout_constraintHeight_percent="0.46">

            <TextView
                android:id="@+id/text_map"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/mapa_paranormal"
                android:textColor="#FFFFFF"
                android:textSize="13sp"
                android:textStyle="bold"
                app:drawableTopCompat="@drawable/ic_map"
                app:drawableTint="#FFFFFF"
                android:drawablePadding="6dp"
                android:gravity="center_horizontal"
                app:layout_constraintTop_toTopOf="parent"
                app:layout_constraintBottom_toBottomOf="parent"
                app:layout_constraintStart_toStartOf="parent"
                app:layout_constraintEnd_toEndOf="parent" />

        </androidx.constraintlayout.widget.ConstraintLayout>

    </androidx.constraintlayout.widget.ConstraintLayout>

    <com.google.android.material.button.MaterialButton
        android:id="@+id/btn_iniciar_sesion"
        android:layout_width="200dp"
        android:layout_height="wrap_content"
        android:layout_marginHorizontal="16dp"
        android:layout_marginBottom="24dp"
        android:backgroundTint="#5189fc"
        android:paddingVertical="12dp"
        android:text="@string/iniciar_sesion"
        android:textColor="#FFFFFF"
        android:textSize="16sp"
        android:textStyle="bold"
        app:cornerRadius="24dp"
        app:layout_constraintBottom_toTopOf="@id/text_como_funciona"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"/>

    <TextView
        android:id="@+id/text_como_funciona"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/como_funciona"
        android:textColor="#8AB4F8"
        android:textSize="14sp"
        android:textStyle="bold"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        android:layout_marginBottom="50dp" />

    <ProgressBar
        android:id="@+id/mainActivityProgressBar"
        style="?android:attr/progressBarStyleLarge"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:visibility="gone"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        android:elevation="10dp"/>

</androidx.constraintlayout.widget.ConstraintLayout>


===== Archivo: app\src\main\res\layout\activity_maps.xml =====


<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <Button
        android:id="@+id/btnBackMap"
        android:layout_width="48dp"
        android:layout_height="48dp"
        android:src="@drawable/ic_arrow_back"
        android:visibility="visible"
        android:background="?attr/selectableItemBackgroundBorderless"
        android:contentDescription="@string/back_button_desc"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        android:layout_margin="8dp"/>

    <androidx.fragment.app.FragmentContainerView
        android:id="@+id/mapView"
        android:name="com.google.android.gms.maps.SupportMapFragment"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        app:layout_constraintTop_toBottomOf="@id/btnBackMap" />

    <Button
        android:id="@+id/btnConfirmLocation"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/accept"
        android:layout_margin="16dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent" />
</androidx.constraintlayout.widget.ConstraintLayout>


===== Archivo: app\src\main\res\layout\activity_pending_uploads.xml =====


<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@drawable/gradient_background"
    tools:context=".PendingUploadsActivity">

    <LinearLayout
        android:id="@+id/headerLayoutPendingUploads"
        android:layout_width="0dp"
        android:layout_height="?attr/actionBarSize"
        android:orientation="horizontal"
        android:gravity="center_vertical"
        android:paddingHorizontal="16dp"
        android:background="@color/purple_dark"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

        <ImageView
            android:id="@+id/btnBackPendingUploads"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:minWidth="48dp"
            android:minHeight="48dp"
            android:padding="12dp"
            android:src="@drawable/ic_arrow_back"
            android:contentDescription="@string/back_button_desc"
            android:background="?attr/selectableItemBackgroundBorderless"
            android:clickable="true"
            android:focusable="true"/>

        <TextView
            android:id="@+id/screenTitlePendingUploads"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="@string/title_pending_uploads"
            android:textColor="@color/white"
            android:textSize="20sp"
            android:textStyle="bold"
            android:gravity="center_vertical"
            android:paddingStart="16dp"
            android:paddingEnd="16dp"/>
    </LinearLayout>

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/recyclerViewPendingUploads"
        android:layout_width="0dp"
        android:layout_height="0dp"
        app:layout_constraintTop_toBottomOf="@id/headerLayoutPendingUploads"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        android:padding="8dp"
        tools:listitem="@layout/list_item_pending_upload"/>

    <TextView
        android:id="@+id/textViewNoPendingUploads"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/no_pending_uploads_message"
        android:textColor="@color/glass_hint"
        android:textSize="16sp"
        android:visibility="gone"
        app:layout_constraintTop_toBottomOf="@id/headerLayoutPendingUploads"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        tools:visibility="visible"/>

</androidx.constraintlayout.widget.ConstraintLayout>


===== Archivo: app\src\main\res\layout\activity_relato_viewer.xml =====


<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@drawable/gradient_background"
    tools:context=".RelatoViewerActivity">

    <LinearLayout
        android:id="@+id/headerLayoutRelatoViewer"
        android:layout_width="0dp"
        android:layout_height="?attr/actionBarSize"
        android:orientation="horizontal"
        android:gravity="center_vertical"
        android:paddingHorizontal="16dp"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

        <ImageView
            android:id="@+id/btnBackRelatoViewer"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:minWidth="48dp"
            android:minHeight="48dp"
            android:padding="12dp"
            android:src="@drawable/ic_arrow_back"
            android:contentDescription="@string/back_button_desc"
            android:background="?attr/selectableItemBackgroundBorderless"
            android:clickable="true"
            android:focusable="true"/>

        <TextView
            android:id="@+id/screenTitleRelatoViewer"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="@string/title_detail_story"
            android:textColor="@color/white"
            android:textSize="20sp"
            android:textStyle="bold"
            android:gravity="center_vertical"
            android:paddingStart="16dp"
            android:paddingEnd="16dp"/>
    </LinearLayout>

    <TextView
        android:id="@+id/textViewPendingReviewStatusRelato"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:text="@string/status_pending_review_message"
        android:textColor="@color/blue_light"
        android:background="#40000000"
        android:padding="8dp"
        android:gravity="center"
        android:textSize="14sp"
        android:textStyle="italic"
        android:visibility="gone"
        app:layout_constraintTop_toBottomOf="@id/headerLayoutRelatoViewer"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        tools:visibility="visible"/>

    <ScrollView
        android:id="@+id/scrollViewRelatoContent"
        android:layout_width="0dp"
        android:layout_height="0dp"
        app:layout_constraintTop_toBottomOf="@id/textViewPendingReviewStatusRelato"
        app:layout_constraintBottom_toTopOf="@+id/interactionLayoutRelato"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:padding="16dp">

            <TextView
                android:id="@+id/storyTitleTextViewer"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textColor="@color/white"
                android:textSize="22sp"
                android:textStyle="bold"
                android:layout_marginBottom="8dp"
                tools:text="Título del Relato Impactante"/>

            <TextView
                android:id="@+id/storyAuthorTextViewer"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textColor="@color/glass_hint"
                android:textSize="14sp"
                android:layout_marginBottom="4dp"
                tools:text="Autor: Usuario Ejemplo"/>

            <TextView
                android:id="@+id/storyDateTextViewer"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textColor="@color/glass_hint"
                android:textSize="14sp"
                android:layout_marginBottom="16dp"
                tools:text="Fecha: 01/01/2024"/>

            <TextView
                android:id="@+id/storyLocationTextViewer"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textColor="@color/glass_hint"
                android:textSize="14sp"
                android:layout_marginBottom="4dp"
                tools:text="Ubicación: Ciudad de México"/>

            <TextView
                android:id="@+id/storyTypeTextViewer"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textColor="@color/glass_hint"
                android:textSize="14sp"
                android:layout_marginBottom="16dp"
                tools:text="Tipo: Experiencia"/>

            <ImageView
                android:id="@+id/storyOptionalImageViewer"
                android:layout_width="match_parent"
                android:layout_height="200dp"
                android:scaleType="centerCrop"
                android:visibility="gone"
                tools:src="@drawable/placeholder_image"
                android:layout_marginBottom="16dp"
                android:contentDescription="@string/content_desc_story_attached_image"/>

            <TextView
                android:id="@+id/storyContentTextViewer"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textColor="@color/white"
                android:textSize="16sp"
                android:lineSpacingMultiplier="1.2"
                tools:text="Aquí va el contenido completo del relato paranormal..."/>

        </LinearLayout>
    </ScrollView>

    <LinearLayout
        android:id="@+id/interactionLayoutRelato"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:padding="8dp"
        android:gravity="center_vertical"
        android:background="@color/glass_background"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        tools:visibility="visible">

        <ImageButton
            android:id="@+id/likeButtonRelato"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:src="@drawable/ic_megusta"
            app:tint="@color/white"
            android:background="?attr/selectableItemBackgroundBorderless"
            android:padding="8dp"
            android:contentDescription="@string/me_gusta"/>

        <TextView
            android:id="@+id/likesCountRelato"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textColor="@color/white"
            android:layout_marginStart="4dp"
            android:layout_marginEnd="16dp"
            tools:text="123"/>

        <ImageButton
            android:id="@+id/commentButtonRelato"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:src="@drawable/ic_comment"
            app:tint="@color/white"
            android:background="?attr/selectableItemBackgroundBorderless"
            android:padding="8dp"
            android:contentDescription="@string/ver_comentarios"/>
        <TextView
            android:id="@+id/commentsCountRelato"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textColor="@color/white"
            android:layout_marginStart="4dp"
            tools:text="45"/>

    </LinearLayout>

</androidx.constraintlayout.widget.ConstraintLayout>


===== Archivo: app\src\main\res\layout\activity_search_results.xml =====


<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/search_results_main"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@drawable/gradient_background">

    <!-- Botón de regreso -->
    <ImageButton
        android:id="@+id/btn_back"
        android:layout_width="48dp"
        android:layout_height="48dp"
        android:src="@drawable/ic_arrow_back"
        android:background="?attr/selectableItemBackgroundBorderless"
        android:contentDescription="@string/back_button_desc"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        android:layout_margin="8dp"/>

    <!-- Título de resultados -->
    <TextView
        android:id="@+id/title_search_results"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:textSize="20sp"
        android:textColor="#FFFFFF"
        android:textStyle="bold"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintStart_toEndOf="@id/btn_back"
        app:layout_constraintEnd_toEndOf="parent"
        android:layout_marginTop="16dp"
        android:layout_marginEnd="16dp"
        tools:text='Resultados de Búsqueda: "fantasma"'
        android:gravity="center_vertical"/>

    <!-- Contador de resultados -->
    <TextView
        android:id="@+id/text_results_count"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:textColor="#E1E1E1"
        app:layout_constraintTop_toBottomOf="@id/title_search_results"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        android:layout_marginTop="8dp"
        android:layout_marginHorizontal="16dp"
        tools:text="Mostrando 5 resultados"/>

    <!-- Filtros (Chips) -->
    <com.google.android.material.chip.ChipGroup
        android:id="@+id/filters_container"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        app:layout_constraintTop_toBottomOf="@id/text_results_count"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        android:layout_marginTop="16dp"
        android:layout_marginHorizontal="16dp"
        app:singleLine="true"
        app:chipSpacing="8dp">

        <com.google.android.material.chip.Chip
            android:id="@+id/filter_location"
            style="@style/ChipStyle"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/filter_location"/>

        <com.google.android.material.chip.Chip
            android:id="@+id/filter_date"
            style="@style/ChipStyle"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/filter_date"/>

        <com.google.android.material.chip.Chip
            android:id="@+id/filter_types"
            style="@style/ChipStyle"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/filter_types"/>
    </com.google.android.material.chip.ChipGroup>

    <!-- RecyclerView para resultados -->
    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/recycler_search_results"
        android:layout_width="0dp"
        android:layout_height="0dp"
        android:contentDescription="@string/results_list_dynamic_description"
        app:layout_constraintTop_toBottomOf="@id/filters_container"
        app:layout_constraintBottom_toTopOf="@id/pagination_container"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        android:layout_marginTop="16dp"
        android:layout_marginHorizontal="16dp"/>

    <!-- Paginación con números -->
    <LinearLayout
        android:id="@+id/pagination_container"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="center"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        android:layout_marginBottom="16dp"
        android:padding="8dp">

        <com.google.android.material.button.MaterialButton
            android:id="@+id/btn_previous"
            style="@style/Widget.App.Button.Primary"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/previous"
            android:layout_marginEnd="4dp"/>

        <TextView
            android:id="@+id/text_page_1"
            android:layout_width="30dp"
            android:layout_height="30dp"
            android:gravity="center"
            android:text="@string/page_1"
            android:textColor="#FFFFFF"
            android:backgroundTint="#5189fc"
            android:layout_marginHorizontal="4dp"
            style="@style/Widget.App.Button.Primary"/>

        <TextView
            android:id="@+id/text_page_2"
            android:layout_width="30dp"
            android:layout_height="30dp"
            android:gravity="center"
            android:text="@string/page_2"
            android:textColor="#FFFFFF"
            android:backgroundTint="#5189fc"
            android:layout_marginHorizontal="4dp"
            style="@style/Widget.App.Button.Primary"/>

        <TextView
            android:id="@+id/text_page_3"
            android:layout_width="30dp"
            android:layout_height="30dp"
            android:gravity="center"
            android:text="@string/page_3"
            android:textColor="#FFFFFF"
            android:backgroundTint="#5189fc"
            android:layout_marginHorizontal="4dp"
            style="@style/Widget.App.Button.Primary"/>

        <com.google.android.material.button.MaterialButton
            android:id="@+id/btn_next"
            style="@style/Widget.App.Button.Primary"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/next"
            android:layout_marginStart="4dp"/>
    </LinearLayout>

</androidx.constraintlayout.widget.ConstraintLayout>


===== Archivo: app\src\main\res\layout\activity_upload_image.xml =====


<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@drawable/gradient_background"
    android:fitsSystemWindows="true"
    tools:context="com.example.mexicoparanormal.UploadImageActivity">

    <LinearLayout
        android:id="@+id/headerLayout"
        android:layout_width="0dp"
        android:layout_height="?attr/actionBarSize"
        android:orientation="horizontal"
        android:gravity="center_vertical"
        android:paddingHorizontal="16dp"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

        <ImageView
            android:id="@+id/btnBack"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:minWidth="48dp"
            android:minHeight="48dp"
            android:padding="12dp"
            android:src="@drawable/ic_arrow_back"
            android:contentDescription="@string/back_button_desc"
            android:background="?attr/selectableItemBackgroundBorderless"
            android:clickable="true"
            android:focusable="true"/>

        <TextView
            android:id="@+id/headerTitle"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="@string/upload_image_title"
            android:textColor="@color/white"
            android:textSize="20sp"
            android:textStyle="bold"
            android:gravity="center_vertical"
            android:paddingStart="16dp"
            android:paddingEnd="16dp"/>
    </LinearLayout>

    <ScrollView
        android:id="@+id/scrollView"
        android:layout_width="0dp"
        android:layout_height="0dp"
        app:layout_constraintTop_toBottomOf="@id/headerLayout"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintBottom_toTopOf="@+id/bottom_buttons_container">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:padding="16dp"
            android:paddingBottom="16dp">

            <com.google.android.material.textfield.TextInputLayout
                android:id="@+id/textInputLayoutImageTitle"
                style="@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:hint="@string/image_title_hint"
                app:boxStrokeColor="@color/white"
                app:hintTextColor="@color/white">

                <com.google.android.material.textfield.TextInputEditText
                    android:id="@+id/editTextImageTitle"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:textColor="@color/white"
                    android:background="@android:color/transparent"
                    android:inputType="textCapWords"
                    android:maxLength="37" />
            </com.google.android.material.textfield.TextInputLayout>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/info_attach_file"
                android:textColor="@color/glass_hint"
                android:textSize="14sp"
                android:layout_marginTop="16dp"
                android:contentDescription="@string/desc_file_info" />

            <com.google.android.material.button.MaterialButton
                android:id="@+id/btnSelectFile"
                style="@style/Widget.MaterialComponents.Button.OutlinedButton"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="8dp"
                android:text="@string/select_file_button"
                app:icon="@drawable/ic_attachment"
                app:iconTint="@color/white"
                app:strokeColor="@color/white"
                android:textColor="@color/white"
                android:minHeight="48dp"
                android:focusable="true" />

            <ImageView
                android:id="@+id/imageViewPreview"
                android:layout_width="match_parent"
                android:layout_height="200dp"
                android:layout_marginTop="16dp"
                android:visibility="gone"
                android:scaleType="centerCrop"
                android:contentDescription="@string/image_preview_description" />

            <TextView
                android:id="@+id/textViewPreviewLabel"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/image_preview_label"
                android:textColor="@color/glass_hint"
                android:textSize="12sp"
                android:layout_marginTop="4dp"
                android:layout_marginStart="16dp"
                android:visibility="gone" />

            <TextView
                android:id="@+id/labelLocationSpinner"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/location_question"
                android:textColor="@color/glass_hint"
                android:textSize="14sp"
                android:paddingStart="12dp"
                android:paddingEnd="12dp"
                android:paddingBottom="4dp"
                android:layout_marginTop="16dp"/>

            <com.google.android.material.textfield.TextInputLayout
                android:id="@+id/textInputLayoutLocationSpinner"
                style="@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:hint="@null"
                app:boxStrokeColor="@color/white"
                app:hintTextColor="@color/white">

                <Spinner
                    android:id="@+id/spinnerLocation"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:background="@drawable/spinner_background"
                    android:minHeight="48dp"
                    android:padding="12dp"
                    android:popupBackground="@color/glass_background"
                    android:spinnerMode="dropdown" />
            </com.google.android.material.textfield.TextInputLayout>


            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/label_coordinates"
                android:textColor="@color/glass_hint"
                android:textSize="14sp"
                android:paddingStart="12dp"
                android:paddingEnd="12dp"
                android:paddingBottom="4dp"
                android:layout_marginTop="16dp"/>

            <LinearLayout
                android:id="@+id/coordinatesSelectionLayout"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="vertical"
                android:gravity="center_vertical"
                android:paddingVertical="8dp"
                android:background="@drawable/glassmorphism_background"
                android:paddingHorizontal="16dp">

                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="horizontal"
                    android:gravity="center_vertical">

                    <TextView
                        android:layout_width="0dp"
                        android:layout_height="wrap_content"
                        android:layout_weight="1"
                        android:text="@string/info_coordinates"
                        android:textColor="@color/glass_hint"
                        android:textSize="14sp" />

                    <Switch
                        android:id="@+id/switchCoordinates"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:minWidth="48dp"
                        android:minHeight="48dp"
                        android:padding="8dp"
                        android:checked="false"
                        android:thumbTint="@color/blue_light"
                        android:trackTint="@color/grey_light"
                        android:contentDescription="@string/desc_coordinates_section"
                        tools:ignore="UseSwitchCompatOrMaterialXml" />
                </LinearLayout>

                <LinearLayout
                    android:id="@+id/mapSelectionContainer"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="vertical"
                    android:layout_marginTop="8dp"
                    android:visibility="gone"
                    tools:visibility="gone">

                    <TextView
                        android:id="@+id/textViewSelectCoordinates"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:text="@string/select_location_map"
                        android:textColor="@color/white"
                        android:textSize="16sp"
                        android:padding="12dp"
                        android:minHeight="48dp"
                        android:gravity="center"
                        android:background="?attr/selectableItemBackground"
                        android:clickable="true"
                        android:focusable="true" />

                    <TextView
                        android:id="@+id/textViewSelectedCoordinates"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        tools:text="Lat: 19.4326, Lon: -99.1332"
                        android:textColor="@color/glass_text"
                        android:textSize="14sp"
                        android:padding="8dp"
                        android:visibility="gone"
                        tools:visibility="gone"/>

                    <TextView
                        android:id="@+id/textViewCityName"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        tools:text="Ciudad de México"
                        android:textColor="@color/glass_text"
                        android:textSize="14sp"
                        android:paddingStart="8dp"
                        android:paddingEnd="8dp"
                        android:paddingBottom="8dp"
                        android:visibility="gone"
                        tools:visibility="gone"/>

                    <Button
                        android:id="@+id/btnEditCoordinates"
                        style="@style/Widget.App.Button.Primary"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:minHeight="48dp"
                        android:text="@string/edit_coordinates"
                        android:visibility="gone"
                        tools:visibility="gone"
                        android:layout_marginTop="8dp"/>
                </LinearLayout>
            </LinearLayout>

            <com.google.android.material.textfield.TextInputLayout
                android:id="@+id/textInputLayoutImageDescription"
                style="@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="16dp"
                android:hint="@string/image_description_hint"
                app:boxStrokeColor="@color/white"
                app:counterEnabled="true"
                app:counterMaxLength="666"
                app:hintTextColor="@color/white"
                app:counterTextColor="@color/glass_hint"
                app:counterOverflowTextColor="@color/red_error">

                <com.google.android.material.textfield.TextInputEditText
                    android:id="@+id/editTextImageDescription"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:minLines="3"
                    android:maxLines="5"
                    android:gravity="top"
                    android:textColor="@color/white"
                    android:background="@android:color/transparent"
                    android:inputType="textMultiLine|textCapSentences"
                    android:padding="12dp"/>
            </com.google.android.material.textfield.TextInputLayout>

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="vertical"
                android:layout_marginTop="16dp">

                <TextView
                    android:id="@+id/infoIconDate"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:text="@string/fecha"
                    android:textColor="@color/glass_hint"
                    android:textSize="14sp"
                    android:padding="12dp"
                    android:minHeight="48dp"
                    android:gravity="center_vertical"
                    android:contentDescription="@string/desc_date_section"
                    app:drawableEndCompat="@drawable/ic_info"
                    android:drawablePadding="4dp"
                    android:clickable="true"
                    android:focusable="true" />

                <RadioGroup
                    android:id="@+id/radioGroupDateType"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="horizontal"
                    android:layout_marginTop="8dp">

                    <RadioButton
                        android:id="@+id/radioYear"
                        android:layout_width="0dp"
                        android:layout_weight="1"
                        android:layout_height="wrap_content"
                        android:minHeight="48dp"
                        android:paddingVertical="8dp"
                        android:text="@string/date_type_year"
                        android:textColor="@color/white"
                        android:buttonTint="@color/blue_light" />

                    <RadioButton
                        android:id="@+id/radioExactDate"
                        android:layout_width="0dp"
                        android:layout_weight="1"
                        android:layout_height="wrap_content"
                        android:minHeight="48dp"
                        android:paddingVertical="8dp"
                        android:text="@string/date_type_exact"
                        android:textColor="@color/white"
                        android:buttonTint="@color/blue_light" />

                    <RadioButton
                        android:id="@+id/radioDateRange"
                        android:layout_width="0dp"
                        android:layout_weight="1"
                        android:layout_height="wrap_content"
                        android:minHeight="48dp"
                        android:paddingVertical="8dp"
                        android:text="@string/date_type_range"
                        android:textColor="@color/white"
                        android:buttonTint="@color/blue_light" />
                </RadioGroup>

                <LinearLayout
                    android:id="@+id/dateInputFieldsContainer"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="vertical"
                    android:layout_marginTop="8dp"
                    android:visibility="gone"
                    tools:visibility="gone"
                    android:baselineAligned="false">

                    <com.google.android.material.textfield.TextInputLayout
                        android:id="@+id/textInputLayoutYear"
                        style="@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:hint="@string/hint_year"
                        android:visibility="gone"
                        tools:visibility="gone"
                        app:boxStrokeColor="@color/white"
                        app:hintTextColor="@color/white">

                        <com.google.android.material.textfield.TextInputEditText
                            android:id="@+id/editTextYear"
                            android:layout_width="match_parent"
                            android:layout_height="wrap_content"
                            android:inputType="number"
                            android:maxLength="4"
                            android:textColor="@color/white" />
                    </com.google.android.material.textfield.TextInputLayout>

                    <TextView
                        android:id="@+id/textDateMessageImage"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:textColor="@color/red_error"
                        android:visibility="gone"
                        tools:text="Error en la fecha"
                        android:paddingStart="12dp"
                        android:paddingEnd="12dp"
                        android:paddingTop="4dp"/>

                    <com.google.android.material.textfield.TextInputLayout
                        android:id="@+id/textInputLayoutExactDate"
                        style="@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:hint="@string/hint_exact_date"
                        android:visibility="gone"
                        tools:visibility="gone"
                        app:boxStrokeColor="@color/white"
                        app:hintTextColor="@color/white">

                        <com.google.android.material.textfield.TextInputEditText
                            android:id="@+id/editTextExactDate"
                            android:layout_width="match_parent"
                            android:layout_height="wrap_content"
                            android:textColor="@color/white"
                            android:clickable="true"
                            android:focusable="false" />
                    </com.google.android.material.textfield.TextInputLayout>

                    <LinearLayout
                        android:id="@+id/dateRangeLayout"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:orientation="horizontal"
                        android:visibility="gone"
                        tools:visibility="gone"
                        android:baselineAligned="false">

                        <com.google.android.material.textfield.TextInputLayout
                            android:id="@+id/textInputLayoutStartYear"
                            style="@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox"
                            android:layout_width="0dp"
                            android:layout_height="wrap_content"
                            android:layout_weight="1"
                            android:hint="@string/hint_start_year"
                            app:boxStrokeColor="@color/white"
                            app:hintTextColor="@color/white"
                            android:layout_marginEnd="4dp">

                            <com.google.android.material.textfield.TextInputEditText
                                android:id="@+id/editTextStartYear"
                                android:layout_width="match_parent"
                                android:layout_height="wrap_content"
                                android:inputType="number"
                                android:maxLength="4"
                                android:textColor="@color/white" />
                        </com.google.android.material.textfield.TextInputLayout>

                        <com.google.android.material.textfield.TextInputLayout
                            android:id="@+id/textInputLayoutEndYear"
                            style="@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox"
                            android:layout_width="0dp"
                            android:layout_height="wrap_content"
                            android:layout_weight="1"
                            android:hint="@string/hint_end_year"
                            app:boxStrokeColor="@color/white"
                            app:hintTextColor="@color/white"
                            android:layout_marginStart="4dp">

                            <com.google.android.material.textfield.TextInputEditText
                                android:id="@+id/editTextEndYear"
                                android:layout_width="match_parent"
                                android:layout_height="wrap_content"
                                android:inputType="number"
                                android:maxLength="4"
                                android:textColor="@color/white" />
                        </com.google.android.material.textfield.TextInputLayout>
                    </LinearLayout>
                </LinearLayout>

                <RadioButton
                    android:id="@+id/radioUnknown"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:minHeight="48dp"
                    android:paddingVertical="8dp"
                    android:text="@string/date_type_unknown"
                    android:textColor="@color/white"
                    android:buttonTint="@color/blue_light"
                    android:layout_marginTop="8dp"
                    android:focusable="true" />
            </LinearLayout>

            <TextView
                android:id="@+id/textMessage"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="8dp"
                android:textColor="@color/red_error"
                android:visibility="gone"
                tools:text="Mensaje de error general"/>

        </LinearLayout>
    </ScrollView>

    <LinearLayout
        android:id="@+id/buttonActionsLayoutImage"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="center"
        android:paddingHorizontal="16dp"
        android:paddingVertical="8dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

    </LinearLayout>

    <LinearLayout
        android:id="@+id/bottom_buttons_container"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="center"
        android:padding="16dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

        <Button
            android:id="@+id/btnBorrarTodoImagen"
            style="?android:attr/buttonBarButtonStyle"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="@string/button_clear_all"
            android:backgroundTint="@color/blue_primary"
            android:textColor="@color/white"
            android:minHeight="48dp"
            android:layout_marginEnd="8dp"/>

        <Button
            android:id="@+id/btnEnviarImagen"
            style="?android:attr/buttonBarButtonStyle"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1.5"
            android:text="@string/send_image_button"
            android:backgroundTint="@color/red_button"
            android:textColor="@color/white"
            android:minHeight="48dp"/>
    </LinearLayout>

    <FrameLayout
        android:id="@+id/uploadProgressOverlayImage"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:background="#CC000000"
        android:clickable="true"
        android:focusable="true"
        android:visibility="gone"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        tools:visibility="gone">

        <LinearLayout
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:layout_gravity="center"
            android:padding="24dp"
            android:background="@drawable/glassmorphism_background"
            android:gravity="center_horizontal">

            <ProgressBar
                android:id="@+id/progressBarUploadImage"
                style="?android:attr/progressBarStyleHorizontal"
                android:layout_width="match_parent"
                android:minWidth="200dp"
                android:layout_height="wrap_content"
                android:layout_marginBottom="8dp"
                android:indeterminate="false"
                android:max="100"
                android:progress="0"
                android:progressTint="@color/white"
                android:progressBackgroundTint="@color/glass_stroke"/>

            <TextView
                android:id="@+id/textProgressImage"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:textColor="@color/white"
                android:textSize="16sp"
                android:layout_marginBottom="16dp"
                tools:text="Subiendo 0%"/>
            <Button
                android:id="@+id/btnCancelUploadImage"
                style="@style/Widget.App.Button.Primary"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:minHeight="48dp"
                android:text="@string/cancel_upload_button"
                android:backgroundTint="@color/red_error" />
        </LinearLayout>
    </FrameLayout>

</androidx.constraintlayout.widget.ConstraintLayout>


===== Archivo: app\src\main\res\layout\activity_upload_story.xml =====


<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@drawable/gradient_background"
    android:fitsSystemWindows="true"
    tools:context=".UploadStoryActivity">

    <LinearLayout
        android:id="@+id/headerLayout"
        android:layout_width="0dp"
        android:layout_height="?attr/actionBarSize"
        android:orientation="horizontal"
        android:gravity="center_vertical"
        android:paddingHorizontal="16dp"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

        <ImageView
            android:id="@+id/btnBack"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:minWidth="48dp"
            android:minHeight="48dp"
            android:padding="12dp"
            android:src="@drawable/ic_arrow_back"
            android:contentDescription="@string/back_button_desc"
            android:background="?attr/selectableItemBackgroundBorderless"
            android:clickable="true"
            android:focusable="true"/>

        <TextView
            android:id="@+id/screenTitle"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="@string/title_upload_relato"
            android:textColor="@color/white"
            android:textSize="20sp"
            android:textStyle="bold"
            android:gravity="center_vertical"
            android:paddingStart="16dp"
            android:paddingEnd="16dp"/>
    </LinearLayout>

    <ScrollView
        android:id="@+id/scrollViewStory"
        android:layout_width="0dp"
        android:layout_height="0dp"
        app:layout_constraintTop_toBottomOf="@id/headerLayout"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintBottom_toTopOf="@+id/bottom_buttons_container">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:padding="16dp"
            android:paddingBottom="16dp">

            <com.google.android.material.textfield.TextInputLayout
                android:id="@+id/textInputLayoutStoryTitle"
                style="@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:hint="@string/hint_story_title"
                android:textColorHint="@color/glass_hint"
                app:boxStrokeColor="@color/white"
                app:hintTextColor="@color/white">

                <com.google.android.material.textfield.TextInputEditText
                    android:id="@+id/editTextStoryTitle"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:inputType="textCapWords"
                    android:textColor="@color/white"
                    android:background="@android:color/transparent"
                    android:padding="12dp"
                    android:maxLength="37"/>
            </com.google.android.material.textfield.TextInputLayout>

            <Space
                android:layout_width="match_parent"
                android:layout_height="16dp"/>

            <com.google.android.material.tabs.TabLayout
                android:id="@+id/tabLayoutStoryInput"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:background="@android:color/transparent"
                app:tabTextColor="@color/glass_hint"
                app:tabSelectedTextColor="@color/white"
                app:tabIndicatorColor="@color/blue_primary"
                app:tabIndicatorHeight="2dp"
                app:tabGravity="fill"
                app:tabMode="fixed"/>

            <androidx.viewpager2.widget.ViewPager2
                android:id="@+id/viewPagerStoryInput"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="8dp"
                android:background="@drawable/glassmorphism_background"
                android:padding="1dp"
                android:minHeight="280dp"/> <TextView
            android:id="@+id/tvAudioSelectionWarning"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/info_audio_only_one_allowed"
            android:textColor="@color/blue_light"
            android:textSize="12sp"
            android:layout_marginTop="8dp"
            android:paddingStart="4dp"
            android:paddingEnd="4dp"
            android:visibility="gone"
            tools:visibility="visible"/>

            <Space
                android:layout_width="match_parent"
                android:layout_height="24dp"/>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/label_story_type"
                android:textColor="@color/glass_hint"
                android:textSize="14sp"
                android:paddingStart="12dp"
                android:paddingEnd="12dp"
                android:paddingBottom="4dp"/>

            <com.google.android.material.textfield.TextInputLayout
                android:id="@+id/textInputLayoutStoryTypeSpinner"
                style="@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:hint="@null"
                app:boxStrokeColor="@color/white"
                app:hintTextColor="@color/white">

                <Spinner
                    android:id="@+id/spinnerStoryType"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:minHeight="48dp"
                    android:background="@drawable/spinner_background"
                    android:padding="12dp"
                    android:popupBackground="@color/glass_background"
                    android:spinnerMode="dropdown"/>
            </com.google.android.material.textfield.TextInputLayout>

            <Space
                android:layout_width="match_parent"
                android:layout_height="8dp"/>

            <com.google.android.material.textfield.TextInputLayout
                android:id="@+id/textInputLayoutOtherStoryType"
                style="@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:hint="@string/hint_specify_other_type"
                app:counterEnabled="true"
                app:counterMaxLength="100"
                android:textColorHint="@color/glass_hint"
                app:boxStrokeColor="@color/white"
                app:hintTextColor="@color/white"
                app:counterTextColor="@color/glass_hint"
                app:counterOverflowTextColor="@color/red_error"
                android:visibility="gone"
                tools:visibility="gone">

                <com.google.android.material.textfield.TextInputEditText
                    android:id="@+id/editTextOtherStoryType"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:inputType="textCapWords"
                    android:textColor="@color/white"
                    android:background="@android:color/transparent"
                    android:padding="12dp"/>
            </com.google.android.material.textfield.TextInputLayout>

            <Space
                android:layout_width="match_parent"
                android:layout_height="16dp"/>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/label_location_story"
                android:textColor="@color/glass_hint"
                android:textSize="14sp"
                android:paddingStart="12dp"
                android:paddingEnd="12dp"
                android:paddingBottom="4dp"/>

            <com.google.android.material.textfield.TextInputLayout
                android:id="@+id/textInputLayoutLocationStorySpinner"
                style="@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:hint="@null"
                app:boxStrokeColor="@color/white"
                app:hintTextColor="@color/white">

                <Spinner
                    android:id="@+id/spinnerLocation"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:background="@drawable/spinner_background"
                    android:minHeight="48dp"
                    android:padding="12dp"
                    android:popupBackground="@color/glass_background"
                    android:spinnerMode="dropdown"/>
            </com.google.android.material.textfield.TextInputLayout>

            <Space
                android:layout_width="match_parent"
                android:layout_height="16dp"/>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/label_coordinates"
                android:textColor="@color/glass_hint"
                android:textSize="14sp"
                android:paddingStart="12dp"
                android:paddingEnd="12dp"
                android:paddingBottom="4dp"/>

            <LinearLayout
                android:id="@+id/coordinatesSelectionLayout"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="vertical"
                android:gravity="center_vertical"
                android:paddingVertical="8dp"
                android:background="@drawable/glassmorphism_background"
                android:paddingHorizontal="16dp">

                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="horizontal"
                    android:gravity="center_vertical">

                    <TextView
                        android:layout_width="0dp"
                        android:layout_height="wrap_content"
                        android:layout_weight="1"
                        android:text="@string/info_coordinates"
                        android:textColor="@color/glass_hint"
                        android:textSize="14sp" />

                    <Switch
                        android:id="@+id/switchCoordinates"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:minWidth="48dp"
                        android:minHeight="48dp"
                        android:padding="8dp"
                        android:checked="false"
                        android:thumbTint="@color/blue_light"
                        android:trackTint="@color/grey_light"
                        android:contentDescription="@string/desc_coordinates_section"
                        tools:ignore="UseSwitchCompatOrMaterialXml"/>
                </LinearLayout>

                <LinearLayout
                    android:id="@+id/mapSelectionContainer"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="vertical"
                    android:layout_marginTop="8dp"
                    android:visibility="gone"
                    tools:visibility="gone">

                    <TextView
                        android:id="@+id/textViewSelectCoordinates"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:text="@string/select_location_map"
                        android:textColor="@color/white"
                        android:textSize="16sp"
                        android:padding="12dp"
                        android:minHeight="48dp"
                        android:gravity="center"
                        android:background="?attr/selectableItemBackground"
                        android:clickable="true"
                        android:focusable="true" />

                    <TextView
                        android:id="@+id/textViewSelectedCoordinates"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        tools:text="Lat: 19.4326, Lon: -99.1332"
                        android:textColor="@color/glass_text"
                        android:textSize="14sp"
                        android:padding="8dp"
                        android:visibility="gone"
                        tools:visibility="gone"/>

                    <TextView
                        android:id="@+id/textViewCityName"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        tools:text="Ciudad de México"
                        android:textColor="@color/glass_text"
                        android:textSize="14sp"
                        android:paddingStart="8dp"
                        android:paddingEnd="8dp"
                        android:paddingBottom="8dp"
                        android:visibility="gone"
                        tools:visibility="gone"/>

                    <Button
                        android:id="@+id/btnEditCoordinates"
                        style="@style/Widget.App.Button.Primary"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:minHeight="48dp"
                        android:text="@string/edit_coordinates"
                        android:visibility="gone"
                        tools:visibility="gone"
                        android:layout_marginTop="8dp"/>
                </LinearLayout>
            </LinearLayout>

            <Space
                android:layout_width="match_parent"
                android:layout_height="16dp"/>

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="vertical"
                android:layout_marginTop="16dp">

                <TextView
                    android:id="@+id/infoIconDate"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:text="@string/fecha"
                    android:textColor="@color/glass_hint"
                    android:textSize="14sp"
                    android:padding="12dp"
                    android:minHeight="48dp"
                    android:gravity="center_vertical"
                    android:contentDescription="@string/desc_date_section"
                    app:drawableEndCompat="@drawable/ic_info"
                    android:drawablePadding="4dp"
                    android:clickable="true"
                    android:focusable="true" />

                <RadioGroup
                    android:id="@+id/radioGroupDateType"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="horizontal"
                    android:layout_marginTop="8dp">

                    <RadioButton
                        android:id="@+id/radioYear"
                        android:layout_width="0dp"
                        android:layout_weight="1"
                        android:layout_height="wrap_content"
                        android:minHeight="48dp"
                        android:paddingVertical="8dp"
                        android:text="@string/date_type_year"
                        android:textColor="@color/white"
                        android:buttonTint="@color/blue_light" />

                    <RadioButton
                        android:id="@+id/radioExactDate"
                        android:layout_width="0dp"
                        android:layout_weight="1"
                        android:layout_height="wrap_content"
                        android:minHeight="48dp"
                        android:paddingVertical="8dp"
                        android:text="@string/date_type_exact"
                        android:textColor="@color/white"
                        android:buttonTint="@color/blue_light" />

                    <RadioButton
                        android:id="@+id/radioDateRange"
                        android:layout_width="0dp"
                        android:layout_weight="1"
                        android:layout_height="wrap_content"
                        android:minHeight="48dp"
                        android:paddingVertical="8dp"
                        android:text="@string/date_type_range"
                        android:textColor="@color/white"
                        android:buttonTint="@color/blue_light" />
                </RadioGroup>

                <LinearLayout
                    android:id="@+id/dateInputFieldsContainer"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="vertical"
                    android:layout_marginTop="8dp"
                    android:visibility="gone"
                    tools:visibility="gone"
                    android:baselineAligned="false">

                    <com.google.android.material.textfield.TextInputLayout
                        android:id="@+id/textInputLayoutYear"
                        style="@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:hint="@string/hint_year_story"
                        android:visibility="gone"
                        tools:visibility="gone"
                        app:boxStrokeColor="@color/white"
                        app:hintTextColor="@color/white">

                        <com.google.android.material.textfield.TextInputEditText
                            android:id="@+id/editTextYear"
                            android:layout_width="match_parent"
                            android:layout_height="wrap_content"
                            android:inputType="number"
                            android:maxLength="4"
                            android:textColor="@color/white" />
                    </com.google.android.material.textfield.TextInputLayout>

                    <TextView
                        android:id="@+id/textDateMessageStory"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:textColor="@color/red_error"
                        android:visibility="gone"
                        tools:text="Error en la fecha"
                        android:paddingStart="12dp"
                        android:paddingEnd="12dp"
                        android:paddingTop="4dp"/>

                    <com.google.android.material.textfield.TextInputLayout
                        android:id="@+id/textInputLayoutExactDate"
                        style="@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:hint="@string/hint_exact_date"
                        android:visibility="gone"
                        tools:visibility="gone"
                        app:boxStrokeColor="@color/white"
                        app:hintTextColor="@color/white">

                        <com.google.android.material.textfield.TextInputEditText
                            android:id="@+id/editTextExactDate"
                            android:layout_width="match_parent"
                            android:layout_height="wrap_content"
                            android:textColor="@color/white"
                            android:clickable="true"
                            android:focusable="false" />
                    </com.google.android.material.textfield.TextInputLayout>

                    <LinearLayout
                        android:id="@+id/dateRangeLayout"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:orientation="horizontal"
                        android:visibility="gone"
                        tools:visibility="gone"
                        android:baselineAligned="false">

                        <com.google.android.material.textfield.TextInputLayout
                            android:id="@+id/textInputLayoutStartYear"
                            style="@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox"
                            android:layout_width="0dp"
                            android:layout_height="wrap_content"
                            android:layout_weight="1"
                            android:hint="@string/hint_start_year"
                            app:boxStrokeColor="@color/white"
                            app:hintTextColor="@color/white"
                            android:layout_marginEnd="4dp">

                            <com.google.android.material.textfield.TextInputEditText
                                android:id="@+id/editTextStartYear"
                                android:layout_width="match_parent"
                                android:layout_height="wrap_content"
                                android:inputType="number"
                                android:maxLength="4"
                                android:textColor="@color/white" />
                        </com.google.android.material.textfield.TextInputLayout>

                        <com.google.android.material.textfield.TextInputLayout
                            android:id="@+id/textInputLayoutEndYear"
                            style="@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox"
                            android:layout_width="0dp"
                            android:layout_height="wrap_content"
                            android:layout_weight="1"
                            android:hint="@string/hint_end_year"
                            app:boxStrokeColor="@color/white"
                            app:hintTextColor="@color/white"
                            android:layout_marginStart="4dp">

                            <com.google.android.material.textfield.TextInputEditText
                                android:id="@+id/editTextEndYear"
                                android:layout_width="match_parent"
                                android:layout_height="wrap_content"
                                android:inputType="number"
                                android:maxLength="4"
                                android:textColor="@color/white" />
                        </com.google.android.material.textfield.TextInputLayout>
                    </LinearLayout>
                </LinearLayout>
                <RadioButton
                    android:id="@+id/radioUnknown"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:minHeight="48dp"
                    android:paddingVertical="8dp"
                    android:text="@string/date_type_unknown"
                    android:textColor="@color/white"
                    android:buttonTint="@color/blue_light"
                    android:layout_marginTop="8dp"
                    android:focusable="true" />
            </LinearLayout>

            <Space
                android:layout_width="match_parent"
                android:layout_height="16dp"/>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/label_attach_image_story_optional"
                android:textColor="@color/glass_hint"
                android:textSize="14sp"
                android:gravity="center_horizontal"
                android:paddingTop="16dp"
                android:paddingBottom="4dp"/>

            <LinearLayout
                android:id="@+id/imageSelectionLayoutStory"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="vertical"
                android:gravity="center_horizontal"
                android:layout_marginTop="8dp"
                android:background="@drawable/glassmorphism_background"
                android:padding="16dp">

                <TextView
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:text="@string/info_attach_file"
                    android:textColor="@color/glass_hint"
                    android:textSize="14sp"
                    android:gravity="center_horizontal"
                    android:paddingBottom="8dp"/>

                <Button
                    android:id="@+id/btnSelectImageStory"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:minHeight="48dp"
                    android:text="@string/select_file_button"
                    android:backgroundTint="@color/blue_primary"
                    android:textColor="@color/white"
                    style="@style/Widget.MaterialComponents.Button.UnelevatedButton"/>

                <ImageView
                    android:id="@+id/imageViewPreviewStory"
                    android:layout_width="200dp"
                    android:layout_height="200dp"
                    android:layout_marginTop="16dp"
                    android:scaleType="centerCrop"
                    android:visibility="gone"
                    tools:src="@drawable/placeholder_image"
                    android:contentDescription="@string/image_preview_description"/>

                <TextView
                    android:id="@+id/textViewPreviewLabelStory"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="4dp"
                    android:text="@string/image_preview_label"
                    android:textColor="@color/glass_hint"
                    android:textSize="12sp"
                    android:gravity="center_horizontal"
                    android:visibility="gone"/>
            </LinearLayout>
            <Space
                android:layout_width="match_parent"
                android:layout_height="24dp"/>

        </LinearLayout>
    </ScrollView>

    <LinearLayout
        android:id="@+id/buttonActionsLayoutStory"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="center"
        android:paddingHorizontal="16dp"
        android:paddingVertical="8dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

    </LinearLayout>

    <LinearLayout
        android:id="@+id/bottom_buttons_container"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="center"
        android:padding="16dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

        <Button
            android:id="@+id/btnBorrarTodo"
            style="?android:attr/buttonBarButtonStyle"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="@string/button_clear_all"
            android:backgroundTint="@color/blue_primary"
            android:textColor="@color/white"
            android:minHeight="48dp"
            android:layout_marginEnd="8dp"/>

        <Button
            android:id="@+id/btnEnviarRelato"
            style="?android:attr/buttonBarButtonStyle"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1.5"
            android:text="@string/button_send_story"
            android:backgroundTint="@color/red_button"
            android:textColor="@color/white"
            android:minHeight="48dp"/>
    </LinearLayout>

    <FrameLayout
        android:id="@+id/uploadProgressOverlayStory"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:background="#CC000000"
        android:clickable="true"
        android:focusable="true"
        android:visibility="gone"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        tools:visibility="gone">

        <LinearLayout
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:layout_gravity="center"
            android:padding="24dp"
            android:background="@drawable/glassmorphism_background"
            android:gravity="center_horizontal">

            <ProgressBar
                android:id="@+id/progressBarUploadStory"
                style="?android:attr/progressBarStyleHorizontal"
                android:layout_width="match_parent"
                android:minWidth="200dp"
                android:layout_height="wrap_content"
                android:layout_marginBottom="8dp"
                android:indeterminate="false"
                android:max="100"
                android:progress="0"
                android:progressTint="@color/white"
                android:progressBackgroundTint="@color/glass_stroke"/>

            <TextView
                android:id="@+id/textProgressStory"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:textColor="@color/white"
                android:textSize="16sp"
                android:layout_marginBottom="16dp"
                tools:text="Subiendo 0%"/>
            <Button
                android:id="@+id/btnCancelUploadStory"
                style="@style/Widget.App.Button.Primary"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:minHeight="48dp"
                android:text="@string/cancel_upload_button"
                android:backgroundTint="@color/red_error" />
        </LinearLayout>
    </FrameLayout>

</androidx.constraintlayout.widget.ConstraintLayout>


===== Archivo: app\src\main\res\layout\activity_upload_video.xml =====


<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@drawable/gradient_background"
    android:fitsSystemWindows="true">

    <LinearLayout
        android:id="@+id/headerLayout"
        android:layout_width="0dp"
        android:layout_height="?attr/actionBarSize"
        android:orientation="horizontal"
        android:gravity="center_vertical"
        android:paddingHorizontal="16dp"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

        <ImageView
            android:id="@+id/btnBack"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:minWidth="48dp"
            android:minHeight="48dp"
            android:padding="12dp"
            android:src="@drawable/ic_arrow_back"
            android:contentDescription="@string/back_button_desc"
            android:background="?attr/selectableItemBackgroundBorderless"
            android:clickable="true"
            android:focusable="true"/>

        <TextView
            android:id="@+id/screenTitle"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="@string/title_upload_video"
            android:textColor="@color/white"
            android:textSize="20sp"
            android:textStyle="bold"
            android:gravity="center_vertical"
            android:paddingStart="16dp"
            android:paddingEnd="16dp"/>
    </LinearLayout>

    <ScrollView
        android:id="@+id/scrollView"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:fillViewport="true"
        app:layout_constraintTop_toBottomOf="@id/headerLayout"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintBottom_toTopOf="@+id/bottom_buttons_container">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:padding="16dp"
            android:paddingBottom="16dp">

            <com.google.android.material.textfield.TextInputLayout
                android:id="@+id/textInputLayoutVideoTitle"
                style="@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:hint="@string/hint_video_title"
                android:textColorHint="@color/glass_hint"
                app:boxStrokeColor="@color/white"
                app:hintTextColor="@color/white">

                <com.google.android.material.textfield.TextInputEditText
                    android:id="@+id/editTextVideoTitle"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:inputType="textCapWords"
                    android:textColor="@color/white"
                    android:background="@android:color/transparent"
                    android:padding="12dp"
                    android:maxLength="37"/>
            </com.google.android.material.textfield.TextInputLayout>

            <com.google.android.material.textfield.TextInputLayout
                android:id="@+id/textInputLayoutAttachVideo"
                style="@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="8dp"
                android:hint="@string/label_attach_video"
                android:textColorHint="@color/glass_hint"
                app:boxStrokeColor="@color/white"
                app:hintTextColor="@color/white">

                <com.google.android.material.textfield.TextInputEditText
                    android:id="@+id/editTextAttachVideo"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:inputType="text"
                    android:textColor="@color/white"
                    android:background="@android:color/transparent"
                    android:padding="12dp"
                    android:clickable="true"
                    android:focusable="false" />
            </com.google.android.material.textfield.TextInputLayout>

            <FrameLayout
                android:id="@+id/videoPreviewContainer"
                android:layout_width="match_parent"
                android:layout_height="200dp"
                android:layout_marginTop="8dp"
                android:background="@color/black"
                android:visibility="gone"
                tools:visibility="gone">

                <VideoView
                    android:id="@+id/videoViewPreview"
                    android:layout_width="match_parent"
                    android:layout_height="match_parent"
                    android:layout_gravity="center"/>

                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="horizontal"
                    android:layout_gravity="bottom"
                    android:padding="8dp"
                    android:background="#80000000">

                    <ImageButton
                        android:id="@+id/btnPlay"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:minWidth="48dp"
                        android:minHeight="48dp"
                        android:padding="8dp"
                        android:src="@drawable/ic_play"
                        android:background="?attr/selectableItemBackgroundBorderless"
                        android:contentDescription="@string/play_video"
                        app:tint="@color/white"/>

                    <ImageButton
                        android:id="@+id/btnPause"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:minWidth="48dp"
                        android:minHeight="48dp"
                        android:padding="8dp"
                        android:src="@drawable/ic_pause"
                        android:background="?attr/selectableItemBackgroundBorderless"
                        android:contentDescription="@string/pause_video"
                        app:tint="@color/white"
                        android:visibility="gone"/>

                    <ImageButton
                        android:id="@+id/btnStop"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:minWidth="48dp"
                        android:minHeight="48dp"
                        android:padding="8dp"
                        android:src="@drawable/ic_stop"
                        android:background="?attr/selectableItemBackgroundBorderless"
                        android:contentDescription="@string/stop_video"
                        app:tint="@color/white"
                        android:layout_marginStart="8dp"/>

                    <View android:layout_width="0dp" android:layout_height="0dp" android:layout_weight="1"/>

                    <ImageButton
                        android:id="@+id/btnCloseVideo"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:minWidth="48dp"
                        android:minHeight="48dp"
                        android:padding="8dp"
                        android:src="@drawable/ic_close"
                        android:background="?attr/selectableItemBackgroundBorderless"
                        android:contentDescription="@string/close_video"
                        app:tint="@color/white"/>
                </LinearLayout>
            </FrameLayout>

            <com.google.android.material.textfield.TextInputLayout
                android:id="@+id/textInputLayoutYoutubeLink"
                style="@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="8dp"
                android:hint="@string/hint_youtube_link"
                android:textColorHint="@color/glass_hint"
                app:boxStrokeColor="@color/white"
                app:hintTextColor="@color/white">

                <com.google.android.material.textfield.TextInputEditText
                    android:id="@+id/editTextYoutubeLink"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:inputType="textUri"
                    android:textColor="@color/white"
                    android:background="@android:color/transparent"
                    android:padding="12dp"
                    android:maxLength="100"/>
            </com.google.android.material.textfield.TextInputLayout>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/label_attach_image_story_optional"
                android:textColor="@color/glass_hint"
                android:textSize="14sp"
                android:gravity="center_horizontal"
                android:paddingTop="16dp"
                android:paddingBottom="4dp"
                android:layout_marginTop="16dp"/>

            <LinearLayout
                android:id="@+id/coverImageSelectionLayoutVideo"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="vertical"
                android:gravity="center_horizontal"
                android:layout_marginTop="8dp"
                android:background="@drawable/glassmorphism_background"
                android:padding="16dp">

                <TextView
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:text="@string/info_attach_file"
                    android:textColor="@color/glass_hint"
                    android:textSize="14sp"
                    android:gravity="center_horizontal"
                    android:paddingBottom="8dp"/>

                <Button
                    android:id="@+id/btnSelectCoverImageVideo"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:minHeight="48dp"
                    android:text="@string/select_file_button"
                    android:backgroundTint="@color/blue_primary"
                    android:textColor="@color/white"
                    style="@style/Widget.MaterialComponents.Button.UnelevatedButton"/>

                <ImageView
                    android:id="@+id/imageViewCoverPreviewVideo"
                    android:layout_width="200dp"
                    android:layout_height="120dp"
                    android:layout_marginTop="16dp"
                    android:scaleType="centerCrop"
                    android:visibility="gone"
                    tools:src="@drawable/placeholder_image"
                    android:contentDescription="@string/image_preview_description"/>

                <TextView
                    android:id="@+id/textViewCoverPreviewLabelVideo"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="4dp"
                    android:text="@string/image_preview_label"
                    android:textColor="@color/glass_hint"
                    android:textSize="12sp"
                    android:gravity="center_horizontal"
                    android:visibility="gone"/>
            </LinearLayout>
            <com.google.android.material.textfield.TextInputLayout
                android:id="@+id/textInputLayoutVideoDescription"
                style="@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginTop="16dp"
                android:hint="@string/hint_video_description"
                app:counterEnabled="true"
                app:counterMaxLength="666"
                android:textColorHint="@color/glass_hint"
                app:boxStrokeColor="@color/white"
                app:hintTextColor="@color/white"
                app:counterTextColor="@color/glass_hint"
                app:counterOverflowTextColor="@color/red_error">

                <com.google.android.material.textfield.TextInputEditText
                    android:id="@+id/editTextVideoDescription"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:inputType="textMultiLine|textCapSentences"
                    android:minLines="3"
                    android:maxLines="5"
                    android:gravity="top"
                    android:textColor="@color/white"
                    android:background="@android:color/transparent"
                    android:padding="12dp"/>
            </com.google.android.material.textfield.TextInputLayout>

            <TextView
                android:id="@+id/labelLocationSpinner"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/label_location"
                android:textColor="@color/glass_hint"
                android:textSize="14sp"
                android:paddingStart="12dp"
                android:paddingEnd="12dp"
                android:paddingBottom="4dp"
                android:layout_marginTop="16dp"/>

            <com.google.android.material.textfield.TextInputLayout
                android:id="@+id/textInputLayoutLocation"
                style="@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:hint="@null"
                app:boxStrokeColor="@color/white"
                app:hintTextColor="@color/white">

                <Spinner
                    android:id="@+id/spinnerLocation"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:background="@drawable/spinner_background"
                    android:minHeight="48dp"
                    android:padding="12dp"
                    android:popupBackground="@color/glass_background"
                    android:spinnerMode="dropdown"/>
            </com.google.android.material.textfield.TextInputLayout>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/label_coordinates"
                android:textColor="@color/glass_hint"
                android:textSize="14sp"
                android:paddingStart="12dp"
                android:paddingEnd="12dp"
                android:paddingBottom="4dp"
                android:layout_marginTop="16dp"/>

            <LinearLayout
                android:id="@+id/coordinatesSelectionLayout"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="vertical"
                android:gravity="center_vertical"
                android:paddingVertical="8dp"
                android:background="@drawable/glassmorphism_background"
                android:paddingHorizontal="16dp">

                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="horizontal"
                    android:gravity="center_vertical">

                    <TextView
                        android:layout_width="0dp"
                        android:layout_height="wrap_content"
                        android:layout_weight="1"
                        android:text="@string/info_coordinates"
                        android:textColor="@color/glass_hint"
                        android:textSize="14sp" />

                    <Switch
                        android:id="@+id/switchCoordinates"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:minWidth="48dp"
                        android:minHeight="48dp"
                        android:padding="8dp"
                        android:checked="false"
                        android:thumbTint="@color/blue_light"
                        android:trackTint="@color/grey_light"
                        android:contentDescription="@string/desc_coordinates_section"
                        tools:ignore="UseSwitchCompatOrMaterialXml" />
                </LinearLayout>

                <LinearLayout
                    android:id="@+id/mapSelectionContainer"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="vertical"
                    android:layout_marginTop="8dp"
                    android:visibility="gone"
                    tools:visibility="gone">

                    <TextView
                        android:id="@+id/textViewSelectCoordinates"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:text="@string/select_location_map"
                        android:textColor="@color/white"
                        android:textSize="16sp"
                        android:padding="12dp"
                        android:minHeight="48dp"
                        android:gravity="center"
                        android:background="?attr/selectableItemBackground"
                        android:clickable="true"
                        android:focusable="true" />

                    <TextView
                        android:id="@+id/textViewSelectedCoordinates"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        tools:text="Lat: 19.4326, Lon: -99.1332"
                        android:textColor="@color/glass_text"
                        android:textSize="14sp"
                        android:padding="8dp"
                        android:visibility="gone"
                        tools:visibility="gone"/>

                    <TextView
                        android:id="@+id/textViewCityName"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        tools:text="Ciudad de México"
                        android:textColor="@color/glass_text"
                        android:textSize="14sp"
                        android:paddingStart="8dp"
                        android:paddingEnd="8dp"
                        android:paddingBottom="8dp"
                        android:visibility="gone"
                        tools:visibility="gone"/>

                    <Button
                        android:id="@+id/btnEditCoordinates"
                        style="@style/Widget.App.Button.Primary"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:minHeight="48dp"
                        android:text="@string/edit_coordinates"
                        android:visibility="gone"
                        tools:visibility="gone"
                        android:layout_marginTop="8dp"/>
                </LinearLayout>
            </LinearLayout>

            <TextView
                android:id="@+id/infoIconDateLabel"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/fecha"
                android:textColor="@color/glass_hint"
                android:textSize="14sp"
                android:padding="12dp"
                android:minHeight="48dp"
                android:gravity="center_vertical"
                android:layout_marginTop="16dp"
                app:drawableEndCompat="@drawable/ic_info"
                android:drawablePadding="4dp"
                android:clickable="true"
                android:focusable="true"
                android:contentDescription="@string/desc_info_icon"/>


            <RadioGroup
                android:id="@+id/radioGroupDateType"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="horizontal"
                android:layout_marginTop="8dp">

                <RadioButton
                    android:id="@+id/radioYear"
                    android:layout_width="0dp"
                    android:layout_weight="1"
                    android:layout_height="wrap_content"
                    android:minHeight="48dp"
                    android:paddingVertical="8dp"
                    android:text="@string/date_type_year"
                    android:textColor="@color/white"
                    android:buttonTint="@color/blue_light" />

                <RadioButton
                    android:id="@+id/radioExactDate"
                    android:layout_width="0dp"
                    android:layout_weight="1"
                    android:layout_height="wrap_content"
                    android:minHeight="48dp"
                    android:paddingVertical="8dp"
                    android:text="@string/date_type_exact"
                    android:textColor="@color/white"
                    android:buttonTint="@color/blue_light" />

                <RadioButton
                    android:id="@+id/radioDateRange"
                    android:layout_width="0dp"
                    android:layout_weight="1"
                    android:layout_height="wrap_content"
                    android:minHeight="48dp"
                    android:paddingVertical="8dp"
                    android:text="@string/date_type_range"
                    android:textColor="@color/white"
                    android:buttonTint="@color/blue_light" />
            </RadioGroup>

            <LinearLayout
                android:id="@+id/dateInputFieldsContainer"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="vertical"
                android:layout_marginTop="8dp"
                android:visibility="gone"
                tools:visibility="gone"
                android:baselineAligned="false">

                <com.google.android.material.textfield.TextInputLayout
                    android:id="@+id/textInputLayoutYear"
                    style="@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:hint="@string/hint_year_video"
                    android:visibility="gone"
                    tools:visibility="gone"
                    app:boxStrokeColor="@color/white"
                    app:hintTextColor="@color/white">

                    <com.google.android.material.textfield.TextInputEditText
                        android:id="@+id/editTextYear"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:inputType="number"
                        android:maxLength="4"
                        android:textColor="@color/white" />
                </com.google.android.material.textfield.TextInputLayout>

                <TextView
                    android:id="@+id/textDateMessage"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:textColor="@color/red_error"
                    android:visibility="gone"
                    tools:text="Error en la fecha"
                    android:paddingStart="12dp"
                    android:paddingEnd="12dp"
                    android:paddingTop="4dp"/>

                <com.google.android.material.textfield.TextInputLayout
                    android:id="@+id/textInputLayoutExactDate"
                    style="@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:hint="@string/hint_exact_date"
                    android:visibility="gone"
                    tools:visibility="gone"
                    app:boxStrokeColor="@color/white"
                    app:hintTextColor="@color/white">

                    <com.google.android.material.textfield.TextInputEditText
                        android:id="@+id/editTextExactDate"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:textColor="@color/white"
                        android:clickable="true"
                        android:focusable="false" />
                </com.google.android.material.textfield.TextInputLayout>

                <LinearLayout
                    android:id="@+id/dateRangeLayout"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="horizontal"
                    android:visibility="gone"
                    tools:visibility="gone"
                    android:baselineAligned="false">

                    <com.google.android.material.textfield.TextInputLayout
                        android:id="@+id/textInputLayoutStartYear"
                        style="@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox"
                        android:layout_width="0dp"
                        android:layout_height="wrap_content"
                        android:layout_weight="1"
                        android:hint="@string/hint_start_year"
                        app:boxStrokeColor="@color/white"
                        app:hintTextColor="@color/white"
                        android:layout_marginEnd="4dp">

                        <com.google.android.material.textfield.TextInputEditText
                            android:id="@+id/editTextStartYear"
                            android:layout_width="match_parent"
                            android:layout_height="wrap_content"
                            android:inputType="number"
                            android:maxLength="4"
                            android:textColor="@color/white" />
                    </com.google.android.material.textfield.TextInputLayout>

                    <com.google.android.material.textfield.TextInputLayout
                        android:id="@+id/textInputLayoutEndYear"
                        style="@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox"
                        android:layout_width="0dp"
                        android:layout_height="wrap_content"
                        android:layout_weight="1"
                        android:hint="@string/hint_end_year"
                        app:boxStrokeColor="@color/white"
                        app:hintTextColor="@color/white"
                        android:layout_marginStart="4dp">

                        <com.google.android.material.textfield.TextInputEditText
                            android:id="@+id/editTextEndYear"
                            android:layout_width="match_parent"
                            android:layout_height="wrap_content"
                            android:inputType="number"
                            android:maxLength="4"
                            android:textColor="@color/white" />
                    </com.google.android.material.textfield.TextInputLayout>
                </LinearLayout>
            </LinearLayout>

            <RadioButton
                android:id="@+id/radioUnknown"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:minHeight="48dp"
                android:paddingVertical="8dp"
                android:text="@string/date_type_unknown"
                android:textColor="@color/white"
                android:buttonTint="@color/blue_light"
                android:layout_marginTop="8dp"
                android:focusable="true" />
        </LinearLayout>
    </ScrollView>

    <LinearLayout
        android:id="@+id/buttonsLayout"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="center"
        android:paddingHorizontal="16dp"
        android:paddingVertical="8dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

    </LinearLayout>

    <LinearLayout
        android:id="@+id/bottom_buttons_container"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="center"
        android:padding="16dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

        <Button
            android:id="@+id/btnBorrarTodoVideo"
            style="?android:attr/buttonBarButtonStyle"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="@string/button_clear_all_video"
            android:backgroundTint="@color/blue_primary"
            android:textColor="@color/white"
            android:minHeight="48dp"
            android:layout_marginEnd="8dp"/>

        <Button
            android:id="@+id/btnEnviarVideo"
            style="?android:attr/buttonBarButtonStyle"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1.5"
            android:text="@string/button_send_video"
            android:backgroundTint="@color/red_button"
            android:textColor="@color/white"
            android:minHeight="48dp"/>
    </LinearLayout>

    <FrameLayout
        android:id="@+id/uploadProgressOverlayVideo"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:background="#CC000000"
        android:clickable="true"
        android:focusable="true"
        android:visibility="gone"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        tools:visibility="gone">

        <LinearLayout
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:layout_gravity="center"
            android:padding="24dp"
            android:background="@drawable/glassmorphism_background"
            android:gravity="center_horizontal">

            <ProgressBar
                android:id="@+id/progressBarUploadVideo"
                style="?android:attr/progressBarStyleHorizontal"
                android:layout_width="match_parent"
                android:minWidth="200dp"
                android:layout_height="wrap_content"
                android:layout_marginBottom="8dp"
                android:indeterminate="false"
                android:max="100"
                android:progress="0"
                android:progressTint="@color/white"
                android:progressBackgroundTint="@color/glass_stroke"/>

            <TextView
                android:id="@+id/textProgressVideo"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:textColor="@color/white"
                android:textSize="16sp"
                android:layout_marginBottom="16dp"
                tools:text="Subiendo 0%"/>
            <Button
                android:id="@+id/btnCancelUploadVideo"
                style="@style/Widget.App.Button.Primary"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:minHeight="48dp"
                android:text="@string/cancel_upload_button"
                android:backgroundTint="@color/red_error" />
        </LinearLayout>
    </FrameLayout>

</androidx.constraintlayout.widget.ConstraintLayout>


===== Archivo: app\src\main\res\layout\activity_user_profile.xml =====


<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/user_profile_main"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@drawable/gradient_background"
    tools:context=".UserProfileActivity">

    <androidx.constraintlayout.widget.ConstraintLayout
        android:id="@+id/header_container"
        android:layout_width="0dp"
        android:layout_height="?attr/actionBarSize"
        android:paddingHorizontal="16dp"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

        <ImageButton
            android:id="@+id/btn_back"
            android:layout_width="48dp"
            android:layout_height="48dp"
            android:src="@drawable/ic_arrow_back"
            android:background="?attr/selectableItemBackgroundBorderless"
            android:contentDescription="@string/back_button_desc"
            app:tint="@color/white"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintBottom_toBottomOf="parent"/>

        <TextView
            android:id="@+id/title_profile"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/profile"
            android:textColor="@color/white"
            android:textSize="20sp"
            android:textStyle="bold"
            app:layout_constraintStart_toEndOf="@id/btn_back"
            app:layout_constraintEnd_toStartOf="@+id/icon_notification"
            app:layout_constraintTop_toTopOf="parent"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintHorizontal_bias="0.5"/> <ImageView
        android:id="@+id/icon_profile"
        android:layout_width="24dp"
        android:layout_height="24dp"
        android:src="@drawable/ic_perfil"
        android:contentDescription="@string/profile"
        app:tint="@color/white"
        app:layout_constraintEnd_toStartOf="@+id/title_profile"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"
        android:layout_marginEnd="8dp"
        app:layout_constraintHorizontal_chainStyle="packed"/> <ImageView
        android:id="@+id/icon_notification"
        android:layout_width="46dp"
        android:layout_height="46dp"
        android:src="@drawable/ic_notifications"
        android:contentDescription="@string/notifications"
        android:padding="6dp"
        android:layout_marginStart="16dp"
        android:layout_gravity="center"
        app:tint="#FFFFFF"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"/>

    </androidx.constraintlayout.widget.ConstraintLayout>

    <LinearLayout
        android:layout_width="0dp"
        android:layout_height="0dp"
        android:orientation="vertical"
        app:layout_constraintTop_toBottomOf="@id/header_container"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintBottom_toBottomOf="parent">

        <com.google.android.material.tabs.TabLayout
            android:id="@+id/tab_layout"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:background="@drawable/gradient_background"
            app:tabTextColor="@color/grey_light"
            app:tabSelectedTextColor="@color/white"
            app:tabIndicatorColor="@color/blue_primary"
            app:tabIndicatorHeight="2dp"
            app:tabGravity="fill"
            app:tabMode="fixed"/>

        <androidx.viewpager2.widget.ViewPager2
            android:id="@+id/view_pager"
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_weight="1"/>

    </LinearLayout>

</androidx.constraintlayout.widget.ConstraintLayout>


===== Archivo: app\src\main\res\layout\activity_video_viewer.xml =====


<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@drawable/gradient_background"
    tools:context=".VideoViewerActivity">

    <LinearLayout
        android:id="@+id/headerLayoutVideoViewer"
        android:layout_width="0dp"
        android:layout_height="?attr/actionBarSize"
        android:orientation="horizontal"
        android:gravity="center_vertical"
        android:paddingHorizontal="16dp"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

        <ImageView
            android:id="@+id/btnBackVideoViewer"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:minWidth="48dp"
            android:minHeight="48dp"
            android:padding="12dp"
            android:src="@drawable/ic_arrow_back"
            android:contentDescription="@string/back_button_desc"
            android:background="?attr/selectableItemBackgroundBorderless"
            android:clickable="true"
            android:focusable="true"/>

        <TextView
            android:id="@+id/screenTitleVideoViewer"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="@string/title_detail_video"
            android:textColor="@color/white"
            android:textSize="20sp"
            android:textStyle="bold"
            android:gravity="center_vertical"
            android:paddingStart="16dp"
            android:paddingEnd="16dp"/>
    </LinearLayout>

    <TextView
        android:id="@+id/textViewPendingReviewStatusVideo"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:text="@string/status_pending_review_message"
        android:textColor="@color/blue_light"
        android:background="#40000000"
        android:padding="8dp"
        android:gravity="center"
        android:textSize="14sp"
        android:textStyle="italic"
        android:visibility="gone"
        app:layout_constraintTop_toBottomOf="@id/headerLayoutVideoViewer"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        tools:visibility="visible"/>

    <ScrollView
        android:id="@+id/scrollViewVideoViewerContent"
        android:layout_width="0dp"
        android:layout_height="0dp"
        app:layout_constraintTop_toBottomOf="@id/textViewPendingReviewStatusVideo"
        app:layout_constraintBottom_toTopOf="@+id/interactionLayoutVideo"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:padding="16dp">

            <TextView
                android:id="@+id/videoTitleTextViewer"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textColor="@color/white"
                android:textSize="22sp"
                android:textStyle="bold"
                android:layout_marginBottom="8dp"
                tools:text="Título del Video Escalofriante"/>

            <TextView
                android:id="@+id/videoAuthorTextViewer"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textColor="@color/glass_hint"
                android:textSize="14sp"
                android:layout_marginBottom="4dp"
                tools:text="Autor: TestUser"/>

            <TextView
                android:id="@+id/videoDateTextViewer"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textColor="@color/glass_hint"
                android:textSize="14sp"
                android:layout_marginBottom="16dp"
                tools:text="Fecha: 03/03/2023"/>

            <FrameLayout
                android:id="@+id/videoPlayerContainer"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="16dp"
                android:background="@color/black">

                <!-- Aquí reemplazamos con ExoPlayer -->
                <com.google.android.exoplayer2.ui.PlayerView
                    android:id="@+id/exoPlayerView"
                    android:layout_width="match_parent"
                    android:layout_height="250dp"
                    app:showFullScreenButton="true"
                    app:resize_mode="fixed_width"
                    android:visibility="visible"
                    tools:visibility="visible"/>

            </FrameLayout>

            <TextView
                android:id="@+id/labelComplementaryImageVideo"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/label_complementary_image"
                android:textColor="@color/glass_hint"
                android:textSize="14sp"
                android:layout_marginBottom="8dp"
                android:visibility="gone"
                tools:visibility="visible"/>

            <ImageView
                android:id="@+id/imageViewComplementaryVideoViewer"
                android:layout_width="match_parent"
                android:layout_height="200dp"
                android:scaleType="centerCrop"
                android:visibility="gone"
                tools:src="@drawable/placeholder_image"
                android:layout_marginBottom="16dp"
                android:contentDescription="@string/content_desc_complementary_image_video"/>

            <TextView
                android:id="@+id/videoLocationTextViewer"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textColor="@color/glass_hint"
                android:textSize="14sp"
                android:layout_marginBottom="16dp"
                tools:text="Ubicación: Ciudad de México"/>

            <TextView
                android:id="@+id/videoDescriptionTextViewer"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textColor="@color/white"
                android:textSize="16sp"
                android:lineSpacingMultiplier="1.2"
                tools:text="Descripción detallada del video paranormal..."/>

        </LinearLayout>
    </ScrollView>

    <LinearLayout
        android:id="@+id/interactionLayoutVideo"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:padding="8dp"
        android:gravity="center_vertical"
        android:background="@color/glass_background"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        tools:visibility="visible">

        <ImageButton
            android:id="@+id/likeButtonVideo"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:src="@drawable/ic_megusta"
            app:tint="@color/white"
            android:background="?attr/selectableItemBackgroundBorderless"
            android:padding="8dp"
            android:contentDescription="@string/me_gusta"/>
        <TextView
            android:id="@+id/likesCountVideo"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textColor="@color/white"
            android:layout_marginStart="4dp"
            android:layout_marginEnd="16dp"
            tools:text="77"/>

        <ImageButton
            android:id="@+id/commentButtonVideo"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:src="@drawable/ic_comment"
            app:tint="@color/white"
            android:background="?attr/selectableItemBackgroundBorderless"
            android:padding="8dp"
            android:contentDescription="@string/ver_comentarios"/>
        <TextView
            android:id="@+id/commentsCountVideo"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textColor="@color/white"
            android:layout_marginStart="4dp"
            tools:text="12"/>
    </LinearLayout>

</androidx.constraintlayout.widget.ConstraintLayout>


===== Archivo: app\src\main\res\layout\dialog_custom_date_picker.xml =====


<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="24dp"
    android:gravity="center_horizontal"
    android:background="@drawable/glassmorphism_background">

    <TextView
        android:id="@+id/dialogTitleTextView"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/dialog_title_select_exact_date"
        android:textSize="20sp"
        android:textStyle="bold"
        android:textColor="@color/white"
        android:layout_marginBottom="20dp"/>

    <LinearLayout
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="center">

        <NumberPicker
            android:id="@+id/numberPickerDay"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginEnd="12dp"
            android:theme="@style/NumberPickerTheme"/>

        <NumberPicker
            android:id="@+id/numberPickerMonth"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginEnd="12dp"
            android:theme="@style/NumberPickerTheme"/>

        <NumberPicker
            android:id="@+id/numberPickerYear"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:theme="@style/NumberPickerTheme"/>

    </LinearLayout>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="end"
        android:layout_marginTop="24dp">

        <Button
            android:id="@+id/buttonCancel"
            style="@style/Widget.MaterialComponents.Button.TextButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/cancelar"
            android:textColor="@color/grey_light"
            android:layout_marginEnd="8dp"/>

        <Button
            android:id="@+id/buttonAccept"
            style="@style/Widget.MaterialComponents.Button.TextButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/dialog_positive_button_accept"
            android:textColor="@color/blue_primary"/>
    </LinearLayout>

</LinearLayout>


===== Archivo: app\src\main\res\layout\fragment_admin_moderation.xml =====


<?xml version="1.0" encoding="utf-8"?>
<ScrollView
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@drawable/gradient_background"
    tools:context=".AdminModerationFragment">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:padding="16dp">

        <TextView
            android:id="@+id/tv_pending_approval_title"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/moderation_pending_approval"
            android:textColor="@color/white"
            android:textSize="18sp"
            android:textStyle="bold"
            android:layout_marginBottom="8dp"/>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:background="@drawable/glassmorphism_background"
            android:padding="12dp"
            android:layout_marginBottom="16dp">

            <TextView
                android:id="@+id/tv_pending_stories"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/moderation_stories"
                android:textColor="@color/glass_text"
                android:textSize="16sp"
                android:drawablePadding="8dp"
                app:drawableStartCompat="@drawable/ic_book"
                app:drawableTint="@color/glass_text"
                android:layout_marginBottom="4dp"/>
            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/moderation_no_items_pending"
                android:textColor="@color/glass_hint"
                android:layout_marginStart="32dp"
                android:textSize="14sp"
                android:layout_marginBottom="8dp"/>


            <TextView
                android:id="@+id/tv_pending_photos"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/moderation_photos"
                android:textColor="@color/glass_text"
                android:textSize="16sp"
                android:drawablePadding="8dp"
                app:drawableStartCompat="@drawable/ic_photo"
                app:drawableTint="@color/glass_text"
                android:layout_marginBottom="4dp"/>
            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/moderation_no_items_pending"
                android:textColor="@color/glass_hint"
                android:layout_marginStart="32dp"
                android:textSize="14sp"
                android:layout_marginBottom="8dp"/>

            <TextView
                android:id="@+id/tv_pending_videos"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/moderation_videos"
                android:textColor="@color/glass_text"
                android:textSize="16sp"
                android:drawablePadding="8dp"
                app:drawableStartCompat="@drawable/ic_video"
                app:drawableTint="@color/glass_text"
                android:layout_marginBottom="4dp"/>
            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/moderation_no_items_pending"
                android:textColor="@color/glass_hint"
                android:layout_marginStart="32dp"
                android:textSize="14sp"/>
        </LinearLayout>

        <TextView
            android:id="@+id/tv_moderation_history_title"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/moderation_history"
            android:textColor="@color/white"
            android:textSize="18sp"
            android:textStyle="bold"
            android:layout_marginBottom="8dp"/>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:background="@drawable/glassmorphism_background"
            android:padding="12dp"
            android:layout_marginBottom="16dp">

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/moderation_status_approved_rejected"
                android:textColor="@color/glass_hint"
                android:textSize="14sp"
                android:layout_marginBottom="8dp"/>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/moderation_stories"
                android:textColor="@color/glass_text"
                android:textSize="16sp"
                android:drawablePadding="8dp"
                app:drawableStartCompat="@drawable/ic_book"
                app:drawableTint="@color/glass_text"
                android:layout_marginBottom="4dp"/>
            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/moderation_no_history"
                android:textColor="@color/glass_hint"
                android:layout_marginStart="32dp"
                android:textSize="14sp"
                android:layout_marginBottom="8dp"/>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/moderation_photos"
                android:textColor="@color/glass_text"
                android:textSize="16sp"
                android:drawablePadding="8dp"
                app:drawableStartCompat="@drawable/ic_photo"
                app:drawableTint="@color/glass_text"
                android:layout_marginBottom="4dp"/>
            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/moderation_no_history"
                android:textColor="@color/glass_hint"
                android:layout_marginStart="32dp"
                android:textSize="14sp"
                android:layout_marginBottom="8dp"/>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/moderation_videos"
                android:textColor="@color/glass_text"
                android:textSize="16sp"
                android:drawablePadding="8dp"
                app:drawableStartCompat="@drawable/ic_video"
                app:drawableTint="@color/glass_text"
                android:layout_marginBottom="4dp"/>
            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/moderation_no_history"
                android:textColor="@color/glass_hint"
                android:layout_marginStart="32dp"
                android:textSize="14sp"/>
        </LinearLayout>

        <TextView
            android:id="@+id/tv_user_management_title"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/moderation_user_management"
            android:textColor="@color/white"
            android:textSize="18sp"
            android:textStyle="bold"
            android:layout_marginBottom="8dp"/>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:background="@drawable/glassmorphism_background"
            android:padding="12dp">

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/moderation_active_users"
                android:textColor="@color/glass_text"
                android:textSize="16sp"
                android:layout_marginBottom="4dp"/>
            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/moderation_no_users_to_manage"
                android:textColor="@color/glass_hint"
                android:layout_marginStart="16dp"
                android:textSize="14sp"
                android:layout_marginBottom="8dp"/>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/moderation_banned_users"
                android:textColor="@color/glass_text"
                android:textSize="16sp"
                android:layout_marginBottom="4dp"/>
            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/moderation_no_users_to_manage"
                android:textColor="@color/glass_hint"
                android:layout_marginStart="16dp"
                android:textSize="14sp"
                android:layout_marginBottom="16dp"/>

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="horizontal"
                android:gravity="center">

                <Button
                    android:id="@+id/btn_ban_user"
                    style="@style/Widget.App.Button.Primary"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/moderation_ban_button"
                    android:layout_marginEnd="8dp"/>

                <Button
                    android:id="@+id/btn_unban_user"
                    style="@style/Widget.App.Button.Primary"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/moderation_unban_button"
                    android:backgroundTint="@color/grey_button"
                    android:layout_marginStart="8dp"/>
            </LinearLayout>
        </LinearLayout>

        <TextView
            android:id="@+id/text_admin_moderation_placeholder"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/admin_moderation_placeholder"
            android:textColor="@color/grey_light"
            android:textSize="16sp"
            android:layout_marginTop="32dp"
            android:layout_gravity="center_horizontal"
            android:visibility="gone"/> </LinearLayout>
</ScrollView>


===== Archivo: app\src\main\res\layout\fragment_attach_audio.xml =====


<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="16dp"
    tools:context=".AttachAudioFragment">

    <TextView
        android:id="@+id/tvInfoAttachFile"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="@string/info_attach_audio_file"
        android:textColor="@color/glass_hint"
        android:textSize="14sp"
        android:layout_marginBottom="8dp"/>

    <Button
        android:id="@+id/btnSelectAudioFile"
        style="@style/Widget.MaterialComponents.Button.OutlinedButton"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="@string/button_select_audio"
        app:icon="@drawable/ic_attachment"
        app:iconTint="@color/white"
        app:strokeColor="@color/white"
        android:textColor="@color/white"
        android:minHeight="48dp"/>

    <FrameLayout
        android:id="@+id/waveformContainer"
        android:layout_width="match_parent"
        android:layout_height="100dp"
        android:layout_marginTop="16dp"
        android:background="@drawable/glassmorphism_background"
        android:padding="8dp"
        android:visibility="gone"
        tools:visibility="gone">

        <com.example.mexicoparanormal.WaveformView
            android:id="@+id/waveformViewAttach"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:visibility="gone"
            tools:visibility="gone"
            android:contentDescription="@string/cd_waveform_visualizer" />

        <TextView
            android:id="@+id/tvLoadingWaveformIndicator"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:text="@string/loading_waveform"
            android:textColor="@color/white"
            android:textSize="16sp"
            android:visibility="gone"
            tools:visibility="gone"/>
    </FrameLayout>


    <LinearLayout
        android:id="@+id/attachedAudioPlayerSection"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:layout_marginTop="8dp" android:visibility="gone"
        tools:visibility="visible">

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/label_attached_audio"
            android:textColor="@color/glass_hint"
            android:textSize="14sp"/>

        <TextView
            android:id="@+id/tvAttachedAudioInfo"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:textColor="@color/white"
            android:textSize="14sp"
            android:layout_marginTop="4dp"
            tools:text="mi_psicofonia.mp3"/>

        <RelativeLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="8dp">

            <ImageButton
                android:id="@+id/btnPlayAttachedAudio"
                android:layout_width="48dp"
                android:layout_height="48dp"
                android:src="@drawable/ic_play"
                app:tint="@color/white"
                android:background="?attr/selectableItemBackgroundBorderless"
                android:contentDescription="@string/content_desc_play_button"
                android:layout_centerVertical="true"
                android:layout_alignParentStart="true"/>

            <ImageButton
                android:id="@+id/btnPauseAttachedAudio"
                android:layout_width="48dp"
                android:layout_height="48dp"
                android:src="@drawable/ic_pause"
                app:tint="@color/white"
                android:background="?attr/selectableItemBackgroundBorderless"
                android:contentDescription="@string/content_desc_pause_button"
                android:layout_centerVertical="true"
                android:layout_alignParentStart="true"
                android:visibility="gone"/>

            <SeekBar
                android:id="@+id/seekBarAttachedAudio"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_toEndOf="@id/btnPlayAttachedAudio"
                android:layout_toStartOf="@id/tvPlaybackSpeedAttached"
                android:layout_centerVertical="true"
                android:layout_marginStart="8dp"
                android:layout_marginEnd="8dp"
                android:progressTint="@color/blue_primary"
                android:thumbTint="@color/blue_light"
                android:contentDescription="@string/cd_seek_bar_audio_playback"/>

            <TextView
                android:id="@+id/tvPlaybackSpeedAttached"
                android:layout_width="wrap_content"
                android:layout_height="48dp"
                android:minWidth="48dp"
                android:text="@string/text_playback_speed_1x"
                android:textColor="@color/white"
                android:textSize="16sp"
                android:gravity="center"
                android:paddingHorizontal="8dp"
                android:background="?attr/selectableItemBackgroundBorderless"
                android:clickable="true"
                android:focusable="true"
                android:layout_alignParentEnd="true"
                android:layout_centerVertical="true"
                android:contentDescription="@string/content_desc_playback_speed_selector"/>
        </RelativeLayout>

        <TextView
            android:id="@+id/tvPlayerTimerAttach"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:textColor="@color/white"
            android:textSize="12sp"
            android:gravity="center_horizontal"
            android:layout_marginTop="4dp"
            tools:text="00:00 / 00:00"
            android:visibility="gone"/>

        <ImageButton
            android:id="@+id/btnDeleteAttachedAudio"
            android:layout_width="48dp"
            android:layout_height="48dp"
            android:src="@drawable/ic_delete"
            app:tint="@color/red_error"
            android:background="?attr/selectableItemBackgroundBorderless"
            android:contentDescription="@string/content_desc_delete_audio_button"
            android:layout_gravity="center_horizontal"
            android:layout_marginTop="8dp"
            android:padding="8dp"/>
    </LinearLayout>
</LinearLayout>


===== Archivo: app\src\main\res\layout\fragment_record_audio.xml =====


<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="16dp"
    tools:context=".RecordAudioFragment"
    android:background="@drawable/gradient_background">

    <TextView
        android:id="@+id/tvAudioSourceLabel"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/audio_source_label"
        android:textColor="@color/white"
        android:textSize="16sp"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toTopOf="@+id/spinnerAudioSource"
        android:layout_marginBottom="4dp"/>

    <Spinner
        android:id="@+id/spinnerAudioSource"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:minHeight="48dp"
        android:background="@drawable/spinner_background"
        android:popupBackground="@color/glass_background"
        app:layout_constraintTop_toBottomOf="@id/tvAudioSourceLabel"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        android:layout_marginTop="4dp"
        android:contentDescription="@string/audio_source_prompt" />

    <TextView
        android:id="@+id/tvRecordingStatusDetailed"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="24dp"
        android:text="@string/status_ready_to_record"
        android:textColor="@color/white"
        android:textSize="18sp"
        android:textStyle="bold"
        app:layout_constraintTop_toBottomOf="@id/spinnerAudioSource"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent" />

    <TextView
        android:id="@+id/tvRecordingTimer"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="8dp"
        android:text="@string/timer_default"
        android:textColor="@color/white"
        android:textSize="16sp"
        android:fontFamily="monospace"
        android:gravity="center_horizontal"
        android:lineSpacingMultiplier="1.2"
        app:layout_constraintTop_toBottomOf="@id/tvRecordingStatusDetailed"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent" />

    <com.example.mexicoparanormal.WaveformView
        android:id="@+id/waveformView"
        android:layout_width="0dp"
        android:layout_height="100dp"
        android:layout_marginTop="16dp"
        android:background="@drawable/glassmorphism_background"
        android:padding="8dp"
        app:layout_constraintTop_toBottomOf="@id/tvRecordingTimer"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        android:contentDescription="@string/cd_waveform_visualizer" />

    <com.google.android.material.button.MaterialButton
        android:id="@+id/btnStartStopRecording"
        style="@style/Widget.App.Button.Primary"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="24dp"
        android:text="@string/button_start_recording"
        android:textColor="@color/white"
        android:backgroundTint="@color/red_button"
        app:icon="@drawable/ic_record_red"
        app:iconTint="@color/white"
        app:iconPadding="12dp"
        android:paddingLeft="24dp"
        android:paddingRight="24dp"
        android:paddingTop="12dp"
        android:paddingBottom="12dp"
        android:textSize="18sp"
        android:textStyle="bold"
        app:cornerRadius="24dp"
        app:layout_constraintTop_toBottomOf="@id/waveformView"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        android:contentDescription="@string/cd_start_recording_button"/>

    <LinearLayout
        android:id="@+id/secondaryRecordingControls"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:layout_marginTop="16dp"
        android:visibility="gone"
        tools:visibility="gone"
        app:layout_constraintTop_toBottomOf="@id/btnStartStopRecording"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

        <com.google.android.material.button.MaterialButton
            android:id="@+id/btnPauseResumeRecording"
            style="@style/Widget.App.Button.Primary"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/button_pause_recording"
            android:textColor="@color/white"
            android:backgroundTint="@color/blue_primary"
            app:icon="@drawable/ic_pause_red"
            app:iconTint="@color/white"
            app:iconPadding="8dp"
            android:paddingLeft="20dp"
            android:paddingRight="20dp"
            app:cornerRadius="20dp"
            android:contentDescription="@string/cd_pause_recording_button"/>

    </LinearLayout>

    <LinearLayout
        android:id="@+id/recordedAudioPlayerSection"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:layout_marginTop="16dp"
        android:padding="12dp"
        android:background="@drawable/glassmorphism_background"
        android:visibility="gone"
        tools:visibility="visible"
        app:layout_constraintTop_toBottomOf="@id/secondaryRecordingControls"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintVertical_bias="0.0">

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/player_recorded_audio_title"
            android:textColor="@color/white"
            android:textSize="16sp"
            android:textStyle="bold"
            android:layout_marginBottom="4dp"/>

        <TextView
            android:id="@+id/tvRecordedAudioFileName"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            tools:text="Archivo: grabacion_2023-10-27_10-30-00.m4a"
            android:textColor="@color/glass_hint"
            android:textSize="12sp"
            android:layout_marginBottom="8dp"/>

        <RelativeLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content">

            <ImageButton
                android:id="@+id/btnPlayRecordedAudio"
                android:layout_width="48dp"
                android:layout_height="48dp"
                android:src="@drawable/ic_play"
                app:tint="@color/white"
                android:background="?attr/selectableItemBackgroundBorderless"
                android:contentDescription="@string/cd_play_recorded_audio"
                android:layout_centerVertical="true"
                android:layout_alignParentStart="true"/>

            <ImageButton
                android:id="@+id/btnPauseRecordedAudio"
                android:layout_width="48dp"
                android:layout_height="48dp"
                android:src="@drawable/ic_pause"
                app:tint="@color/white"
                android:background="?attr/selectableItemBackgroundBorderless"
                android:contentDescription="@string/cd_pause_recorded_audio"
                android:layout_centerVertical="true"
                android:layout_alignParentStart="true"
                android:visibility="gone"/>

            <SeekBar
                android:id="@+id/seekBarRecordedAudio"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_toEndOf="@id/btnPlayRecordedAudio"
                android:layout_toStartOf="@id/tvPlaybackSpeedRecorded"
                android:layout_centerVertical="true"
                android:layout_marginStart="8dp"
                android:layout_marginEnd="8dp"
                android:progressTint="@color/blue_primary"
                android:thumbTint="@color/blue_light"
                android:contentDescription="@string/cd_seek_bar_audio_playback"/>

            <TextView
                android:id="@+id/tvPlaybackSpeedRecorded"
                android:layout_width="wrap_content"
                android:layout_height="48dp"
                android:minWidth="48dp"
                android:text="@string/text_playback_speed_1x"
                android:textColor="@color/white"
                android:textSize="16sp"
                android:gravity="center"
                android:paddingHorizontal="8dp"
                android:background="?attr/selectableItemBackgroundBorderless"
                android:clickable="true"
                android:focusable="true"
                android:layout_alignParentEnd="true"
                android:layout_centerVertical="true"
                android:contentDescription="@string/cd_playback_speed"/>
        </RelativeLayout>

        <TextView
            android:id="@+id/tvPlayerTimer"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:textColor="@color/white"
            android:textSize="12sp"
            android:gravity="center_horizontal"
            android:layout_marginTop="4dp"
            tools:text="00:00 / 00:00"
            android:visibility="gone"/>

        <LinearLayout
            android:id="@+id/playerActionButtonsLayout"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:gravity="center_vertical"
            android:layout_marginTop="8dp">

            <ImageButton
                android:id="@+id/btnSaveLocalAudio"
                android:layout_width="0dp"
                android:layout_height="48dp"
                android:layout_weight="1"
                android:src="@drawable/ic_save_audio"
                app:tint="@color/white"
                android:background="?attr/selectableItemBackgroundBorderless"
                android:contentDescription="@string/cd_save_local_audio"
                android:padding="8dp"
                android:visibility="gone"/>

            <ImageButton
                android:id="@+id/btnDeleteRecordedAudio"
                android:layout_width="0dp"
                android:layout_height="48dp"
                android:layout_weight="1"
                android:src="@drawable/ic_delete"
                app:tint="@color/red_error"
                android:background="?attr/selectableItemBackgroundBorderless"
                android:contentDescription="@string/cd_delete_recorded_audio"
                android:padding="8dp"/>

 </LinearLayout>
    </LinearLayout>

</androidx.constraintlayout.widget.ConstraintLayout>


===== Archivo: app\src\main\res\layout\fragment_settings.xml =====


<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@drawable/gradient_background"
    tools:context=".SettingsFragment">

    <ScrollView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:padding="16dp"
            android:gravity="center_horizontal">

            <ImageView
                android:id="@+id/imageViewProfilePictureSettings"
                android:layout_width="100dp" android:layout_height="100dp" android:layout_marginTop="16dp"
                android:layout_marginBottom="16dp"
                android:scaleType="centerCrop"
                android:contentDescription="@string/my_profile"
                android:src="@drawable/ic_perfil" />
            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/my_profile"
                android:textColor="@color/white"
                android:textSize="18sp"
                android:textStyle="bold"
                android:layout_marginBottom="8dp"/>
            <TextView
                android:id="@+id/textViewUsernameDisplay"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textColor="@color/grey_light"
                android:textSize="16sp"
                android:layout_marginStart="16dp"
                android:layout_marginBottom="4dp"
                tools:text="Nombre de Usuario Cargado"/>
            <TextView
                android:id="@+id/textViewLocationDisplay"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textColor="@color/grey_light"
                android:textSize="16sp"
                android:layout_marginStart="16dp"
                android:layout_marginBottom="16dp"
                tools:text="Ubicación Cargada"/>
            <LinearLayout
                android:id="@+id/option_edit_profile"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="horizontal"
                android:gravity="center_vertical"
                android:paddingVertical="12dp"
                android:background="?attr/selectableItemBackground">
                <ImageView
                    android:layout_width="24dp"
                    android:layout_height="24dp"
                    android:src="@drawable/ic_settings"
                    android:contentDescription="@string/edit_profile"
                    app:tint="@color/white"/>
                <TextView
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:layout_weight="1"
                    android:text="@string/edit_profile"
                    android:textColor="@color/white"
                    android:textSize="16sp"
                    android:layout_marginStart="16dp"/>
            </LinearLayout>
            <LinearLayout
                android:id="@+id/option_comments"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="horizontal"
                android:gravity="center_vertical"
                android:paddingVertical="12dp"
                android:background="?attr/selectableItemBackground">
                <ImageView
                    android:layout_width="24dp"
                    android:layout_height="24dp"
                    android:src="@drawable/ic_comment"
                    android:contentDescription="@string/comments"
                    app:tint="@color/white"/>
                <TextView
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:layout_weight="1"
                    android:text="@string/comments"
                    android:textColor="@color/white"
                    android:textSize="16sp"
                    android:layout_marginStart="16dp"/>
            </LinearLayout>
            <LinearLayout
                android:id="@+id/option_favorites"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="horizontal"
                android:gravity="center_vertical"
                android:paddingVertical="12dp"
                android:background="?attr/selectableItemBackground">
                <ImageView
                    android:layout_width="24dp"
                    android:layout_height="24dp"
                    android:src="@drawable/ic_corazon"
                    android:contentDescription="@string/favorites"
                    app:tint="@color/white"/>
                <TextView
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:layout_weight="1"
                    android:text="@string/favorites"
                    android:textColor="@color/white"
                    android:textSize="16sp"
                    android:layout_marginStart="16dp"/>
            </LinearLayout>
            <View
                android:layout_width="match_parent"
                android:layout_height="1dp"
                android:background="#44FFFFFF"
                android:layout_marginTop="16dp"
                android:layout_marginBottom="16dp"/>
            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="@string/account_section_title"
                android:textColor="@color/white"
                android:textSize="18sp"
                android:textStyle="bold"
                android:layout_marginBottom="16dp"/>
            <LinearLayout
                android:id="@+id/option_logout"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="horizontal"
                android:gravity="center_vertical"
                android:paddingVertical="12dp"
                android:background="?attr/selectableItemBackground">
                <ImageView
                    android:layout_width="24dp"
                    android:layout_height="24dp"
                    android:src="@drawable/ic_logout"
                    android:contentDescription="@string/logout"
                    app:tint="@color/white"/>
                <TextView
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:layout_weight="1"
                    android:text="@string/logout"
                    android:textColor="@color/white"
                    android:textSize="16sp"
                    android:layout_marginStart="16dp"/>
            </LinearLayout>
            <LinearLayout
                android:id="@+id/option_delete_account"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="horizontal"
                android:gravity="center_vertical"
                android:paddingVertical="12dp"
                android:background="?attr/selectableItemBackground">
                <ImageView
                    android:layout_width="24dp"
                    android:layout_height="24dp"
                    android:src="@drawable/ic_delete"
                    android:contentDescription="@string/delete_account"
                    app:tint="@color/white"/>
                <TextView
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:layout_weight="1"
                    android:text="@string/delete_account"
                    android:textColor="@color/white"
                    android:textSize="16sp"
                    android:layout_marginStart="16dp"/>
            </LinearLayout>
        </LinearLayout>
    </ScrollView>

    <ProgressBar
        android:id="@+id/settingsProgressBar"
        style="?android:attr/progressBarStyleLarge"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:visibility="gone"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        android:elevation="10dp"
        tools:visibility="visible"/>

    <TextView
        android:id="@+id/settingsProgressMessage"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:textColor="@color/white"
        android:textSize="16sp"
        android:layout_marginTop="8dp"
        android:visibility="gone"
        app:layout_constraintTop_toBottomOf="@id/settingsProgressBar"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        tools:text="Eliminando cuenta..."
        android:elevation="10dp"/>

</androidx.constraintlayout.widget.ConstraintLayout>


===== Archivo: app\src\main\res\layout\fragment_uploads.xml =====


<?xml version="1.0" encoding="utf-8"?>
<ScrollView
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@drawable/gradient_background"
    tools:context=".UploadsFragment">

    <!-- Contenido dentro del ScrollView -->
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:padding="16dp">

        <!-- Título "Subidas" -->
        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/uploads"
            android:textColor="@color/white"
            android:textSize="18sp"
            android:textStyle="bold"
            android:layout_marginBottom="16dp"/>

        <!-- Opción: Subir Relato -->
        <LinearLayout
            android:id="@+id/option_upload_relato"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:gravity="center_vertical"
            android:paddingVertical="12dp"
            android:background="?attr/selectableItemBackground">

            <ImageView
                android:layout_width="24dp"
                android:layout_height="24dp"
                android:src="@drawable/ic_book"
                android:contentDescription="@string/upload_relato"
                app:tint="@color/white"/>

            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:text="@string/upload_relato"
                android:textColor="@color/white"
                android:textSize="16sp"
                android:layout_marginStart="16dp"/>
        </LinearLayout>

        <!-- Opción: Subir Foto -->
        <LinearLayout
            android:id="@+id/option_upload_foto"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:gravity="center_vertical"
            android:paddingVertical="12dp"
            android:background="?attr/selectableItemBackground">

            <ImageView
                android:layout_width="24dp"
                android:layout_height="24dp"
                android:src="@drawable/ic_photo"
                android:contentDescription="@string/upload_foto"
                app:tint="@color/white"/>

            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:text="@string/upload_foto"
                android:textColor="@color/white"
                android:textSize="16sp"
                android:layout_marginStart="16dp"/>
        </LinearLayout>

        <!-- Opción: Subir Video -->
        <LinearLayout
            android:id="@+id/option_upload_video"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:gravity="center_vertical"
            android:paddingVertical="12dp"
            android:background="?attr/selectableItemBackground">

            <ImageView
                android:layout_width="24dp"
                android:layout_height="24dp"
                android:src="@drawable/ic_video"
                android:contentDescription="@string/upload_video"
                app:tint="@color/white"/>

            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:text="@string/upload_video"
                android:textColor="@color/white"
                android:textSize="16sp"
                android:layout_marginStart="16dp"/>
        </LinearLayout>

        <!-- Divisor -->
        <View
            android:layout_width="match_parent"
            android:layout_height="1dp"
            android:background="#44FFFFFF"
            android:layout_marginTop="16dp"
            android:layout_marginBottom="16dp"/>

        <!-- Título "Mis Envíos" -->
        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/my_uploads"
            android:textColor="@color/white"
            android:textSize="18sp"
            android:textStyle="bold"
            android:layout_marginBottom="16dp"/>

        <!-- Estado: Pendientes -->
        <LinearLayout
            android:id="@+id/status_pending"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:gravity="center_vertical"
            android:paddingVertical="12dp"
            android:background="?attr/selectableItemBackground">

            <ImageView
                android:layout_width="24dp"
                android:layout_height="24dp"
                android:src="@drawable/ic_pending"
                android:contentDescription="@string/pending"
                app:tint="@color/white"/>

            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:text="@string/pending"
                android:textColor="@color/white"
                android:textSize="16sp"
                android:layout_marginStart="16dp"/>
        </LinearLayout>

        <!-- Estado: Aprobados -->
        <LinearLayout
            android:id="@+id/status_approved"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:gravity="center_vertical"
            android:paddingVertical="12dp"
            android:background="?attr/selectableItemBackground">

            <ImageView
                android:layout_width="24dp"
                android:layout_height="24dp"
                android:src="@drawable/ic_approved"
                android:contentDescription="@string/approved"
                app:tint="@color/white"/>

            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:text="@string/approved"
                android:textColor="@color/white"
                android:textSize="16sp"
                android:layout_marginStart="16dp"/>
        </LinearLayout>

        <!-- Estado: Rechazados -->
        <LinearLayout
            android:id="@+id/status_rejected"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:gravity="center_vertical"
            android:paddingVertical="12dp"
            android:background="?attr/selectableItemBackground">

            <ImageView
                android:layout_width="24dp"
                android:layout_height="24dp"
                android:src="@drawable/ic_rejected"
                android:contentDescription="@string/rejected"
                app:tint="@color/white"/>

            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:text="@string/rejected"
                android:textColor="@color/white"
                android:textSize="16sp"
                android:layout_marginStart="16dp"/>
        </LinearLayout>

    </LinearLayout> <!-- Cierre del LinearLayout principal -->
</ScrollView> <!-- Cierre correcto del ScrollView -->


===== Archivo: app\src\main\res\layout\fragment_write_story.xml =====


<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="16dp"
    tools:context=".WriteStoryFragment">

    <com.google.android.material.textfield.TextInputLayout
        android:id="@+id/textInputLayoutStoryText"
        style="@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:hint="@string/hint_story_text_or_record_audio"
        app:counterEnabled="true"
        app:counterMaxLength="20000" android:textColorHint="@color/glass_hint"
        app:boxStrokeColor="@color/white"
        app:hintTextColor="@color/white"
        app:counterTextColor="@color/glass_hint"
        app:counterOverflowTextColor="@color/red_error">

        <com.google.android.material.textfield.TextInputEditText
            android:id="@+id/editTextStoryText"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:gravity="top"
            android:inputType="textMultiLine|textCapSentences"
            android:minLines="10"
            android:maxLines="15" android:scrollbars="vertical"
            android:textColor="@color/white"
            android:background="@android:color/transparent"
            android:padding="12dp"/>
    </com.google.android.material.textfield.TextInputLayout>

    <TextView
        android:id="@+id/tvKeyboardSuggestion"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="@string/suggestion_use_voice_to_text_keyboard"
        android:textColor="@color/blue_light"
        android:textSize="12sp"
        android:layout_marginTop="8dp"
        android:paddingStart="4dp"
        android:paddingEnd="4dp"
        android:gravity="center_horizontal"/>

</LinearLayout>


===== Archivo: app\src\main\res\layout\item_comment.xml =====


<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="16dp">

    <TextView
        android:id="@+id/text_comment_user"
        style="@style/TextAppearance.CardTitle"
        tools:text="Usuario1"/>

    <TextView
        android:id="@+id/text_comment_text"
        style="@style/TextAppearance.CardDescription"
        tools:text="Este relato me dio mucho miedo!"/>

</LinearLayout>


===== Archivo: app\src\main\res\layout\item_dashboard_card.xml =====


<?xml version="1.0" encoding="utf-8"?>
<androidx.cardview.widget.CardView
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="160dp"
    android:layout_margin="8dp"
    app:cardCornerRadius="8dp"
    app:cardBackgroundColor="#1a1928"
    app:cardElevation="4dp"
    tools:layout_height="120dp">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:gravity="center"
        android:padding="16dp">

        <ImageView
            android:id="@+id/dashboard_item_icon"
            android:layout_width="60dp"
            android:layout_height="60dp"
            android:scaleType="fitCenter"
            app:tint="#FFFFFF"
            android:contentDescription="@null"
            android:layout_gravity="center_horizontal" />  <TextView
        android:id="@+id/dashboard_item_title"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="8dp"
        android:textSize="16sp"
        android:textColor="#FFFFFF"
        android:textAlignment="center"
        android:fontFamily="@font/montserratbold"
        android:gravity="center_horizontal" /> </LinearLayout>

</androidx.cardview.widget.CardView>


===== Archivo: app\src\main\res\layout\item_search_result.xml =====


<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:padding="16dp"
    android:background="@drawable/glassmorphism_background"
    android:layout_marginBottom="8dp"
    android:foreground="?attr/selectableItemBackground"
    android:clickable="true"
    android:focusable="true">

    <TextView
        android:id="@+id/text_result_title"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:textSize="16sp"
        android:textColor="#FFFFFF"
        android:textStyle="bold"
        android:contentDescription="@string/result_item_description"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        android:layout_marginBottom="4dp"
        tools:text="1. Relato: &quot;Encuentro en Oaxaca&quot; (Experiencias)"/>

    <TextView
        android:id="@+id/text_result_details"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:textSize="14sp"
        android:textColor="#E1E1E1"
        android:layout_marginTop="4dp"
        android:contentDescription="@string/result_details_description"
        app:layout_constraintTop_toBottomOf="@id/text_result_title"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        tools:text="- Ubicación: Oaxaca | Fecha: 2022"/>

    <View
        android:layout_width="0dp"
        android:layout_height="1dp"
        android:background="#33FFFFFF"
        app:layout_constraintTop_toBottomOf="@id/text_result_details"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        android:layout_marginTop="8dp"/>

</androidx.constraintlayout.widget.ConstraintLayout>


===== Archivo: app\src\main\res\layout\list_item_pending_upload.xml =====


<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    android:padding="16dp"
    android:gravity="center_vertical"
    android:background="@drawable/glassmorphism_background"
    android:layout_marginBottom="8dp"
    android:clickable="true"
    android:focusable="true"
    android:foreground="?attr/selectableItemBackground">

    <ImageView
        android:id="@+id/imageViewItemTypeIcon"
        android:contentDescription="@string/content_desc_item_type_icon"
        android:layout_width="40dp"
        android:layout_height="40dp"
        android:layout_marginEnd="16dp"
        app:tint="@color/white"
        tools:src="@drawable/ic_book"/>

    <LinearLayout
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:orientation="vertical">

        <TextView
            android:id="@+id/textViewItemTitle"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textSize="16sp"
            android:textStyle="bold"
            android:textColor="@color/white"
            tools:text="Título del Envío Pendiente"
            android:maxLines="2"
            android:ellipsize="end"/>

        <TextView
            android:id="@+id/textViewItemSubmissionDate"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textSize="12sp"
            android:textColor="@color/glass_hint"
            tools:text="Enviado: 24/05/2025"/>

    </LinearLayout>

    <ImageView
        android:id="@+id/imageViewPendingIndicator"
        android:layout_width="24dp"
        android:layout_height="24dp"
        android:src="@drawable/ic_pending"
        app:tint="@color/blue_light"
        android:layout_marginStart="8dp"
        android:contentDescription="@string/content_desc_pending_status"/>

</LinearLayout>


===== Archivo: app\src\main\res\layout\list_item_section_header.xml =====


<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    android:paddingStart="16dp"
    android:paddingEnd="16dp"
    android:paddingTop="16dp"
    android:paddingBottom="8dp"
    android:background="@drawable/gradient_background">

    <TextView
        android:id="@+id/textViewSectionHeader"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:textSize="18sp"
        android:textStyle="bold"
        android:textColor="@color/white"
        android:text="@string/placeholder_section_title"/>
</LinearLayout>


===== Archivo: app\src\main\res\layout\spinner_dropdown_item.xml =====


<CheckedTextView xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="?attr/dropdownListPreferredItemHeight"
    android:textColor="@color/white"
    android:background="@color/glass_background"
    android:ellipsize="marquee"
    android:singleLine="true"/>


===== Archivo: app\src\main\res\layout\spinner_item.xml =====


<!-- archivo: app/src/main/res/layout/spinner_item.xml -->
<TextView xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:padding="12dp"
    android:textColor="@color/white"
    android:textSize="16sp"
    android:ellipsize="end"
    android:singleLine="true"/>


===== Archivo: app\src\main\res\mipmap-anydpi-v26\ic_launcher.xml =====


<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background"/>
    <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
</adaptive-icon>


===== Archivo: app\src\main\res\mipmap-anydpi-v26\ic_launcher_round.xml =====


<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background"/>
    <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
</adaptive-icon>


===== Archivo: app\src\main\res\values\arrays.xml =====


<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string-array name="story_types_array">
        <item>Seleccione un tipo</item>
        <item>Experiencias</item>
        <item>Mitos/Leyendas</item>
        <item>Pistas</item>
        <item>Otro (especifique)</item>
    </string-array>

    <string-array name="locations_array">
        <item>Seleccione una ubicación</item>
        <item>desconocido</item>
        <item>aguascalientes</item>
        <item>baja_california</item>
        <item>baja_california_sur</item>
        <item>campeche</item>
        <item>chiapas</item>
        <item>chihuahua</item>
        <item>coahuila</item>
        <item>colima</item>
        <item>ciudad_de_mexico</item>
        <item>durango</item>
        <item>estado_de_mexico</item>
        <item>guanajuato</item>
        <item>guerrero</item>
        <item>hidalgo</item>
        <item>jalisco</item>
        <item>michoacan</item>
        <item>morelos</item>
        <item>nayarit</item>
        <item>nuevo_leon</item>
        <item>oaxaca</item>
        <item>puebla</item>
        <item>queretaro</item>
        <item>quintana_roo</item>
        <item>san_luis_potosi</item>
        <item>sinaloa</item>
        <item>sonora</item>
        <item>tabasco</item>
        <item>tamaulipas</item>
        <item>tlaxcala</item>
        <item>veracruz</item>
        <item>yucatan</item>
        <item>zacatecas</item>
    </string-array>
</resources>


===== Archivo: app\src\main\res\values\attrs.xml =====


<?xml version="1.0" encoding="utf-8"?>
<resources>
    <declare-styleable name="ExoPlayerView">
        <attr name="showFullScreenButton" format="boolean" />
    </declare-styleable>
</resources>


===== Archivo: app\src\main\res\values\colors.xml =====


<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Colores base -->
    <color name="purple_dark">#301934</color>
    <color name="black">#FF000000</color>
    <color name="white">#FFFFFFFF</color>
    <color name="blue_primary">#226df6</color>
    <color name="blue_light">#ADD8E6</color>
    <color name="grey_light">#D3D3D3</color>
    <color name="card_background">#2A283E</color>
    <color name="card_shadow">#1A000000</color>

    <!-- Colores para glassmorphism -->
    <color name="glass_background">#E61E1E1E</color>  <!-- 90% opacity de gris oscuro -->
    <color name="glass_stroke">#33FFFFFF</color>        <!-- Borde semi-transparente -->
    <color name="glass_text">#FFFFFF</color>            <!-- Texto blanco sólido -->
    <color name="glass_hint">#B3FFFFFF</color>          <!-- Hint con 70% opacidad -->
    <color name="purple_light">#4B3B5E</color> <!-- Color adicional para mejor contraste -->

    <!-- colores de texto/hints -->
    <color name="hint_text_color_light">#FFFFFFFF</color> ```

    <color name="red_button">#F44336</color>
    <color name="grey_button">#9E9E9E</color>
    <color name="red_error">#F44336</color>
    <color name="green_success">#7ED321</color>

    <color name="bottom_bar_background">#33000000</color>

    <!-- Otros colores -->
    <color name="map_polygon_fill">#440000FF</color>
    <color name="map_polygon_stroke">#FF0000FF</color>

    <!-- Colores onda de audio-->
    <color name="waveform_wave_color">#43D996</color>
    <color name="waveform_background_color">#000000</color>
    <color name="waveform_grid_color">#333333</color>
    <color name="waveform_indicator_color">#BF0000</color>
    <color name="waveform_center_line_grid_color">#555555</color>

</resources>


===== Archivo: app\src\main\res\values\dimens.xml =====


<!-- app/src/main/res/values/dimens.xml -->
<resources>
    <dimen name="card_margin">8dp</dimen>
    <dimen name="card_corner_radius">12dp</dimen>
</resources>


===== Archivo: app\src\main\res\values\strings.xml =====


<resources>

    <!-- AdminModerationFragment.kt -->
    <string name="admin_moderation_ban_user_placeholder">Funcionalidad Banear (Próximamente)</string>
    <string name="admin_moderation_unban_user_placeholder">Funcionalidad Desbanear (Próximamente)</string>

    <!-- AdminProfileActivity.kt -->
    <string name="tab_moderation_title">Moderación</string>
    <string name="uploads">Subidas</string>
    <string name="settings">Personalización</string>
    <string name="error_invalid_fragment_position">Posición inválida: %d</string>
    <string name="toast_upload_story_tapped">Has pulsado en Subir Relato</string>
    <string name="toast_upload_photo_tapped">Has pulsado en Subir Foto</string>
    <string name="toast_upload_video_tapped">Has pulsado en Subir Video</string>
    <string name="toast_pending_section_tapped">Has pulsado en Sección Pendientes</string>
    <string name="toast_approved_tapped_placeholder">Has pulsado en Aprobados (Próximamente)</string>
    <string name="toast_rejected_tapped_placeholder">Has pulsado en Rechazados (Próximamente)</string>

    <!-- AttachAudioFragment.kt -->
    <string name="error_audio_invalid_type_detailed">Archivo \"%1$s\" no es un tipo de audio válido (tipo detectado: %2$s). Formatos permitidos: MP3, Opus, OGG, M4A, AAC.</string>
    <string name="unknown_format">Formato desconocido</string>
    <string name="error_audio_file_too_large_detailed">El audio es demasiado grande (%2$dMB). Máx: %1$dMB.</string>
    <string name="error_audio_cannot_get_duration">No se pudo determinar la duración del archivo de audio: %s.</string>
    <string name="error_audio_duration_exceeded">El audio excede la duración máxima (%d min).</string>
    <string name="error_audio_duration_exceeded_detailed">El audio (%2$d min) excede la duración máx permitida (%1$d min).</string>
    <string name="audio_selection_successful">El audio ha cargado exitosamente.</string>
    <string name="log_error_security_exception_select_audio">SecurityException al seleccionar audio: %s</string>
    <string name="error_accessing_file_permission">Error al acceder al archivo: %1$s. Permiso denegado.</string>
    <string name="selected_audio_default_name">audio seleccionado</string>
    <string name="log_error_processing_selected_audio">Error al procesar el audio seleccionado: %s</string>
    <string name="upload_file_error_message">Error al subir archivo: %s</string>
    <string name="unknown_error">Ocurrió un error desconocido.</string>
    <string name="error_audio_selection_cancelled">Selección de audio cancelada.</string>
    <string name="error_must_implement_audio_attach_listener">%s debe implementar AudioAttachListener</string>
    <string name="info_attach_audio_file">Sube un archivo de audio (MP3, M4A, Opus, OGG). Máx. %1$dMB y %2$d min.</string>
    <string name="text_playback_speed_1x">1x</string>
    <string name="player_timer_default_ss">00:00 / 00:00</string>
    <string name="error_no_audio_to_play">No hay ningún audio seleccionado para reproducir.</string>
    <string name="log_launch_audio_analysis">Lanzando análisis de audio para URI: %s</string>
    <string name="log_waveform_job_cancelled">Job de generación de forma de onda cancelado para %s</string>
    <string name="log_fragment_not_added_or_job_cancelled_after_extraction">Fragmento no añadido o job cancelado después de la extracción para %s</string>
    <string name="log_waveform_data_set">Datos de forma de onda establecidos e invalidación enviada.</string>
    <string name="log_waveform_update_samples">La forma de onda se actualizará con %d muestras.</string>
    <string name="log_no_amplitudes_extracted">No se extrajeron amplitudes o hubo un error durante la extracción para %s.</string>
    <string name="error_generating_waveform_preview">No se pudo generar vista previa de la onda para este archivo.</string>
    <string name="log_starting_amplitude_extraction">Iniciando extracción de amplitud para URI: %1$s, muestras objetivo: %2$s</string>
    <string name="log_error_open_filedescriptor_null">Fallo al abrir FileDescriptor para %s. pfd es nulo.</string>
    <string name="log_mediasource_set_successful">MediaExtractor setDataSource exitoso.</string>
    <string name="log_track_info">Pista %1$s: Tipo MIME: %2$s, Formato: %3$s</string>
    <string name="log_audio_track_found">Pista de audio encontrada en el índice %1$s con formato: %2$s</string>
    <string name="log_no_audio_track_found_uri">No se encontró pista de audio en %s</string>
    <string name="log_mime_type_null_for_audio_track">El tipo MIME es nulo para la pista de audio.</string>
    <string name="log_selected_audio_track_mime">Pista de audio seleccionada %1$s con MIME: %2$s</string>
    <string name="log_mediacodec_decoder_created">Decodificador MediaCodec creado para el tipo: %s</string>
    <string name="log_mediacodec_configured_started">MediaCodec configurado e iniciado.</string>
    <string name="log_duration_from_mediaformat_us">Duración desde MediaFormat (us): %s</string>
    <string name="log_final_effective_duration_us">Duración efectiva final (us): %s</string>
    <string name="log_samplerate_not_in_format_defaulting">Frecuencia de muestreo no en formato, usando 44100 por defecto</string>
    <string name="log_samplerate_info">Frecuencia de muestreo: %s</string>
    <string name="log_total_expected_samples_in_file">Total de muestras esperadas en el archivo (aprox): %s</string>
    <string name="log_pcm_samples_per_waveform_point">Muestras PCM a procesar por punto de forma de onda: %s</string>
    <string name="log_max_iterations_safety_break">Máximo de iteraciones (ruptura de seguridad): %s</string>
    <string name="log_main_loop_iteration_status">Iteración bucle principal: %1$s, amplitudes: %2$s, EOS_IN: %3$s, EOS_OUT: %4$s</string>
    <string name="log_eos_sent_to_decoder">EOS enviado al decodificador. SampleSize &lt; 0. Total de búferes de entrada desencolados: %s</string>
    <string name="log_getinputbuffer_returned_null">getInputBuffer devolvió nulo para el índice %s</string>
    <string name="log_codecexception_input_processing">CodecException durante procesamiento de entrada: %1$s, esTransitorio=%2$s, esRecuperable=%3$s</string>
    <string name="log_illegalstateexception_input_processing">IllegalStateException durante procesamiento de entrada (códec probablemente en estado incorrecto): %s</string>
    <string name="log_unexpected_exception_input_processing">Excepción inesperada durante procesamiento de entrada: %s</string>
    <string name="log_codecexception_dequeueoutputbuffer">CodecException durante dequeueOutputBuffer: %1$s, esTransitorio=%2$s, esRecuperable=%3$s</string>
    <string name="log_illegalstateexception_dequeueoutputbuffer">IllegalStateException durante dequeueOutputBuffer (códec probablemente en estado incorrecto): %s</string>
    <string name="log_unexpected_exception_dequeueoutputbuffer">Excepción inesperada durante dequeueOutputBuffer: %s</string>
    <string name="log_decoder_output_format_changed">Formato de salida del decodificador cambiado: %s</string>
    <string name="log_output_buffers_changed_deprecated">Búferes de salida cambiados (obsoleto).</string>
    <string name="log_eos_flag_received_output">Bandera EOS recibida en búfer de salida. Total de búferes de salida desencolados: %s</string>
    <string name="log_getoutputbuffer_returned_null">getOutputBuffer devolvió nulo para el índice %s</string>
    <string name="log_target_samples_waveform_reached">Muestras objetivo (%s) para forma de onda alcanzadas. Interrumpiendo.</string>
    <string name="log_dequeueoutputbuffer_unexpected_index">dequeueOutputBuffer devolvió un índice inesperado: %s</string>
    <string name="log_added_final_peak_amplitude">Amplitud de pico final añadida después del bucle: %1$s, total de amplitudes: %2$s</string>
    <string name="log_finished_extraction_loop_status">Bucle de extracción finalizado. Amplitudes recolectadas: %1$s. Total de muestras PCM procesadas: %2$s. Iteraciones: %3$s</string>
    <string name="log_filenotfoundexception_amplitude_extraction">FileNotFoundException durante extracción de amplitud para %1$s: %2$s</string>
    <string name="log_ioexception_amplitude_extraction">IOException durante extracción de amplitud para %1$s: %2$s</string>
    <string name="log_securityexception_amplitude_extraction">SecurityException durante extracción de amplitud para %1$s: %2$s</string>
    <string name="log_illegalstateexception_amplitude_extraction">IllegalStateException durante extracción de amplitud para %1$s: %2$s</string>
    <string name="log_critical_error_amplitude_extraction">!!! Error crítico durante extracción de amplitud para %1$s: %2$s</string>
    <string name="log_error_closing_parcel_file_descriptor">Error cerrando ParcelFileDescriptor</string>
    <string name="log_error_releasing_media_extractor">Error liberando MediaExtractor</string>
    <string name="log_error_stopping_releasing_media_codec">Error deteniendo/liberando MediaCodec</string>
    <string name="default_audio_filename">Audio_adjuntado</string>
    <string name="log_security_exception_get_filename">SecurityException al obtener nombre de archivo para %1$s: %2$s</string>
    <string name="audio_default_name">audio</string>
    <string name="log_error_get_filename">Error al obtener nombre de archivo para %1$s: %2$s</string>
    <string name="error_getting_filename">Error al obtener nombre de archivo: %s</string>
    <string name="log_security_exception_get_filesize">SecurityException al obtener tamaño de archivo para %1$s: %2$s</string>
    <string name="log_error_get_filesize">Error al obtener tamaño de archivo para %1$s: %2$s</string>
    <string name="error_getting_filesize">Error al obtener tamaño de archivo: %s</string>
    <string name="log_illegalargumentexception_get_duration">IllegalArgumentException al obtener duración del audio (URI inválido o no soportado): %s</string>
    <string name="log_runtimeexception_get_duration">RuntimeException al obtener duración del audio: %s</string>
    <string name="log_general_error_get_duration">Error general al obtener duración del audio con MediaMetadataRetriever: %s</string>
    <string name="log_error_releasing_media_metadata_retriever">Error liberando MediaMetadataRetriever</string>
    <string name="log_illegalstateexception_init_exoplayer">IllegalStateException al inicializar ExoPlayer: %s</string>
    <string name="error_playback_failed">Error al reproducir el audio.</string>
    <string name="error_suffix_invalid_state">(Estado inválido)</string>
    <string name="log_general_error_init_exoplayer">Error general al inicializar ExoPlayer: %s</string>
    <string name="error_suffix_unknown_error">(Error desconocido)</string>
    <string name="log_illegalstateexception_pause_exoplayer">IllegalStateException al pausar ExoPlayer: %s</string>
    <string name="log_attached_audio_deleted">Audio adjunto eliminado.</string>
    <string name="error_playback_failed_specific">Error al reproducir el audio: %s</string>
    <string name="log_exoplayer_error">Error de ExoPlayer: %1$s - %2$s</string>
    <string name="error_dialog_title">Error</string>
    <string name="log_error_releasing_exoplayer">Error liberando ExoPlayer</string>
    <string name="dialog_ok">Aceptar</string>
    <string name="log_illegalstateexception_waveform_seek">IllegalStateException durante búsqueda en forma de onda: %s</string>

    <!-- DialogCustomDatePicker.kt -->
    <string name="error_listener_not_implemented_datepicker">%s o el fragmento de destino deben implementar OnDateSelectedListener</string>
    <string name="dialog_title_select_exact_date">Seleccionar Fecha Exacta</string>
    <string name="month_jan_short">Ene</string>
    <string name="month_feb_short">Feb</string>
    <string name="month_mar_short">Mar</string>
    <string name="month_apr_short">Abr</string>
    <string name="month_may_short">May</string>
    <string name="month_jun_short">Jun</string>
    <string name="month_jul_short">Jul</string>
    <string name="month_aug_short">Ago</string>
    <string name="month_sep_short">Sep</string>
    <string name="month_oct_short">Oct</string>
    <string name="month_nov_short">Nov</string>
    <string name="month_dec_short">Dic</string>
    <string name="dialog_positive_button_accept">Aceptar</string>

    <!-- EditProfileActivity.kt -->
    <string name="image_selection_successful">Imagen seleccionada</string>
    <string name="image_selection_cancelled">Selección de imagen cancelada</string>
    <string name="firestore_collection_users">users</string>
    <string name="firestore_field_username">username</string>
    <string name="firestore_field_location">location</string>
    <string name="firestore_field_profileImageUrl">profileImageUrl</string>
    <string name="log_error_loading_user_data">Error al cargar datos del usuario</string>
    <string name="error_loading_data_generic">Error al cargar datos: %s</string>
    <string name="error_user_not_authenticated_profile">Usuario no autenticado</string>
    <string name="username_cannot_be_empty_on_first_set">Debes ingresar un nombre de usuario para establecerlo.</string>
    <string name="location_unknown_spinner_value">desconocido</string>
    <string name="username_permanent_dialog_title">Confirmar Nombre de Usuario</string>
    <string name="username_permanent_dialog_message">El nombre de usuario que elijas (\"%1$s\") será permanente y no podrás cambiarlo después. ¿Estás seguro/a/e?</string>
    <string name="accept">Aceptar</string>
    <string name="log_error_decode_bitmap_from_uri">No se pudo decodificar el bitmap desde URI: %s</string>
    <string name="log_error_compress_image_webp">Error comprimiendo imagen a WebP: %s</string>
    <string name="log_error_closing_streams_compress_webp">Error cerrando streams en compressImageToWebP</string>
    <string name="error_compressing_image_generic">Error al comprimir imagen.</string>
    <string name="cloudinary_option_folder">folder</string>
    <string name="cloudinary_folder_profile_pictures">profile_pictures/%s</string>
    <string name="cloudinary_option_public_id">public_id</string>
    <string name="cloudinary_public_id_profile_image">profile_image</string>
    <string name="cloudinary_option_overwrite">overwrite</string>
    <string name="cloudinary_option_resource_type">resource_type</string>
    <string name="cloudinary_resource_type_image">image</string>
    <string name="cloudinary_result_secure_url">secure_url</string>
    <string name="error_getting_cloudinary_url">Error al obtener URL de Cloudinary.</string>
    <string name="error_uploading_image_cloudinary">Error al subir imagen: %s</string>
    <string name="info_no_changes_to_save">No hay cambios para guardar.</string>
    <string name="success_profile_updated">Perfil actualizado.</string>
    <string name="error_saving_profile_firestore">Error al guardar: %s</string>
    <string name="username_setup_info">Debes establecer un nombre de usuario único. Este será permanente.</string>
    <string name="username_setup_must_complete_username">Debes guardar un nombre de usuario para continuar.</string>
    <string name="error_username_length">El nombre de usuario debe tener entre 3 y 20 caracteres.</string>
    <string name="error_username_invalid_chars">El nombre de usuario solo puede contener letras, números y guion bajo.</string>
    <string name="error_username_taken">Este nombre de usuario ya está en uso. Por favor, elige otro.</string>
    <string name="log_error_verifying_username_uniqueness">Error al verificar la unicidad del username</string>
    <string name="error_verifying_username">Error verificando username: %s</string>
    <string name="firestore_field_usernameNormalized">usernameNormalized</string>

    <!-- ImageViewerActivity.kt -->
    <string name="content_not_found">Contenido no encontrado.</string>
    <string name="status_pending_review_message">Este contenido está pendiente de revisión.</string>
    <string name="firestore_collection_images_pending">images_pending_approval</string>
    <string name="firestore_collection_images_approved">images</string>
    <string name="firestore_field_title">title</string>
    <string name="title_not_available">Sin título</string>
    <string name="firestore_field_imageUrl">imageUrl</string>
    <string name="error_image_url_not_found">URL de imagen no encontrada.</string>
    <string name="author_format">Author: %s</string>
    <string name="firestore_field_authorUsername">authorUsername</string>
    <string name="firestore_field_timestamp">timestamp</string>
    <string name="date_format_dd_mm_yyyy_hh_mm">dd/MM/yyyy HH:mm</string>
    <string name="date_format_viewer">Fecha: %s</string>
    <string name="firestore_field_description">description</string>
    <string name="location_unknown">Ubicación desconocida</string>
    <string name="type_unknown">Tipo desconocido</string>
    <string name="log_document_not_found">No existe el documento en %1$s con ID: %2$s</string>
    <string name="log_error_loading_image_data">Error al cargar datos de la imagen:</string>
    <string name="error_loading_content">Error al cargar el contenido.</string>

    <!-- MainActivity.kt -->
    <string name="app_name">México Paranormal</string>
    <string name="accessing_section">Accediendo a: %s</string>
    <string name="filtering_by">Filtrando por: %s</string>
    <string name="log_attempting_sign_in_credential_manager">Intentando iniciar sesión con Credential Manager.</string>
    <string name="default_web_client_id" translatable="false">463011268660-vhi439m4jrspflaopfod6inlte2m7jre.apps.googleusercontent.com</string>
    <string name="log_error_sign_in_credential_manager">Error en el inicio de sesión con Credential Manager: %s</string>
    <string name="log_sign_in_cancelled_by_user">Inicio de sesión cancelado por el usuario.</string>
    <string name="error_sign_in_cancelled">Inicio de sesión cancelado</string>
    <string name="error_sign_in_generic">Error en inicio de sesión: %s</string>
    <string name="log_googleidtokencredential_obtained">GoogleIdTokenCredential obtenida, procediendo con Firebase Auth.</string>
    <string name="log_customcredential_converted_to_google">CustomCredential convertida a GoogleIdTokenCredential.</string>
    <string name="log_error_parsing_customcredential">Error al parsear CustomCredential a GoogleIdTokenCredential.</string>
    <string name="error_procesar_credencial_google">Error al procesar la credencial de Google</string>
    <string name="log_unsupported_credential_type">Tipo de credencial no soportado: %s</string>
    <string name="tipo_credencial_no_soportado">Tipo de credencial no soportado</string>
    <string name="unknown_user">Usuario Desconocido</string>
    <string name="undefined_location">Ubicación No Definida</string>
    <string name="log_firebase_auth_successful">Autenticación con Firebase exitosa.</string>
    <string name="log_error_firebase_user_null_after_success">Firebase User es null después de autenticación exitosa.</string>
    <string name="error_internal_user_not_available">Error interno: Usuario no disponible.</string>
    <string name="log_error_firebase_auth">Error en autenticación con Firebase: %s</string>
    <string name="error_authentication_generic">Error en autenticación: %s</string>
    <string name="log_user_document_not_exists_creating">Documento para usuario %s no existe. Creando uno nuevo.</string>
    <string name="firestore_field_userId">userId</string>
    <string name="firestore_field_email">email</string>
    <string name="firestore_field_displayNameFromGoogle">displayNameFromGoogle</string>
    <string name="firestore_field_role">role</string>
    <string name="user_role_default">user</string>
    <string name="user_role_admin">admin</string>
    <string name="firestore_field_isBanned">isBanned</string>
    <string name="firestore_field_registrationDate">registrationDate</string>
    <string name="log_user_document_created_firestore">Documento de usuario creado en Firestore para UID: %s.</string>
    <string name="log_error_creating_user_document_firestore">Error al crear documento de usuario en Firestore para UID: %s</string>
    <string name="error_creating_user_profile">Error al crear perfil de usuario.</string>
    <string name="log_user_document_exists_firestore">Documento de usuario ya existe en Firestore para UID: %s</string>
    <string name="log_error_verifying_user_document_firestore">Error al verificar documento de usuario en Firestore para UID: %s</string>
    <string name="error_verifying_existing_profile">Error al verificar perfil existente.</string>
    <string name="admin_panel_button_text">Panel Admin</string>
    <string name="ir_al_perfil">Ir al Perfil</string>
    <string name="log_user_document_not_found_role_check">Documento de usuario no encontrado en Firestore para %s durante la verificación de rol.</string>
    <string name="log_error_getting_user_role">Error al obtener rol del usuario: %s</string>
    <string name="iniciar_sesion">Iniciar Sesión</string>
    <string name="error_search_term_empty">Por favor, ingresa un término de búsqueda.</string>
    <string name="intent_extra_search_query">SEARCH_QUERY</string>
    <string name="toast_complete_profile_setup">Por favor, completa la configuración de tu perfil para continuar.</string>
    <string name="button_complete_profile">Completar Perfil</string>
    <string name="success_username_set_can_continue_editing">¡Nombre de usuario guardado! Y puedes editar el resto.</string>

    <!-- MapsActivity.kt -->
    <string name="meta_data_google_geo_api_key">com.google.android.geo.API_KEY</string>
    <string name="log_error_maps_sdk_api_key_not_found">API Key para Maps SDK no encontrada en AndroidManifest.xml</string>
    <string name="log_error_getting_api_key_from_manifest">Error al obtener la API Key del manifest</string>
    <string name="intent_extra_selected_state">ESTADO_SELECCIONADO</string>
    <string name="log_oncreate_state_info">onCreate - Estado Original: \'%1$s\', Clave Normalizada: \'%2$s\'</string>
    <string name="intent_extra_latitude">LATITUD</string>
    <string name="intent_extra_longitude">LONGITUD</string>
    <string name="log_poi_clicked_ignoring">POI clickeado, ignorando: %s</string>
    <string name="log_onmaploadedcallback_map_fully_loaded">onMapLoadedCallback - Mapa completamente cargado.</string>
    <string name="log_onmaploadedcallback_state_has_bounds_animating">onMapLoadedCallback - Estado \'%1$s\' tiene bounds. Animando cámara al estado.</string>
    <string name="log_onmaploadedcallback_animation_to_state_bounds_finished">onMapLoadedCallback - Animación a bounds del estado finalizada.</string>
    <string name="log_onmaploadedcallback_editing_animating_to_existing_location">onMapLoadedCallback (después de zoom a estado) - Editando, animando a ubicación existente: %s</string>
    <string name="log_onmaploadedcallback_animation_to_state_bounds_cancelled">onMapLoadedCallback - Animación a bounds del estado cancelada.</string>
    <string name="log_onmaploadedcallback_editing_no_state_bounds_animating_directly">onMapLoadedCallback - Editando, sin bounds de estado, animando directamente a ubicación existente: %s</string>
    <string name="current_location">Ubicación actual</string>
    <string name="log_click_ignored_animation_in_progress">Clic ignorado, animación programática en curso.</string>
    <string name="log_map_clicked_at_state">Mapa clickeado en: %1$s. Estado actual (key): %2$s</string>
    <string name="log_point_inside_state_placing_marker">Punto DENTRO del estado. Colocando marcador.</string>
    <string name="selected_location">Ubicación seleccionada</string>
    <string name="log_point_outside_state_showing_toast">Punto FUERA del estado. Mostrando Toast.</string>
    <string name="default_state_name">el estado seleccionado</string>
    <string name="error_select_location_within_state">Por favor, selecciona una ubicación dentro de %1$s.</string>
    <string name="intent_extra_latitude_result">latitude</string>
    <string name="intent_extra_longitude_result">longitude</string>
    <string name="intent_extra_cityname_result">cityName</string>
    <string name="error_select_location_first">Selecciona una ubicación en el mapa primero</string>
    <string name="log_loadestadogeojson_search_key">loadEstadoGeoJson - Clave para búsqueda: \'%1$s\'</string>
    <string name="log_loadestadogeojson_no_state_selected">loadEstadoGeoJson - No hay estado seleccionado. No se carga GeoJSON.</string>
    <string name="log_loadestadogeojson_no_geojson_id_found">loadEstadoGeoJson - No se encontró ID de archivo GeoJSON para la clave: \'%1$s\'. Nombre original: \'%2$s\'</string>
    <string name="error_geojson_not_found_for_state">No se pudo cargar el mapa para %1$s.</string>
    <string name="log_loadestadogeojson_using_file_id">loadEstadoGeoJson - Usando archivo ID: %1$s para \'%2$s\'</string>
    <string name="log_loadestadogeojson_layer_added">loadEstadoGeoJson - Capa GeoJSON añadida para \'%1$s\'</string>
    <string name="log_loadestadogeojson_bounds_calculated">loadEstadoGeoJson - Bounds calculados para \'%1$s\': %2$s</string>
    <string name="log_loadestadogeojson_could_not_build_bounds">loadEstadoGeoJson - No se pudieron construir los bounds para \'%1$s\'</string>
    <string name="log_loadestadogeojson_no_geometries_for_bounds">loadEstadoGeoJson - GeoJSON para \'%1$s\' no contiene geometrías para bounds.</string>
    <string name="log_loadestadogeojson_error_loading_parsing">loadEstadoGeoJson - Error al cargar/parsear GeoJSON para \'%1$s\'</string>
    <string name="error_loading_state_boundary">Error al mostrar el límite para %1$s.</string>
    <string name="log_ispointinselectedstate_checking_point">isPointInSelectedState - Verificando punto %1$s para estado clave \'%2$s\'</string>
    <string name="log_ispointinselectedstate_no_state_selected_allowing_click">isPointInSelectedState - No hay estado seleccionado, se permite el clic (vista general de México).</string>
    <string name="log_ispointinselectedstate_geojsonlayer_null">isPointInSelectedState - GeoJsonLayer es nulo para el estado \'%1$s\'. El punto se considera fuera.</string>
    <string name="log_ispointinselectedstate_point_inside_geojsonpolygon">isPointInSelectedState - Punto DENTRO de GeoJsonPolygon para \'%1$s\'.</string>
    <string name="log_ispointinselectedstate_point_inside_multipolygon">isPointInSelectedState - Punto DENTRO de un polígono en GeoJsonMultiPolygon para \'%1$s\'.</string>
    <string name="log_ispointinselectedstate_point_outside_all_polygons">isPointInSelectedState - El punto %1$s está FUERA de todos los polígonos del GeoJSON para \'%2$s\'.</string>
    <string name="log_geocoder_not_present">Geocoder no está presente en este dispositivo.</string>
    <string name="geocoding_no_service_available">Servicio de geocodificación no disponible en este dispositivo.</string>
    <string name="log_geocoder_full_address">Geocoder Dirección Completa: %s</string>
    <string name="log_geocoder_constructed_name">Geocoder nombre construido: \'%s\'</string>
    <string name="log_geocoder_no_address_found">Geocoder: No se encontró dirección para las coordenadas.</string>
    <string name="no_address_found_for_coordinates">No se encontró una dirección para estas coordenadas.</string>
    <string name="log_geocoder_service_error">Error de servicio con Geocoder</string>
    <string name="geocoding_service_error">No se pudo obtener el nombre del lugar. Intenta de nuevo.</string>
    <string name="log_geocoder_invalid_argument">Argumento inválido para Geocoder (lat/lng)</string>
    <string name="geocoding_invalid_coordinates">Coordenadas inválidas para geocodificación.</string>

    <!-- MexicoParanormalApplication.kt -->
    <string name="log_info_firebase_app_initialized">Firebase App inicializado.</string>
    <string name="log_info_firebase_app_check_initialized">Firebase App Check con Play Integrity inicializado.</string>
    <string name="log_info_cloudinary_initialized_successfully">Cloudinary inicializado exitosamente en Application.</string>
    <string name="log_error_cloudinary_initialization">Error inicializando Cloudinary en Application.</string>

    <!-- PendingUploadsActivity.kt -->
    <string name="intent_extra_story_id">STORY_ID</string>
    <string name="intent_extra_is_pending_review">IS_PENDING_REVIEW</string>
    <string name="intent_extra_image_id">IMAGE_ID</string>
    <string name="intent_extra_video_id">VIDEO_ID</string>
    <string name="no_pending_uploads_message">Por ahora no tienes envíos pendientes.</string>
    <string name="firestore_collection_stories_pending">stories_pending_approval</string>
    <string name="firestore_collection_videos_pending">videos_pending_approval</string>
    <string name="firestore_field_complementaryImageUrl">complementaryImageUrl</string>
    <string name="section_header_pending_stories">Relatos Pendientes</string>
    <string name="section_header_pending_images">Imágenes Pendientes</string>
    <string name="section_header_pending_videos">Videos Pendientes</string>
    <string name="log_error_loading_pending_uploads">Error al cargar envíos pendientes</string>
    <string name="error_loading_pending_uploads_with_message">Error al cargar envíos pendientes: %s</string>
    <string name="error_loading_pending_uploads">Error al cargar envíos pendientes.</string>
    <string name="error_user_not_authenticated">Debes iniciar sesión para subir contenido</string>

    <!-- PendingUploadsAdapter.kt -->
    <string name="error_item_at_position_null">El ítem en la posición %d es nulo</string>
    <string name="error_invalid_view_type">Tipo de vista inválido: %d</string>
    <string name="submission_date_format">Enviado: %s</string>

    <!-- RecordAudioFragment.kt -->
    <string name="error_mic_permission_denied_permanently">Permiso de micrófono denegado permanentemente. Habilítalo desde la configuración de la app.</string>
    <string name="error_write_permission_denied_for_saving">Permiso de escritura denegado. No se puede guardar el audio.</string>
    <string name="error_listener_not_implemented_audiorecord">%s debe implementar AudioRecordListener</string>
    <string name="log_error_load_onnx_context_null">loadOnnxModel: Contexto u OrtEnvironment es nulo al intentar cargar el modelo: %s</string>
    <string name="log_info_onnx_model_copied_to_cache">loadOnnxModel: Modelo %1$s copiado a caché: %2$s</string>
    <string name="log_info_onnx_model_exists_in_cache">loadOnnxModel: Modelo %1$s ya existe en caché: %2$s</string>
    <string name="log_error_onnx_ioexception">loadOnnxModel: IOException cargando modelo ONNX \'%s\'. Verifica que el asset exista y la caché sea escribible.</string>
    <string name="log_error_onnx_ortexception">loadOnnxModel: OrtException cargando modelo ONNX \'%s\'. El modelo podría estar corrupto o ser incompatible.</string>
    <string name="log_error_onnx_unexpected">loadOnnxModel: Error inesperado cargando modelo ONNX \'%s\'</string>
    <string name="log_info_onnx_models_loaded_successfully">initializeOnnxRuntime: Todos los modelos ONNX cargados exitosamente.</string>
    <string name="log_error_onnx_failed_to_load_models">initializeOnnxRuntime: Falló la carga de uno o más modelos ONNX.</string>
    <string name="error_critical_ai_initialization">Error crítico en inicialización de IA.</string>
    <string name="log_error_onnx_ortexception_init">initializeOnnxRuntime: OrtException inicializando ONNX Runtime o cargando modelos.</string>
    <string name="error_critical_ai_initialization_ort">Error crítico en inicialización de IA (ORT)</string>
    <string name="log_error_onnx_critical_init">initializeOnnxRuntime: Error crítico inicializando ONNX Runtime.</string>
    <string name="log_onnx_resources_closed_successfully">onDestroyView: Recursos ONNX cerrados exitosamente.</string>
    <string name="log_onnx_resources_error_closing">onDestroyView: Error cerrando recursos ONNX.</string>
    <string name="info_recording_stopped_due_to_app_state">Grabación detenida porque la app pasó a segundo plano o se cerró.</string>
    <string name="permission_dialog_title">Permiso Necesario</string>
    <string name="action_open_settings">Abrir Configuración</string>
    <string name="audio_source_mic">Micrófono Clásico (Voz natural)</string>
    <string name="audio_source_mic_ai">Micrófono Optimizado por IA (Elimina ruido)</string>
    <string name="log_audio_source_selected">setupAudioSourceSpinner: Fuente de audio seleccionada: %s</string>
    <string name="info_ai_feature_experimental">Esta función de IA es experimental y puede requerir más recursos del dispositivo.</string>
    <string name="info_ai_processing_audio">Procesando audio con IA, por favor espera…</string>
    <string name="permission_dialog_mic_rationale">Se necesita acceso al micrófono para grabar audio. Por favor, concede el permiso.</string>
    <string name="permission_dialog_grant">Conceder</string>
    <string name="default_filename_unknown_m4a">desconocido.m4a</string>
    <string name="info_no_recording_to_save">No hay ninguna grabación para guardar.</string>
    <string name="log_error_check_storage_illegal_arg">hasSufficientStorage: Error verificando almacenamiento (IllegalArgumentException).</string>
    <string name="log_error_check_storage_unexpected">hasSufficientStorage: Error inesperado verificando almacenamiento.</string>
    <string name="error_insufficient_storage_title">Espacio Insuficiente</string>
    <string name="error_insufficient_storage_message">No hay suficiente espacio de almacenamiento para iniciar una nueva grabación. Por favor, libera algo de espacio e inténtalo de nuevo.</string>
    <string name="dialog_confirm_new_recording_title">Nueva Grabación</string>
    <string name="dialog_confirm_new_recording_message">Ya existe una grabación. ¿Deseas iniciar una nueva? La grabación anterior se eliminará.</string>
    <string name="dialog_yes">Sí</string>
    <string name="dialog_no">No</string>
    <string name="file_name_prefix">grabacion_</string>
    <string name="file_name_date_format">yyyy-MM-dd_HH-mm-ss</string>
    <string name="file_extension_m4a">.m4a</string>
    <string name="error_cache_dir_unavailable">Directorio de caché no disponible. No se puede grabar.</string>
    <string name="log_mediarecorder_configured_at_samplerate">actuallyStartRecording: MediaRecorder configurado para grabar a %d Hz</string>
    <string name="log_mediarecorder_failed_to_set_samplerate_fallback">actuallyStartRecording: Falló al establecer MediaRecorder a %d Hz, usando 44100 Hz como fallback.</string>
    <string name="error_media_recorder_unknown">Error desconocido del grabador de audio.</string>
    <string name="error_media_server_died">El servicio de multimedia del sistema falló. Intenta reiniciar el dispositivo.</string>
    <string name="error_start_recording_with_code">Error al iniciar grabación (Código: %1$d, Extra: %2$d)</string>
    <string name="info_max_duration_reached">Límite de grabación de %d minutos alcanzado.</string>
    <string name="recording_status_recording">Grabando</string>
    <string name="error_media_recorder_prepare_io">Error al preparar la grabación (E/S): %s</string>
    <string name="error_media_recorder_start_state">Error al iniciar la grabación (Estado): %s</string>
    <string name="error_start_recording_generic">Error desconocido al iniciar grabación: %s</string>
    <string name="recording_paused_status">Grabación Pausada</string>
    <string name="error_pause_not_supported">La pausa no es compatible con esta versión de Android.</string>
    <string name="error_pause_recording_specific">Error al pausar grabación: %s</string>
    <string name="error_resume_recording_specific">Error al reanudar grabación: %s</string>
    <string name="error_stop_recording_failed_critical">Error crítico al detener. La grabación podría no haberse guardado.</string>
    <string name="log_finalize_recording_details">finalizeRecording: URI: %1$s, Nombre: %2$s, Duración: %3$s</string>
    <string name="status_finished">Grabación Finalizada</string>
    <string name="log_finalize_recording_fragment_not_attached">finalizeRecording: Fragmento no adjunto. No se puede actualizar UI o notificar al listener.</string>
    <string name="log_process_audio_with_ai_aborted">processAudioWithAI: Procesamiento IA abortado. Fragmento no adjunto o sesión(es) ONNX no listas.</string>
    <string name="error_critical_ai_initialization_sessions">Error crítico en inicialización de IA (Sesiones)</string>
    <string name="log_process_audio_with_ai_starting">processAudioWithAI: Iniciando procesamiento IA para: %s</string>
    <string name="info_ai_audio_processed">Audio procesado con IA.</string>
    <string name="error_ai_processing_failed">Falló el procesamiento de audio con IA.</string>
    <string name="log_decode_m4a_to_pcm_coroutine_inactive">decodeM4aToPcm: Corrutina inactiva o fragmento no listo para entrada %s.</string>
    <string name="log_decode_m4a_to_pcm_starting">decodeM4aToPcm: Iniciando decodificación M4A a PCM: %1$s -> %2$s</string>
    <string name="log_decode_m4a_to_pcm_no_audio_track">decodeM4aToPcm: No se encontró pista de audio en %s</string>
    <string name="log_decode_m4a_to_pcm_input_format">decodeM4aToPcm: Formato M4A de entrada: SR=%1$s Hz, Canales=%2$s para %3$s</string>
    <string name="log_decode_m4a_to_pcm_decoder_output_format_changed">decodeM4aToPcm: Formato de salida del decodificador cambiado para %1$s: SR=%2$s Hz, Canales=%3$s</string>
    <string name="log_decode_m4a_to_pcm_completed">decodeM4aToPcm: Decodificación PCM completada para %1$s a %2$s</string>
    <string name="log_decode_m4a_to_pcm_ioexception">decodeM4aToPcm: IOException para %s.</string>
    <string name="log_decode_m4a_to_pcm_illegalstate">decodeM4aToPcm: IllegalStateException para %s.</string>
    <string name="log_decode_m4a_to_pcm_illegalargument">decodeM4aToPcm: IllegalArgumentException para %s.</string>
    <string name="log_decode_m4a_to_pcm_securityexception">decodeM4aToPcm: SecurityException (MediaDrm?) para %s.</string>
    <string name="log_decode_m4a_to_pcm_unexpected_error">decodeM4aToPcm: Error inesperado para %s.</string>
    <string name="log_decode_m4a_to_pcm_error_releasing_codec">decodeM4aToPcm: Error deteniendo/liberando MediaCodec para %s</string>
    <string name="log_decode_m4a_to_pcm_error_releasing_extractor">decodeM4aToPcm: Error liberando MediaExtractor para %s</string>
    <string name="log_resampler_attempting_resample">Resampler: Intentando remuestrear: %1$sHz/%2$sch -> %3$sHz/%4$sch</string>
    <string name="log_resampler_mono_only">Resampler: Este resampleador simple solo soporta MONO a MONO. Canales de entrada: %1$s, Canales objetivo: %2$s</string>
    <string name="log_resampler_rates_identical">Resampler: Las frecuencias de muestreo son idénticas (%s Hz). No se necesita remuestreo.</string>
    <string name="log_resampler_complete">Resampler: Remuestreo completo. Muestras de entrada: %1$s, Muestras de salida: %2$s</string>
    <string name="log_stereo_to_mono_invalid_size">Resampler: Tamaño de datos PCM estéreo inválido (debe ser múltiplo de 4 bytes). Tamaño: %s</string>
    <string name="log_stereo_to_mono_complete">Resampler: Conversión Estéreo a Mono completa. Muestras mono: %s</string>
    <string name="log_run_ai_enhancement_starting">runAiEnhancement: Iniciando mejora IA para: %s</string>
    <string name="log_run_ai_enhancement_failed_decode_or_cancelled">runAiEnhancement: Falló la decodificación de M4A a PCM o corrutina cancelada para %s.</string>
    <string name="log_run_ai_enhancement_pcm_decoded">runAiEnhancement: PCM decodificado para %1$s: %2$s, SR: %3$s, Canales: %4$s</string>
    <string name="log_run_ai_enhancement_error_reading_decoded_pcm">runAiEnhancement: Error leyendo bytes del archivo PCM decodificado %s o corrutina cancelada.</string>
    <string name="log_run_ai_enhancement_converting_to_mono">runAiEnhancement: Convirtiendo %1$s a mono desde %2$s canales.</string>
    <string name="log_run_ai_enhancement_failed_to_convert_to_mono">runAiEnhancement: Falló la conversión de %s a mono o corrutina cancelada.</string>
    <string name="log_run_ai_enhancement_converted_to_mono">runAiEnhancement: Audio %s convertido a mono.</string>
    <string name="log_run_ai_enhancement_resampling">runAiEnhancement: Remuestreando %1$s de %2$sHz a %3$sHz.</string>
    <string name="log_run_ai_enhancement_failed_to_resample">runAiEnhancement: Falló el remuestreo de %1$s a %2$sHz o corrutina cancelada.</string>
    <string name="log_run_ai_enhancement_resampled">runAiEnhancement: Audio %1$s remuestreado a %2$sHz mono.</string>
    <string name="log_run_ai_enhancement_pcm_data_null_after_conversion">runAiEnhancement: Datos PCM para procesamiento %s son nulos después de conversión/remuestreo o corrutina cancelada.</string>
    <string name="log_run_ai_enhancement_final_pcm_ready_for_onnx">runAiEnhancement: PCM final para %1$s (%2$sHz, %3$sch) listo para entrada ONNX: %4$s</string>
    <string name="log_run_ai_enhancement_onnx_sessions_not_init">runAiEnhancement: Sesión(es) ONNX o entorno no inicializado para %s. Omitiendo inferencia.</string>
    <string name="log_run_ai_enhancement_num_frames_zero_or_negative">runAiEnhancement: Número de tramas S es cero o negativo (%1$s) para %2$s. No se puede proceder con inferencia.</string>
    <string name="log_run_ai_enhancement_num_pcm_samples_frames">runAiEnhancement: Número de muestras PCM para %1$s: %2$s, Número de tramas (S): %3$s</string>
    <string name="log_run_ai_enhancement_output_not_found_in_onnx">runAiEnhancement: Salida \'%1$s\' no encontrada en resultados ONNX para %2$s (archivo: %3$s).</string>
    <string name="log_run_ai_enhancement_output_not_onnx_tensor">runAiEnhancement: Salida \'%1$s\' no es un OnnxTensor para %2$s. Tipo real: %3$s</string>
    <string name="log_run_ai_enhancement_running_enc_onnx">runAiEnhancement: Ejecutando enc.onnx para %s…</string>
    <string name="log_run_ai_enhancement_enc_onnx_executed">runAiEnhancement: enc.onnx ejecutado para %1$s. Formas: emb=%2$s</string>
    <string name="log_run_ai_enhancement_running_df_dec_onnx">runAiEnhancement: Ejecutando df_dec.onnx para %s…</string>
    <string name="log_run_ai_enhancement_df_dec_onnx_executed">runAiEnhancement: df_dec.onnx ejecutado para %1$s. Forma df_out_signal_tensor (\'302\'): %2$s</string>
    <string name="log_run_ai_enhancement_running_erb_dec_onnx">runAiEnhancement: Ejecutando erb_dec.onnx para %s…</string>
    <string name="log_run_ai_enhancement_erb_dec_onnx_executed">runAiEnhancement: erb_dec.onnx ejecutado para %1$s. Forma erb_out_mask_tensor (\'m\'): %2$s</string>
    <string name="log_run_ai_enhancement_simulating_ai_output">runAiEnhancement: Simulando salida IA para %s: Copiando PCM preprocesado a salida.</string>
    <string name="log_run_ai_enhancement_starting_re_encoding">runAiEnhancement: Iniciando re-codificación de PCM a M4A/AAC para %1$s desde: %2$s</string>
    <string name="log_run_ai_enhancement_re_encoding_complete">runAiEnhancement: Re-codificación a M4A/AAC completada para %1$s: %2$s</string>
    <string name="log_run_ai_enhancement_failed_re_encoding">runAiEnhancement: Falló re-codificación PCM a M4A/AAC para %s.</string>
    <string name="log_run_ai_enhancement_ortexception">runAiEnhancement: OrtException durante inferencia ONNX para %s.</string>
    <string name="log_run_ai_enhancement_ioexception">runAiEnhancement: IOException durante operaciones de archivo para %s.</string>
    <string name="log_run_ai_enhancement_critical_unexpected_error">runAiEnhancement: Error crítico inesperado para %s.</string>
    <string name="log_encode_pcm_to_aac_preconditions_not_met">encodePcmToAacM4a: Precondiciones no cumplidas para entrada %1$s. Archivo existe: %2$s, Longitud: %3$s</string>
    <string name="log_encode_pcm_to_aac_starting">encodePcmToAacM4a: Iniciando codificación PCM a AAC M4A: %1$s -> %2$s</string>
    <string name="log_encode_pcm_to_aac_eos_sent">encodePcmToAacM4a: EOS enviado al codificador AAC para %1$s. Total de bytes PCM leídos: %2$s</string>
    <string name="log_encode_pcm_to_aac_format_changed_after_muxer">encodePcmToAacM4a: Formato cambiado después de iniciar muxer para %s. Esto no debería ocurrir.</string>
    <string name="exception_format_changed_after_muxer_started">Formato cambiado después de iniciar el muxer</string>
    <string name="log_encode_pcm_to_aac_muxer_started">encodePcmToAacM4a: Muxer iniciado para %1$s. Pista de audio añadida con formato: %2$s</string>
    <string name="log_encode_pcm_to_aac_output_buffers_changed">encodePcmToAacM4a: Búferes de salida del codificador cambiados (obsoleto) para %s.</string>
    <string name="log_encode_pcm_to_aac_dequeue_unexpected_code">encodePcmToAacM4a: dequeueOutputBuffer devolvió código inesperado: %1$s para %2$s</string>
    <string name="log_encode_pcm_to_aac_output_before_format_changed">encodePcmToAacM4a: Paquete de salida recibido ANTES de MediaCodec.INFO_OUTPUT_FORMAT_CHANGED para %s. Liberando búfer y reintentando.</string>
    <string name="log_encode_pcm_to_aac_muxer_track_index_invalid">encodePcmToAacM4a: Índice de pista del muxer es inválido (-1) para %s, no se pueden escribir datos de muestra.</string>
    <string name="log_encode_pcm_to_aac_eos_received_from_encoder">encodePcmToAacM4a: EOS recibido de la salida del codificador AAC para %s.</string>
    <string name="log_encode_pcm_to_aac_loop_finished">encodePcmToAacM4a: Bucle de codificación AAC finalizado para %s.</string>
    <string name="log_encode_pcm_to_aac_cancelled_coroutine">encodePcmToAacM4a: Codificación AAC cancelada por corrutina para %s.</string>
    <string name="log_encode_pcm_to_aac_cancelled_output_processing">encodePcmToAacM4a: Codificación AAC (procesamiento de salida) cancelada para %s.</string>
    <string name="log_encode_pcm_to_aac_no_more_input_try_again">encodePcmToAacM4a: No hay más entrada para %s y el codificador necesita más tiempo. Asumiendo que la codificación finalizó o se atascó.</string>
    <string name="log_encode_pcm_to_aac_ioexception">encodePcmToAacM4a: IOException para %s.</string>
    <string name="log_encode_pcm_to_aac_illegalstate">encodePcmToAacM4a: IllegalStateException para %s.</string>
    <string name="log_encode_pcm_to_aac_illegalargument">encodePcmToAacM4a: IllegalArgumentException para %s.</string>
    <string name="log_encode_pcm_to_aac_codecexception">encodePcmToAacM4a: MediaCodec.CodecException para %s.</string>
    <string name="log_encode_pcm_to_aac_unexpected_error">encodePcmToAacM4a: Error inesperado para %s.</string>
    <string name="log_encode_pcm_to_aac_error_releasing_codec">encodePcmToAacM4a: Error deteniendo/liberando MediaCodec para %s</string>
    <string name="log_encode_pcm_to_aac_error_releasing_muxer">encodePcmToAacM4a: Error deteniendo/liberando muxer para %s</string>
    <string name="log_release_mediarecorder_error">releaseMediaRecorder: Error liberando MediaRecorder.</string>
    <string name="log_release_exoplayer_error">releasePlayer: Error liberando ExoPlayer.</string>
    <string name="timer_format_recording_multiline_ms">Grabado: %1$02d:%2$02d.%3$02d\nRestante: %4$02d:%5$02d.%6$02d</string>
    <string name="timer_format_total_duration_ms">Duración: %1$02d:%2$02d.%3$03d</string>
    <string name="timer_format_total_duration">Duración: %1$02d:%2$02d</string>
    <string name="timer_format_elapsed_remaining_ds">Grabado: %1$02d:%2$02d.%3$01d  Restante: %4$02d:%5$02d.%6$01d</string>
    <string name="timer_format_idle">Listo: %1$02d:%2$02d</string>
    <string name="status_ready_to_record">Listo para Grabar</string>
    <string name="button_start_recording">INICIAR GRABACIÓN</string>
    <string name="button_stop_recording">DETENER GRABACIÓN</string>
    <string name="button_pause_recording">PAUSAR GRABACIÓN</string>
    <string name="button_resume_recording">REANUDAR GRABACIÓN</string>
    <string name="status_paused">Grabación Pausada</string>
    <string name="player_audio_file_name_format">Archivo: %s</string>
    <string name="log_error_amplitude_updater_illegalstate">initializeAmplitudeUpdater: IllegalStateException en getMaxAmplitude, deteniendo actualizador.</string>
    <string name="error_saving_audio_no_context">No se pudo guardar el audio. Intente de nuevo.</string>
    <string name="app_recordings_folder_name">GrabacionesMexicoParanormal</string>
    <string name="error_saving_audio_failed_mediastore">No se pudo crear el archivo de audio en la carpeta de Música.</string>
    <string name="error_saving_audio_copy_failed_streams_null">Error al guardar el audio: Flujo de entrada/salida es nulo</string>
    <string name="error_saving_audio_copy_failed">Error al guardar el audio: %s</string>
    <string name="info_audio_saved_locally">Audio Guardado Localmente</string>
    <string name="success_audio_saved_to_music_path_dialog">Audio guardado en:\n%1$s</string>
    <string name="error_creating_directory_failed">No se pudo crear el directorio de grabaciones: %s</string>
    <string name="error_saving_audio_copy_failed_input_null">Error al guardar el audio: InputStream nulo desde sourceFileUri</string>
    <string name="timer_format_final_elapsed_only">Grabación: %1$02d:%2$02d</string>
    <string name="timer_format_ms">%1$02d:%2$02d.%3$01d</string>
    <string name="timer_format_ss">%1$02d:%2$02d</string>
    <string name="player_play_button_desc">Reproducir audio grabado</string>
    <string name="player_pause_button_desc">Pausar audio grabado</string>
    <string name="player_delete_button_desc">Eliminar audio grabado</string>
    <string name="player_speed_button_desc">Cambiar velocidad de reproducción</string>
    <string name="error_start_recording">Error al iniciar la grabación.</string>
    <string name="error_stop_recording">Error al detener la grabación.</string>
    <string name="error_pause_recording">Error al pausar la grabación.</string>
    <string name="error_resume_recording">Error al reanudar la grabación.</string>
    <string name="info_audio_saved">Grabación guardada: %s</string>
    <string name="info_no_recording_to_play">No hay grabación para reproducir.</string>
    <string name="info_no_recording_to_delete">No hay grabación para eliminar.</string>
    <string name="cd_stop_recording_button">Botón para detener grabación</string>
    <string name="cd_resume_recording_button">Botón para reanudar grabación</string>
    <string name="cd_seek_bar_audio_playback">Barra de progreso de reproducción</string>
    <string name="file_extension_opus">.opus</string>
    <string name="waveform_placeholder_text">Visualizador de Ondas (Estático)</string>
    <string name="recorded_audio_player_title">Reproductor de Audio Grabado</string>
    <string name="cd_icon_mic">Icono de micrófono</string>
    <string name="warning_recording_paused">Grabación en pausa.</string>
    <string name="timer_label_elapsed">Grabado</string>
    <string name="timer_label_remaining">Restante</string>
    <string name="timer_separator"> </string>
    <string name="error_recording_failed_io">No se pudo guardar la grabación debido a un error de archivo.</string>
    <string name="error_recording_failed_state">Falló el inicio de la grabación debido a un error interno del grabador.</string>
    <string name="status_recording">Grabando</string>
    <string name="status_saving">Guardando grabación</string>
    <string name="error_recording_failed_unknown">Ocurrió un error desconocido durante la grabación.</string>
    <string name="timer_format_total_duration_ds">Duración: %1$02d:%2$02d.%3$01d</string>
    <string name="player_timer_format_current_total_ds">%1$02d:%2$02d.%3$01d / %4$02d:%5$02d.%6$01d</string>
    <string name="player_timer_default_ds">00:00.0 / 00:00.0</string>
    <string name="timer_format_recording_elapsed_ms">Grabado: %1$02d:%2$02d.%3$03d</string>
    <string name="timer_format_recording_remaining_ms">Restante: %1$02d:%2$02d.%3$03d</string>
    <string name="player_timer_format_current_total_ss">%1$02d:%2$02d / %3$02d:%4$02d</string>
    <string name="error_filename_missing_for_save">Error: Falta el nombre del archivo para guardar.</string>
    <string name="success_audio_saved_to_music">Audio \"%1$s\" guardado en la carpeta Música/GrabacionesMexicoParanormal.</string>
    <string name="info_ai_feature_experimental_reverted">"Modo IA (Preprocesamiento): Esta opción ahora solo aplica preprocesamiento (mono, 48kHz) a tu grabación. La supresión de ruido completa se reactivará pronto."</string>
    <string name="info_ai_preprocessing_audio_reverted">"Preprocesando audio (mono, 48kHz)"</string>
    <string name="info_ai_audio_preprocessed_reverted">"Audio preprocesado (mono, 48kHz) listo."</string>

    <string name="error_ai_preprocessing_failed_reverted">"Falló el preprocesamiento del audio. Se usará la grabación original."</string>
    <string name="audio_type_classic">Grabado con Micrófono Clásico</string>
    <string name="audio_source_voice_recognition">Micrófono (Optimizado para Voz)</string>
    <string name="audio_type_ia_preprocessed">Grabación IA (Preprocesada)</string>
    <string name="audio_type_ia_processed">Grabación IA (Procesada)</string>
    <string name="label_recordings_list">Mis Grabaciones (Máx. 4):</string>
    <string name="error_max_recordings_reached_title">Límite de Grabaciones Alcanzado</string>
    <string name="error_max_recordings_reached_message">Has alcanzado el límite de 4 grabaciones. Por favor, elimina alguna para poder grabar una nueva.</string>
    <string name="warning_only_one_audio_submission">Recuerda: Solo podrás adjuntar UNA de estas grabaciones a tu relato final.</string>
    <string name="delete_selected_audios_button_desc">Eliminar audios seleccionados</string>
    <string name="cd_select_for_deletion">Seleccionar para eliminar</string>
    <string name="cd_play_this_audio">Reproducir este audio</string>
    <string name="ai_progress_starting">Iniciando procesamiento IA</string>
    <string name="ai_progress_decoding_m4a">Decodificando audio grabado</string>
    <string name="ai_progress_encoding_m4a">Finalizando y guardando audio</string>
    <string name="ai_progress_preprocessing_pcm">Preparando audio (48kHz, mono)</string>
    <string name="ai_progress_error_preprocessing">Error en preparación de audio.</string>
    <string name="ai_progress_feature_extraction_format">Analizando la pista con IA: %d%%</string>
    <string name="ai_progress_error_feature_extraction">Error </string>
    <string name="ai_progress_feature_extraction_complete">Extracción de características completa.</string>
    <string name="ai_progress_error_decoding">Error en decodificación.</string>
    <string name="ai_progress_error_encoding_m4a">Error al guardar el audio final.</string>
    <string name="ai_processing_cancelled_generic">Procesamiento cancelado.</string>
    <string name="ai_processing_error_context_unavailable">Contexto no disponible para procesamiento IA.</string>
    <string name="ai_processing_error_decode_m4a_to_pcm_failed">Fallo en decodificación M4A a PCM para IA.</string>
    <string name="ai_processing_error_reading_decoded_pcm_failed">Error leyendo archivo PCM decodificado para IA.</string>
    <string name="ai_processing_error_stereo_to_mono_failed">Error convirtiendo audio a mono para IA.</string>
    <string name="ai_processing_error_resampling_failed">Error en remuestreo de audio para IA.</string>
    <string name="ai_processing_error_unknown_pcm_preprocessing_failed">Error desconocido en preprocesamiento PCM para IA. </string>
    <string name="ai_processing_error_empty_preprocessed_pcm_file">Archivo PCM preprocesado para IA está vacío.</string>
    <string name="ai_processing_error_reencode_to_m4a_failed">Fallo en recodificación a M4A después de IA.</string>
    <string name="ai_processing_error_out_of_memory_generic">Error de memoria durante el procesamiento IA.</string>
    <string name="ai_processing_error_critical_prefix">Error crítico IA: </string>
    <string name="save_selected_audios_summary_saved_format">%d archivo(s) guardado(s).</string>
    <string name="save_selected_audios_summary_skipped_format">%d archivo(s) ya existía(n) y se omitieron.</string>
    <string name="save_selected_audios_summary_error_format">%d archivo(s) no pudieron guardarse.</string>
    <string name="save_selected_audios_summary_none_processed">No se procesó ningún archivo para guardar.</string>
    <string name="info_recordings_deleted_count_format">%d grabación(es) eliminada(s).</string>
    <string name="error_restoring_playable_recording_item">Error al reanudar</string>
    <string name="ai_progress_decoding_m4a_format">Decodificando audio grabado: %d%%</string>
    <string name="ai_progress_encoding_m4a_format">Finalizando y guardando audio: %d%%</string>
    <string name="notification_channel_name">Servicio de Grabación de Audio</string>
    <string name="notification_title_recording">Grabando Audio</string>
    <string name="notification_title_processing">Procesando Audio</string>
    <string name="notification_title_error">Error en Servicio</string>
    <string name="notification_action_stop">Detener</string>
    <string name="notification_action_pause">Pausar</string>
    <string name="notification_action_resume">Reanudar</string>
    <string name="error_service_insufficient_data_start">Datos insuficientes para iniciar grabación desde el servicio.</string>
    <string name="error_service_insufficient_data_process">Datos insuficientes para procesar audio desde el servicio.</string>
    <string name="error_service_input_file_not_exist">Archivo de entrada para procesamiento no existe.</string>
    <string name="error_media_recorder_generic">Error de MediaRecorder (what: %1$d, extra: %2$d)</string>
    <string name="error_stop_recording_file_corrupt">Error al detener grabación, el archivo podría estar corrupto.</string>
    <string name="error_service_file_not_found">Archivo de grabación no encontrado por el servicio.</string>
    <string name="error_service_file_empty">Archivo de grabación vacío o no existe según el servicio.</string>
    <string name="error_service_ai_processing_failed">Falló el procesamiento IA del audio en el servicio.</string>
    <string name="error_service_ai_processing_detailed">Error en procesamiento IA: %s</string>
    <string name="error_service_decode_failed">Fallo en decodificación M4A a PCM.</string>
    <string name="error_service_mono_conversion_failed">Fallo en conversión a mono.</string>
    <string name="error_service_resample_failed">Fallo en remuestreo de audio.</string>
    <string name="error_service_encoding_failed">Fallo en codificación a M4A.</string>
    <string name="error_service_ai_critical">Error crítico en procesamiento IA: %s</string>
    <string name="error_service_unknown">Error desconocido del servicio.</string>
    <string name="ai_progress_stage_decoding">Decodificando</string>
    <string name="ai_progress_stage_preprocessing">Preprocesando</string>
    <string name="ai_progress_stage_feature_extraction">Extrayendo Características</string>
    <string name="ai_progress_stage_encoding">Codificando</string>
    <string name="ai_progress_processing_default">Procesando</string>
    <string name="permission_dialog_notification_rationale">Se necesita permiso de notificaciones para mostrar el estado de la grabación y procesamiento en segundo plano.</string>
    <string name="warning_notification_permission_denied">Permiso de notificación denegado. La grabación podría no funcionar correctamente en segundo plano o no mostrar su estado.</string>
    <string name="error_notification_permission_denied_permanently_prompt">El permiso de notificaciones fue denegado permanentemente.</string>
    <string name="error_service_file_not_received">Error: Archivo de grabación no recibido del servicio.</string>
    <string name="error_service_processed_file_not_received">Error: Archivo procesado no recibido del servicio.</string>
    <string name="error_mic_permission_denied">Permiso de micrófono denegado.</string>
    <string name="error_mic_unavailable">Micrófono no disponible.</string>
    <string name="error_mic_permission_denied_permanently_prompt">El permiso de micrófono fue denegado permanentemente. Para grabar audio, necesitas habilitarlo manualmente desde la configuración de la aplicación.</string>
    <string name="info_using_original_due_to_processing_error">Procesamiento IA falló. Usando grabación original.</string>

    <!-- UserProfileActivity.kt -->
    <string name="profile">Perfil de Usuario</string>

    <!-- VideoViewerActivity.kt -->
    <string name="intent_extra_story_id_key">STORY_ID</string>
    <string name="intent_extra_is_pending_review_key">IS_PENDING_REVIEW</string>
    <string name="firestore_collection_stories_approved">stories</string>
    <string name="firestore_field_text">text</string>
    <string name="firestore_field_storyType">storyType</string>
    <string name="log_document_not_found_in_collection">Documento no encontrado en %1$s con ID: %2$s</string>
    <string name="log_error_loading_story_with_id">Error al cargar relato con ID: %1$s</string>
    <string name="content_not_available">Contenido no disponible.</string>
    <string name="info_youtube_link_found_placeholder">Enlace de YouTube encontrado: %s (Implementar reproductor)</string>

    <!-- SearchResultsActivity.kt -->
    <string name="intent_extra_search_query_key">SEARCH_QUERY</string>
    <string name="filter_by_message">Filtrar por: %s</string>
    <string name="pagination_previous_page">Página anterior</string>
    <string name="pagination_next_page">Página siguiente</string>
    <string name="sample_story_title">Encuentro en Oaxaca</string>
    <string name="search_results_title">Resultados </string>
    <string name="showing_results">Mostrando %d resultados:</string>
    <string name="result_story">Relato: \"%s\" (Experiencias)</string>
    <string name="result_photo">Foto: \"%s\"</string>
    <string name="result_video">Video: \"%s\"</string>
    <string name="location_format">Ubicación: %1$s |</string>
    <string name="result_item_title">%1$d. %2$s</string>
    <string name="results_list_dynamic_description">Lista con %d resultados de búsqueda</string>
    <string name="result_item_description">Elemento %1$d: %2$s</string>
    <string name="result_details_description">Ubicación: %1$s, Fecha: %2$s</string>

    <!-- SettingsFragment.kt -->
    <string name="username_not_set">Nombre de usuario no establecido</string>
    <string name="location_not_set">Ubicación no establecida</string>
    <string name="log_profile_data_loaded">Datos de perfil cargados para UID: %s</string>
    <string name="log_user_document_not_found_settings">Documento de usuario no encontrado en Firestore para UID: %s</string>
    <string name="log_error_loading_profile_data_settings">Error al cargar datos de perfil para UID: %s</string>
    <string name="error_loading_profile_data_message">Error al cargar datos del perfil: %s</string>
    <string name="log_user_not_authenticated_settings">Usuario no autenticado en SettingsFragment.</string>
    <string name="user_not_authenticated_message">Usuario no autenticado</string>
    <string name="error_loading_name">Error al cargar nombre</string>
    <string name="error_loading_location">Error al cargar ubicación</string>
    <string name="not_authenticated">No Autenticado</string>
    <string name="dialog_delete_account_title">Eliminar Cuenta Permanentemente</string>
    <string name="dialog_delete_account_message">¿Estás seguro de que quieres eliminar tu cuenta? Esta acción es PERMANENTE y NO SE PUEDE DESHACER.\n\nSe borrarán tus datos de perfil. La eliminación de tus relatos, imágenes y videos de nuestros servidores puede tardar un poco más en completarse.\n\nEs posible que se te pida volver a iniciar sesión por seguridad para confirmar esta acción.</string>
    <string name="action_delete_account_confirm">Eliminar Cuenta</string>
    <string name="error_user_not_authenticated_for_action">Debes estar autenticado para realizar esta acción.</string>
    <string name="success_account_deleted">Tu cuenta ha sido eliminada exitosamente.</string>
    <string name="error_deleting_auth_user">Error al eliminar tu cuenta: %s. \n\nSi el problema persiste, cierra sesión, vuelve a iniciarla e inténtalo de nuevo, o contacta a soporte.</string>
    <string name="error_deleting_user_data_firestore">Error al eliminar los datos de tu perfil: %s.</string>
    <string name="warning_profile_picture_deletion_failed">No se pudo eliminar la foto de perfil de Cloudinary, pero se continuará con la eliminación de la cuenta.</string>
    <string name="info_deleting_account_progress">Eliminando cuenta, por favor espera</string>

    <!-- UploadImageActivity.kt -->
    <string name="log_image_selected">Imagen seleccionada: %s</string>
    <string name="log_security_exception_processing_image">SecurityException al procesar la imagen seleccionada desde URI \'%s\'</string>
    <string name="selected_image_default_name">imagen seleccionada</string>
    <string name="log_illegal_argument_processing_image">IllegalArgumentException al procesar la imagen seleccionada (URI \'%s\' malformado?)</string>
    <string name="log_unexpected_error_processing_image">Error inesperado al procesar la imagen seleccionada desde URI \'%s\'</string>
    <string name="log_image_selection_cancelled">Selección de imagen cancelada.</string>
    <string name="log_user_not_authenticated_oncreate">onCreate: Usuario no autenticado. Finalizando actividad.</string>
    <string name="log_coordinates_received">mapsActivityResultLauncher: Coordenadas recibidas - Lat: %1$s, Lon: %2$s, Ciudad: %3$s</string>
    <string name="log_map_selection_cancelled">mapsActivityResultLauncher: Selección de mapa cancelada o sin resultado.</string>
    <string name="log_state_restored_upload_image">onCreate: Estado restaurado - ImageURI: %1$s, Lat: %2$s</string>
    <string name="log_error_cloudinary_not_configured">checkCloudinaryInitialization: Cloudinary no está configurado en MediaManager.</string>
    <string name="log_error_cloudinary_not_initialized">checkCloudinaryInitialization: Cloudinary (MediaManager) no inicializado.</string>
    <string name="log_error_cloudinary_unknown_check">checkCloudinaryInitialization: Error desconocido verificando Cloudinary.</string>
    <string name="log_upload_cancellation_sent">setupUploadCancelButton: Solicitud de cancelación de subida enviada para ID: %s</string>
    <string name="log_error_cancelling_upload">setupUploadCancelButton: Error al cancelar la solicitud de subida ID: %s</string>
    <string name="log_error_parsing_date_datepicker">showCustomDatePickerImageFragment: No se pudo parsear la fecha \'%s\' del editTextExactDate. Usando fecha actual.</string>
    <string name="log_all_fields_cleared">clearAllFields: Todos los campos limpiados.</string>
    <string name="log_security_exception_get_filesize_uri">getFileSize: SecurityException obteniendo tamaño del archivo para URI \'%s\'</string>
    <string name="default_file_name">archivo</string>
    <string name="log_illegal_argument_get_filesize_uri">getFileSize: IllegalArgumentException obteniendo tamaño del archivo para URI \'%s\' (URI malformado?)</string>
    <string name="log_error_get_filesize_uri">getFileSize: Error obteniendo tamaño del archivo para URI \'%s\'</string>
    <string name="log_submission_already_in_progress">processImageSubmission: Ya se está procesando un envío.</string>
    <string name="log_form_not_valid">processImageSubmission: Formulario no válido.</string>
    <string name="log_error_user_not_authenticated_submission">processImageSubmission: Usuario no autenticado.</string>
    <string name="firestore_field_authorProfileImageUrl">authorProfileImageUrl</string>
    <string name="firestore_field_type">type</string>
    <string name="content_type_image">image</string>
    <string name="firestore_field_date">date</string>
    <string name="firestore_field_status">status</string>
    <string name="status_pending_value">pending</string>
    <string name="firestore_field_isVisible">isVisible</string>
    <string name="firestore_field_likes">likes</string>
    <string name="firestore_field_commentsCount">commentsCount</string>
    <string name="firestore_field_latitude">latitude</string>
    <string name="firestore_field_longitude">longitude</string>
    <string name="firestore_field_cityName">cityName</string>
    <string name="firestore_field_moderatedBy">moderatedBy</string>
    <string name="firestore_field_moderationTimestamp">moderationTimestamp</string>
    <string name="firestore_field_rejectionReason">rejectionReason</string>
    <string name="log_starting_cloudinary_upload">processImageSubmission: Iniciando subida de imagen a Cloudinary para URI: %s</string>
    <string name="log_error_imageuri_null_after_validation">processImageSubmission: imageUri es nulo después de la validación del formulario.</string>
    <string name="log_error_getting_user_data_for_authorship">processImageSubmission: Error al obtener datos del usuario para autoría.</string>
    <string name="error_suffix_user_data_fetch">(Obtención de datos de usuario)</string>
    <string name="firestore_field_date_type">type</string>
    <string name="date_type_value_unknown">unknown</string>
    <string name="firestore_field_date_value">value</string>
    <string name="date_type_value_year">year</string>
    <string name="date_type_value_exact">exact</string>
    <string name="date_type_value_range">range</string>
    <string name="firestore_field_date_startYear">startYear</string>
    <string name="firestore_field_date_endYear">endYear</string>
    <string name="date_type_value_none">none</string>
    <string name="log_error_compressing_image_uri">uploadImageToCloudinaryAndSaveData: Falló la compresión de la imagen URI: %s</string>
    <string name="cloudinary_folder_image_uploads">image_uploads/%s</string>
    <string name="cloudinary_public_id_image_prefix">image_</string>
    <string name="log_cloudinary_upload_started">uploadImageToCloudinaryAndSaveData - onStart: Subida a Cloudinary iniciada, requestId: %s</string>
    <string name="log_cloudinary_upload_success">uploadImageToCloudinaryAndSaveData - onSuccess: Imagen subida a Cloudinary, URL: %s</string>
    <string name="log_error_cloudinary_url_null">uploadImageToCloudinaryAndSaveData - onSuccess: URL de Cloudinary es nula.</string>
    <string name="error_suffix_cloudinary_url_null">(URL de imagen nula de Cloudinary)</string>
    <string name="log_error_cloudinary_upload">uploadImageToCloudinaryAndSaveData - onError: Error subiendo imagen a Cloudinary. RequestId: %1$s, Error: %2$s, Code: %3$s</string>
    <string name="log_cloudinary_upload_rescheduled">uploadImageToCloudinaryAndSaveData - onReschedule: Subida de imagen re-programada. RequestId: %1$s, Error: %2$s, Code: %3$s</string>
    <string name="error_suffix_upload_rescheduled">(Re-programado: %s)</string>
    <string name="log_firestore_image_data_saved">saveImageDataToFirestore: Datos de imagen guardados en Firestore con ID: %s</string>
    <string name="log_error_firestore_saving_image_data">saveImageDataToFirestore: Error al guardar datos de la imagen en Firestore.</string>
    <string name="error_suffix_firestore_save">(Firestore: %s)</string>
    <string name="log_handling_upload_error">handleUploadError: %s</string>
    <string name="log_activity_finishing_dialog_not_shown">showSubmissionConfirmationDialog: La actividad está finalizando o destruida, no se mostrará el diálogo.</string>
    <string name="error_inputstream_null_for_uri">InputStream es nulo para URI: %s</string>
    <string name="error_failed_decode_bitmap_from_uri">Fallo al decodificar bitmap desde URI: %s</string>
    <string name="error_exif_inputstream_null_for_uri">Exif InputStream es nulo para URI: %s</string>
    <string name="log_error_file_not_found_compress_webp">compressImageToWebP: Archivo no encontrado para URI \'%s\'</string>
    <string name="log_error_io_compress_webp">compressImageToWebP: Error de E/S comprimiendo imagen desde URI \'%s\'</string>
    <string name="log_error_unexpected_compress_webp">compressImageToWebP: Error inesperado comprimiendo imagen desde URI \'%s\'</string>
    <string name="log_error_closing_streams_compress_webp_uri">compressImageToWebP: Error cerrando streams para URI \'%s\'</string>
    <string name="log_activity_finishing_dialog_not_shown_alert">showAlertDialog: La actividad está finalizando o destruida, no se mostrará el diálogo.</string>
    <string name="error_select_image">Por favor, selecciona una imagen para subir</string>
    <string name="error_image_title_required">El título de la imagen es obligatorio</string>
    <string name="error_image_description_required">La descripción de la imagen es obligatoria</string>
    <string name="error_select_exact_date">Por favor, selecciona la fecha exacta</string>
    <string name="error_year_range_order">El año de fin no puede ser menor </string>
    <string name="desc_info_date_format_title">Formatos de Fecha</string>
    <string name="desc_info_date_format_message">Puedes ingresar solo el año (YYYY), la fecha exacta (DD/MM/YYYY) o un rango de años (YYYY–YYYY).</string>
    <string name="submission_success_title_upload">Imagen Enviada a Revisión</string>
    <string name="submission_success_message_upload">Su imagen entra en fase de revisión.</string>
    <string name="submission_generic_error_message_upload">Ocurrió un error al intentar enviar la imagen.</string>
    <string name="error_location_required">Seleccione una ubicación</string>
    <string name="error_description_length">Descripción demasiado larga. Máx. %d caracteres.</string>
    <string name="uploading_image_progress_percent">Subiendo imagen: %d%%</string>
    <string name="error_invalid_date_format">Formato de fecha incorrecto (dd/mm/yyyy)</string>
    <string name="error_invalid_date_range">La fecha debe estar entre %1$s y %2$s</string>
    <string name="error_correct_date_errors">Por favor, corrige los errores en la fecha</string>
    <string name="error_select_date_type_or_unknown">Selecciona un tipo de fecha o marca \'Desconocido\'</string>
    <string name="error_story_title_required">El título del relato es obligatorio</string>
    <string name="error_story_text_required">El texto del relato es obligatorio</string>
    <string name="error_story_type_required">Por favor, selecciona un tipo de relato</string>
    <string name="error_other_story_type_required">Debes especificar el tipo de relato</string>
    <string name="error_invalid_file_type_specific">Formato de archivo no permitido. Permite: %s</string>
    <string name="save_story_error_message">Error al guardar relato: %s</string>
    <string name="error_title_length">El título es demasiado largo. Máximo 37 caracteres.</string>
    <string name="error_image_compression_failed">Error al comprimir la imagen</string>
    <string name="upload_cancelled">Subida cancelada</string>
    <string name="error_unknown_upload">Error desconocido en la subida</string>
    <string name="error_reading_video_file">Error al cargar el video</string>
    <string name="video_selection_cancelled">Selección de video cancelada</string>
    <string name="video_selected">Vídeo seleccionado</string>
    <string name="error_video_too_large">Vídeo supera 10MB.</string>
    <string name="error_invalid_video_type">Solo se permiten archivos de video</string>
    <string name="uploading_video_progress_percent">Subiendo video: %d%%</string>
    <string name="video_upload_success">¡Vídeo enviado a revisión!</string>
    <string name="video_upload_message">Su video entra en fase de revisión.</string>
    <string name="selected_coordinates_format">Coordenadas seleccionadas:\nLat: %1$.6f\nLon: %2$.6f</string>
    <string name="error_select_state_first">Seleccione una ubicación primero</string>
    <string name="uploading_content_progress">Subiendo contenido</string>
    <string name="dialog_positive_button_understood">Entendido</string>
    <string name="dialog_title_image_date">Fecha de la Imagen</string>
    <string name="error_select_image_internal">Error interno: No hay imagen disponible después de validación.</string>
    <string name="error_select_coordinates_on_map">Por favor, selecciona las coordenadas en el mapa si el interruptor está activado.</string>
    <string name="dialog_title_video_date">Fecha del Video</string>
    <string name="error_loading_video_preview">Error al cargar la vista previa del video.</string>
    <string name="error_no_video_source">Debes adjuntar un video o ingresar un enlace de YouTube.</string>
    <string name="error_video_title_required">El título del video es obligatorio.</string>
    <string name="error_video_description_required">La descripción del video es obligatoria.</string>
    <string name="error_video_or_youtube_link_required">Adjunte un video o ingrese un enlace de YouTube.</string>
    <string name="error_field_required">Requerido</string>
    <string name="error_video_and_youtube_link_provided">Solo puede adjuntar un video O ingresar un enlace de YouTube, no ambos.</string>
    <string name="error_invalid_youtube_link">El enlace de YouTube no es válido.</string>
    <string name="error_file_size_too_large">El archivo es demasiado grande. Máximo %1$dMB.</string>
    <string name="error_file_not_found_for_compression">Error: Archivo no encontrado para compresión: %1$s</string>
    <string name="error_io_compressing_image">Error: Problema de E/S al comprimir la imagen.</string>
    <string name="error_unknown_compressing_image">Error: Ocurrió un error desconocido al comprimir la imagen.</string>

    <!-- UploadStoryActivity.kt -->
    <string name="log_optional_image_selected">Imagen opcional seleccionada: %s</string>
    <string name="log_invalid_file_type_optional_image">Tipo de archivo no válido para imagen opcional. URI: %1$s, Tipo: %2$s</string>
    <string name="log_security_exception_validating_optional_image">SecurityException al validar imagen opcional desde URI \'%s\'</string>
    <string name="log_illegal_argument_validating_optional_image">IllegalArgumentException al validar imagen opcional (URI \'%s\' malformado?)</string>
    <string name="log_unexpected_error_validating_optional_image">Error inesperado al validar imagen opcional desde URI \'%s\'</string>
    <string name="log_optional_image_selection_cancelled">Selección de imagen opcional cancelada.</string>
    <string name="log_user_not_authenticated_oncreate_story">onCreate: Usuario no autenticado. Finalizando actividad UploadStory.</string>
    <string name="log_coordinates_received_story">mapsActivityResultLauncher: Coordenadas recibidas - Lat: %1$s, Lon: %2$s, Ciudad: %3$s</string>
    <string name="log_map_selection_cancelled_story">mapsActivityResultLauncher: Selección de mapa cancelada o sin resultado.</string>
    <string name="log_state_restored_upload_story">onCreate: Estado restaurado - ImageURI: %1$s, RecordedAudioURI: %2$s, AttachedAudioURI: %3$s, Lat: %4$s</string>
    <string name="log_error_cloudinary_not_configured_story">checkCloudinaryInitialization: Cloudinary no está configurado en MediaManager (UploadStory).</string>
    <string name="log_error_cloudinary_not_initialized_story">checkCloudinaryInitialization: Cloudinary (MediaManager) no inicializado (UploadStory).</string>
    <string name="log_error_cloudinary_unknown_check_story">checkCloudinaryInitialization: Error desconocido verificando Cloudinary (UploadStory).</string>
    <string name="log_story_image_upload_cancellation_sent">setupUploadCancelButton: Solicitud de cancelación de imagen de relato enviada para ID: %s</string>
    <string name="log_error_cancelling_story_image_upload">setupUploadCancelButton: Error cancelando subida de imagen de relato ID: %s</string>
    <string name="log_story_audio_upload_cancellation_sent">setupUploadCancelButton: Solicitud de cancelación de audio de relato enviada para ID: %s</string>
    <string name="log_error_cancelling_story_audio_upload">setupUploadCancelButton: Error cancelando subida de audio de relato ID: %s</string>
    <string name="log_general_upload_cancellation_sent">setupUploadCancelButton: Solicitud de cancelación de subida general enviada.</string>
    <string name="log_error_parsing_date_datepicker_story">showCustomDatePickerStoryFragment: No se pudo parsear la fecha \'%s\' del editTextExactDate. Usando fecha actual.</string>
    <string name="log_all_fields_cleared_story">clearAllFields: Todos los campos limpiados en UploadStory.</string>
    <string name="log_security_exception_get_filesize_uri_story">getFileSize: SecurityException obteniendo tamaño del archivo para URI \'%s\' (UploadStory)</string>
    <string name="log_illegal_argument_get_filesize_uri_story">getFileSize: IllegalArgumentException obteniendo tamaño del archivo para URI \'%s\' (URI malformado?) (UploadStory)</string>
    <string name="log_error_get_filesize_uri_story">getFileSize: Error obteniendo tamaño del archivo para URI \'%s\' (UploadStory)</string>
    <string name="log_submission_already_in_progress_story">processStorySubmission: Ya se está procesando un envío de relato.</string>
    <string name="log_form_not_valid_story">processStorySubmission: Formulario no válido para relato.</string>
    <string name="log_error_user_not_authenticated_submission_story">proceedWithSubmission: Usuario no autenticado al intentar enviar relato.</string>
    <string name="content_type_story">story</string>
    <string name="firestore_field_audioUrl">audioUrl</string>
    <string name="firestore_field_audioOriginalName">audioOriginalName</string>
    <string name="log_starting_cloudinary_audio_upload">proceedWithSubmission: Iniciando subida de audio a Cloudinary para URI: %s</string>
    <string name="log_audio_uploaded_starting_optional_image_upload">proceedWithSubmission: Audio subido, iniciando subida de imagen opcional para URI: %s</string>
    <string name="log_audio_uploaded_no_optional_image">proceedWithSubmission: Audio subido, no hay imagen opcional. Guardando datos del relato.</string>
    <string name="log_no_audio_starting_optional_image_upload">proceedWithSubmission: No hay audio, iniciando subida de imagen opcional para URI: %s</string>
    <string name="log_no_audio_no_optional_image">proceedWithSubmission: No hay audio ni imagen opcional. Guardando datos del relato.</string>
    <string name="log_error_getting_user_data_for_authorship_story">proceedWithSubmission: Error al obtener datos del usuario para autoría del relato.</string>
    <string name="log_error_getting_bytes_from_audio_uri">uploadAudioToCloudinary: Falló la obtención de bytes del audio URI: %s</string>
    <string name="cloudinary_default_audio_filename_prefix">story_audio_</string>
    <string name="cloudinary_folder_story_audios">story_audios/%s</string>
    <string name="cloudinary_resource_type_video">video</string>
    <string name="log_cloudinary_audio_upload_started">uploadAudioToCloudinary - onStart: Subida de audio a Cloudinary iniciada, requestId: %s</string>
    <string name="log_cloudinary_audio_upload_success">uploadAudioToCloudinary - onSuccess: Audio subido a Cloudinary, URL: %s</string>
    <string name="log_error_cloudinary_audio_upload">uploadAudioToCloudinary - onError: Error subiendo audio a Cloudinary. RequestId: %1$s, Error: %2$s, Code: %3$s</string>
    <string name="error_suffix_audio_upload">(audio)</string>
    <string name="log_cloudinary_audio_upload_rescheduled">uploadAudioToCloudinary - onReschedule: Subida de audio re-programada. RequestId: %1$s, Error: %2$s, Code: %3$s</string>
    <string name="log_error_compressing_optional_image_uri">uploadOptionalImageToCloudinary: Falló la compresión de la imagen opcional URI: %s</string>
    <string name="cloudinary_folder_story_images">story_images/%s</string>
    <string name="cloudinary_public_id_story_image_prefix">story_image_</string>
    <string name="log_cloudinary_optional_image_upload_started">uploadOptionalImageToCloudinary - onStart: Subida de imagen opcional a Cloudinary iniciada, requestId: %s</string>
    <string name="log_cloudinary_optional_image_upload_success">uploadOptionalImageToCloudinary - onSuccess: Imagen opcional subida, URL: %s</string>
    <string name="log_error_cloudinary_optional_image_upload">uploadOptionalImageToCloudinary - onError: Error subiendo imagen opcional. RequestId: %1$s, Error: %2$s, Code: %3$s</string>
    <string name="error_suffix_story_image_upload">(imagen de relato)</string>
    <string name="log_cloudinary_optional_image_upload_rescheduled">uploadOptionalImageToCloudinary - onReschedule: Subida de imagen opcional re-programada. RequestId: %1$s, Error: %2$s, Code: %3$s</string>
    <string name="log_firestore_story_data_saved">saveStoryDataToFirestore: Datos del relato guardados en Firestore con ID: %s</string>
    <string name="log_error_firestore_saving_story_data">saveStoryDataToFirestore: Error al guardar datos del relato en Firestore.</string>
    <string name="error_suffix_firestore_save_story">(Firestore - relato)</string>
    <string name="log_handling_upload_error_story">handleUploadError (Story): %s</string>
    <string name="log_activity_finishing_dialog_not_shown_story">showSubmissionConfirmationDialog (Story): La actividad está finalizando o destruida, no se mostrará el diálogo.</string>
    <string name="error_inputstream_null_for_uri_compress">InputStream es nulo para URI: %s (compressImageToWebP)</string>
    <string name="error_failed_decode_bitmap_from_uri_compress">Fallo al decodificar bitmap desde URI: %s (compressImageToWebP)</string>
    <string name="error_exif_inputstream_null_for_uri_compress">Exif InputStream es nulo para URI: %s (compressImageToWebP)</string>
    <string name="log_error_file_not_found_compress_webp_story">compressImageToWebP: Archivo no encontrado para URI \'%s\' (UploadStory)</string>
    <string name="log_error_io_compress_webp_story">compressImageToWebP: Error de E/S comprimiendo imagen desde URI \'%s\' (UploadStory)</string>
    <string name="log_error_unexpected_compress_webp_story">compressImageToWebP: Error inesperado comprimiendo imagen desde URI \'%s\' (UploadStory)</string>
    <string name="log_error_closing_streams_compress_webp_uri_story">compressImageToWebP: Error cerrando streams para URI \'%s\' (UploadStory)</string>
    <string name="log_error_file_not_found_get_bytes">getBytesFromUri: Archivo no encontrado para URI \'%s\'</string>
    <string name="log_error_io_get_bytes">getBytesFromUri: Error al leer bytes del URI \'%s\'</string>
    <string name="log_security_exception_get_bytes">getBytesFromUri: SecurityException al leer bytes del URI \'%s\'</string>
    <string name="log_unexpected_error_get_bytes">getBytesFromUri: Error inesperado al leer bytes del URI \'%s\'</string>
    <string name="log_audio_recorded_received">onAudioRecorded: Audio grabado recibido - URI: %1$s, Nombre: %2$s</string>
    <string name="log_attached_audio_reset_due_to_new_recording">onAudioRecorded: Audio adjunto reseteado debido a nueva grabación.</string>
    <string name="log_recording_state_changed">onRecordingStateChanged: Estado de grabación cambiado a: %s</string>
    <string name="log_attached_audio_reset_recording_started">onRecordingStateChanged: Audio adjunto reseteado porque la grabación ha comenzado.</string>
    <string name="log_recorded_audio_deleted_from_fragment">onAudioDeleted: Audio grabado eliminado desde fragmento.</string>
    <string name="log_audio_attached_received">onAudioAttached: Audio adjuntado recibido - URI: %1$s, Nombre: %2$s</string>
    <string name="log_recorded_audio_reset_due_to_new_attachment">onAudioAttached: Audio grabado reseteado debido a nuevo adjunto.</string>
    <string name="log_attached_audio_deleted_from_fragment">onAttachedAudioDeleted: Audio adjuntado eliminado desde fragmento.</string>
    <string name="log_audio_warning_visibility_updated">updateAudioWarningVisibility: Visibilidad de advertencia de audio actualizada. Grabando: %1$s, URI Grabado: %2$s, URI Adjunto: %3$s</string>
    <string name="log_error_fragment_type_mismatch">getFragmentAtIndex: Fragmento en el índice %1$s encontrado, pero no es del tipo %2$s. Tipo real: %3$s</string>
    <string name="log_warning_fragment_not_found_by_tag">getFragmentAtIndex: Fragmento en el índice %1$s no encontrado por tag \'%2$s\'.</string>
    <string name="log_activity_finishing_dialog_not_shown_story_alert">showAlertDialog (Story): La actividad está finalizando o destruida, no se mostrará el diálogo.</string>
    <string name="error_story_text_or_audio_required">Debes escribir un relato, grabar un audio o adjuntar un archivo de audio.</string>
    <string name="error_story_text_too_long">El texto del relato excede el límite de %d caracteres.</string>
    <string name="warning_recorded_audio_active">Audio grabado activo.</string>
    <string name="warning_attached_audio_active">Audio adjunto activo.</string>
    <string name="warning_recording_in_progress">Grabación en curso.</string>
    <string name="info_audio_only_one_allowed">Solo puedes grabar o adjuntar un audio por relato.</string>
    <string name="info_max_record_duration_reached">Límite de grabación de %d minutos alcanzado.</string>
    <string name="info_audio_preparing">Preparando audio</string>
    <string name="error_audio_selection">Error al seleccionar el audio.</string>
    <string name="info_no_audio_provided">No se ha grabado ni adjuntado audio.</string>
    <string name="error_audio_compression">Error al procesar el audio.</string>
    <string name="error_audio_invalid_type">Tipo de archivo de audio no válido.</string>
    <string name="error_audio_file_too_large">El archivo de audio es demasiado grande (Máx. %dMB).</string>
    <string name="info_audio_conversion_to_opus">Tu audio se convertirá a formato Opus para optimizarlo.</string>
    <string name="uploading_audio_progress">Subiendo audio: %d%%</string>
    <string name="error_audio_conversion_failed">Error al convertir el audio a formato Opus.</string>
    <string name="error_upload_audio_generic">Error subiendo audio: %s</string>
    <string name="error_upload_audio_rescheduled">Subida de audio re-programada.</string>
    <string name="error_upload_image_generic_story">Error subiendo imagen del relato: %s</string>
    <string name="error_upload_image_rescheduled_story">Subida de imagen del relato re-programada.</string>
    <string name="dialog_confirm_upload_title">Confirmar Envío</string>
    <string name="dialog_confirm_upload_story_with_audio_message">Tu relato y el audio se enviarán a revisión.</string>
    <string name="dialog_confirm_upload_story_text_only_message">Tu relato (solo texto) se enviará a revisión.</string>
    <string name="label_story_audio_player">Audio del Relato:</string>
    <string name="submission_success_title_story">¡Relato Enviado!</string>
    <string name="submission_success_message_story">Tu relato ha sido enviado para revisión.</string>
    <string name="deleted_audio_message">Audio eliminado</string>
    <string name="timer_format_elapsed_remaining">Grabado: %1$02d:%2$02d  Restante: %3$02d:%4$02d</string>
    <string name="error_cant_start_recording_io">No se pudo iniciar la grabación (Error de E/S).</string>
    <string name="error_cant_start_recording_state">No se pudo iniciar la grabación (Error de estado).</string>
    <string name="error_cant_save_recording">No se pudo guardar la grabación.</string>
    <string name="error_pausing_recording">Error al pausar la grabación.</string>
    <string name="error_resuming_recording">Error al reanudar la grabación.</string>
    <string name="error_stopping_recording">Error al detener la grabación.</string>
    <string name="error_recording_failed">Error durante la grabación.</string>
    <string name="submission_success_story_audio_image">Tu relato, audio e imagen se enviarán a revisión.</string>
    <string name="submission_success_story_image">Tu relato e imagen se enviarán a revisión.</string>
    <string name="submission_success_story_audio_image_sent">¡Relato, audio e imagen enviados!</string>
    <string name="submission_success_story_audio_sent">¡Relato y audio enviados!</string>
    <string name="submission_success_story_image_sent">¡Relato e imagen enviados!</string>
    <string name="status_unknown">Estado desconocido</string>
    <string name="dialog_title_story_date">Fecha del Relato</string>
    <string name="cloudinary_config_error">Error de configuración del servicio de subida.</string>
    <string name="cloudinary_init_error">Error de configuración: Servicio de subida no inicializado.</string>
    <string name="cloudinary_check_error">Error de configuración del servicio de subida.</string>
    <string name="upload_error_prefix">Error: %s</string>
    <string name="error_invalid_year_generic">Rango de años inválido.</string>
    <string name="error_invalid_year_range_formatted">El rango de años especificado es inválido. Debe ser entre %1$d y %2$d.</string>
    <string name="error_invalid_year_range_simple">Año inválido. Debe estar entre %1$d y %2$d.</string>

    <!-- UploadVideoActivity.kt -->
    <string name="log_video_selected">Video seleccionado - URI: %1$s, Nombre: %2$s</string>
    <string name="log_invalid_file_type_for_video">Tipo de archivo no válido para video. URI: %1$s, Tipo: %2$s</string>
    <string name="log_security_exception_validating_video">SecurityException al validar el video desde URI \'%s\'</string>
    <string name="selected_video_default_name">video seleccionado</string>
    <string name="log_illegal_argument_validating_video">IllegalArgumentException al validar el video (URI \'%s\' malformado?)</string>
    <string name="log_unexpected_error_validating_video">Error inesperado al validar el video desde URI \'%s\'</string>
    <string name="log_video_selection_cancelled">Selección de video cancelada.</string>
    <string name="log_complementary_image_selected">Imagen complementaria seleccionada - URI: %s</string>
    <string name="log_invalid_file_type_complementary_image">Tipo de archivo no válido para imagen complementaria. URI: %1$s, Tipo: %2$s</string>
    <string name="log_security_exception_validating_complementary_image">SecurityException al validar la imagen complementaria desde URI \'%s\'</string>
    <string name="log_illegal_argument_validating_complementary_image">IllegalArgumentException al validar la imagen complementaria (URI \'%s\' malformado?)</string>
    <string name="log_unexpected_error_validating_complementary_image">Error inesperado al validar la imagen complementaria desde URI \'%s\'</string>
    <string name="log_complementary_image_selection_cancelled">Selección de imagen complementaria cancelada.</string>
    <string name="log_security_exception_get_filename_video">getFileName: SecurityException obteniendo nombre de archivo para URI \'%s\' (Video)</string>
    <string name="log_illegal_argument_get_filename_video">getFileName: IllegalArgumentException obteniendo nombre de archivo para URI \'%s\' (Video)</string>
    <string name="log_error_get_filename_video">getFileName: Error obteniendo nombre de archivo para URI \'%s\' (Video)</string>
    <string name="log_security_exception_get_filesize_video">getFileSize: SecurityException obteniendo tamaño del archivo para URI \'%s\' (Video)</string>
    <string name="log_illegal_argument_get_filesize_video">getFileSize: IllegalArgumentException obteniendo tamaño del archivo para URI \'%s\' (Video)</string>
    <string name="log_error_get_filesize_video">getFileSize: Error obteniendo tamaño del archivo para URI \'%s\' (Video)</string>
    <string name="log_user_not_authenticated_oncreate_video">onCreate: Usuario no autenticado. Finalizando actividad UploadVideo.</string>
    <string name="log_coordinates_received_video">mapsActivityResultLauncher: Coordenadas recibidas - Lat: %1$s, Lon: %2$s, Ciudad: %3$s (Video)</string>
    <string name="log_map_selection_cancelled_video">mapsActivityResultLauncher: Selección de mapa cancelada o sin resultado (Video).</string>
    <string name="log_state_restored_upload_video">onCreate: Estado restaurado - VideoURI: %1$s, ImageURI: %2$s, Lat: %3$s (Video)</string>
    <string name="log_error_cloudinary_not_configured_video">checkCloudinaryInitialization: Cloudinary no está configurado en MediaManager (UploadVideo).</string>
    <string name="log_error_cloudinary_not_initialized_video">checkCloudinaryInitialization: Cloudinary (MediaManager) no inicializado (UploadVideo).</string>
    <string name="log_error_cloudinary_unknown_check_video">checkCloudinaryInitialization: Error desconocido verificando Cloudinary (UploadVideo).</string>
    <string name="log_video_upload_cancellation_sent">setupUploadCancelButton: Solicitud de cancelación de subida de video enviada para ID: %s</string>
    <string name="log_error_cancelling_video_upload">setupUploadCancelButton: Error al cancelar la subida de video ID: %s</string>
    <string name="log_complementary_image_upload_cancellation_sent">setupUploadCancelButton: Solicitud de cancelación de subida de imagen complementaria enviada para ID: %s</string>
    <string name="log_error_cancelling_complementary_image_upload">setupUploadCancelButton: Error al cancelar la subida de imagen complementaria ID: %s</string>
    <string name="log_error_loading_video_preview">Error al cargar vista previa del video. URI: %1$s, What: %2$s, Extra: %3$s</string>
    <string name="log_play_button_clicked_video_uri_null">setupVideoPlayerControls: btnPlay clickeado pero videoUri es nulo.</string>
    <string name="log_error_parsing_date_datepicker_video">showCustomDatePickerVideoFragment: No se pudo parsear la fecha \'%s\' del editTextExactDate. Usando fecha actual.</string>
    <string name="log_all_fields_cleared_video">clearAllFields: Todos los campos limpiados en UploadVideo.</string>
    <string name="log_submission_already_in_progress_video">processVideoSubmission: Ya se está procesando un envío de video.</string>
    <string name="log_form_not_valid_video">processVideoSubmission: Formulario no válido para video.</string>
    <string name="log_error_user_not_authenticated_submission_video">processVideoSubmission: Usuario no autenticado al intentar enviar video.</string>
    <string name="content_type_video">video</string>
    <string name="firestore_field_youtubeLink">youtubeLink</string>
    <string name="firestore_field_videoUrl">videoUrl</string>
    <string name="log_starting_cloudinary_video_upload">processVideoSubmission: Iniciando subida de video a Cloudinary para URI: %s</string>
    <string name="log_starting_complementary_image_upload_no_local_video">processVideoSubmission: Iniciando subida de imagen complementaria (sin video local) para URI: %s</string>
    <string name="log_saving_video_data_youtube_link_only">processVideoSubmission: Guardando datos de video solo con enlace de YouTube: %s</string>
    <string name="log_error_no_video_source_after_validation">processVideoSubmission: No hay fuente de video (ni local ni YouTube) después de la validación.</string>
    <string name="log_error_getting_user_data_for_authorship_video">processVideoSubmission: Error al obtener datos del usuario para autoría del video.</string>
    <string name="log_error_getting_bytes_from_video_uri">uploadVideoAndProceed: Falló la obtención de bytes del video URI: %s</string>
    <string name="cloudinary_folder_video_uploads">video_uploads/%s</string>
    <string name="cloudinary_public_id_video_prefix">video_</string>
    <string name="log_cloudinary_video_upload_started">uploadVideoAndProceed - onStart: Subida de video a Cloudinary iniciada, requestId: %s</string>
    <string name="log_cloudinary_video_upload_success">uploadVideoAndProceed - onSuccess: Video subido a Cloudinary, URL: %s</string>
    <string name="log_error_cloudinary_video_url_null">uploadVideoAndProceed - onSuccess: URL de video de Cloudinary es nula.</string>
    <string name="error_suffix_cloudinary_video_url_null">(URL de video nula de Cloudinary)</string>
    <string name="log_error_cloudinary_video_upload">uploadVideoAndProceed - onError: Error subiendo video a Cloudinary. RequestId: %1$s, Error: %2$s, Code: %3$s</string>
    <string name="error_suffix_video_upload">(video)</string>
    <string name="log_cloudinary_video_upload_rescheduled">uploadVideoAndProceed - onReschedule: Subida de video re-programada. RequestId: %1$s, Error: %2$s, Code: %3$s</string>
    <string name="error_suffix_upload_rescheduled_video">(Video re-programado: %s)</string>
    <string name="log_error_compressing_complementary_image_uri">uploadComplementaryImageAndSaveData: Falló la compresión de la imagen complementaria URI: %s</string>
    <string name="error_suffix_complementary_image">(complementaria)</string>
    <string name="log_complementary_image_compression_failed_saving_video_data_without_it">uploadComplementaryImageAndSaveData: Compresión de imagen complementaria falló, guardando datos de video sin ella.</string>
    <string name="cloudinary_folder_video_complementary_images">video_complementary_images/%s</string>
    <string name="cloudinary_public_id_video_comp_img_prefix">video_comp_img_</string>
    <string name="log_cloudinary_complementary_image_upload_started">uploadComplementaryImageAndSaveData - onStart: Subida de imagen complementaria a Cloudinary iniciada, requestId: %s</string>
    <string name="log_cloudinary_complementary_image_upload_success">uploadComplementaryImageAndSaveData - onSuccess: Imagen complementaria subida, URL: %s</string>
    <string name="log_cloudinary_complementary_image_url_null">uploadComplementaryImageAndSaveData - onSuccess: URL de imagen complementaria es nula, continuando sin ella.</string>
    <string name="log_error_cloudinary_complementary_image_upload">uploadComplementaryImageAndSaveData - onError: Error subiendo imagen complementaria. RequestId: %1$s, Error: %2$s, Code: %3$s</string>
    <string name="log_complementary_image_upload_cancelled_saving_video_data">uploadComplementaryImageAndSaveData - onError: Subida de imagen complementaria cancelada, guardando datos de video.</string>
    <string name="error_suffix_complementary_image_upload">(imagen complementaria)</string>
    <string name="log_error_uploading_complementary_image_saving_without_it">uploadComplementaryImageAndSaveData - onError: Error subiendo imagen complementaria: %s. Guardando datos sin ella si es posible.</string>
    <string name="log_cloudinary_complementary_image_upload_rescheduled">uploadComplementaryImageAndSaveData - onReschedule: Reintento subida imagen complementaria. RequestId: %1$s, Error: %2$s, Code: %3$s</string>
    <string name="error_suffix_upload_rescheduled_comp_image">(Imagen complementaria re-programada: %s)</string>
    <string name="log_error_inputstream_null_for_uri_video">getVideoByteArray: InputStream es nulo para URI: %s</string>
    <string name="log_error_file_not_found_get_video_bytes">getVideoByteArray: Archivo no encontrado para URI \'%s\'</string>
    <string name="log_error_io_get_video_bytes">getVideoByteArray: Error de IO leyendo URI \'%s\'</string>
    <string name="log_unexpected_error_get_video_bytes">getVideoByteArray: Error inesperado leyendo URI \'%s\'</string>
    <string name="error_inputstream_null_for_uri_compress_video">InputStream es nulo para URI: %s (compressImageToWebP - Video)</string>
    <string name="error_failed_decode_bitmap_from_uri_compress_video">Fallo al decodificar bitmap desde URI: %s (compressImageToWebP - Video)</string>
    <string name="error_exif_inputstream_null_for_uri_compress_video">Exif InputStream es nulo para URI: %s (compressImageToWebP - Video)</string>
    <string name="log_error_file_not_found_compress_webp_video">compressImageToWebP: Archivo no encontrado para URI \'%s\' (UploadVideo)</string>
    <string name="log_error_io_compress_webp_video">compressImageToWebP: Error de E/S comprimiendo imagen desde URI \'%s\' (UploadVideo)</string>
    <string name="log_error_unexpected_compress_webp_video">compressImageToWebP: Error inesperado comprimiendo imagen desde URI \'%s\' (UploadVideo)</string>
    <string name="log_error_closing_streams_compress_webp_uri_video">compressImageToWebP: Error cerrando streams para URI \'%s\' (UploadVideo)</string>
    <string name="log_firestore_video_data_saved">saveVideoDataToFirestore: Datos del video guardados en Firestore con ID: %s</string>
    <string name="log_error_firestore_saving_video_data">saveVideoDataToFirestore: Error al guardar datos del video en Firestore.</string>
    <string name="error_suffix_firestore_save_video">(Firestore - video)</string>
    <string name="log_handling_upload_error_video">handleUploadError (Video): %s</string>
    <string name="log_activity_finishing_dialog_not_shown_video">showSubmissionConfirmationDialog (Video): La actividad está finalizando o destruida, no se mostrará el diálogo.</string>
    <string name="log_activity_finishing_dialog_not_shown_video_alert">showAlertDialog (Video): La actividad está finalizando o destruida, no se mostrará el diálogo.</string>

    <!-- VideoViewerActivity.kt -->
    <string name="intent_extra_video_id_key">VIDEO_ID</string>
    <string name="firestore_collection_videos_approved">videos</string>
    <string name="error_video_source_not_found">Fuente de video no encontrada.</string>
    <string name="log_document_not_found_in_collection_video">Documento no encontrado en %1$s con ID: %2$s (VideoViewer)</string>
    <string name="log_error_loading_video_with_id">Error al cargar video con ID: %1$s</string>
    <string name="log_error_initializing_exoplayer">Error al inicializar ExoPlayer</string>
    <string name="error_initializing_exoplayer_message">Error al inicializar el reproductor de video</string>

    <!-- WaveformView.kt -->
    <string name="cd_waveform_visualizer">Visualizador de forma de onda de audio</string>
    <string name="log_waveform_size_changed">WaveformView onSizeChanged: w=%1$d, h=%2$d, maxDisplayablePoints=%3$d</string>
    <string name="log_waveform_setdata_empty_or_no_points">WaveformView setWaveformData: Muestras vacías o maxDisplayablePoints es cero. Limpiando forma de onda.</string>
    <string name="log_waveform_setdata_processed">WaveformView setWaveformData: Procesadas %d amplitudes normalizadas.</string>
    <string name="log_waveform_cleared">WaveformView: Forma de onda limpiada.</string>

    <!-- WriteStoryFragment.kt -->
    <string name="hint_story_text_or_record_audio">Escribe tu relato o usa grabadora de audio</string>
    <string name="suggestion_use_voice_to_text_keyboard">Sugerencia: Para escribir más rápido, puedes usar un teclado con función de voz a texto (como Gboard).</string>

    <!-- activity_admin_profile.xml -->
    <string name="admin_icon_desc">Ícono de Administrador</string>
    <string name="admin_profile_activity_title">Panel de Administrador</string>

    <!-- activity_comment.xml -->
    <string name="enviar_comentario">Enviar comentario</string>

    <!-- activity_edit_profile.xml -->
    <string name="edit_profile">Editar Perfil</string>
    <string name="delete_account">Eliminar cuenta</string>
    <string name="my_profile">Mi Perfil</string>
    <string name="change_profile_picture_desc">Cambiar foto de perfil</string>
    <string name="delete_profile_picture_desc">Descripción para el botón de eliminar foto de perfil</string>
    <string name="hint_username_edit">Pon tu nombre de usuario</string>
    <string name="username_already_set_info">Tu nombre de usuario ya es permanente.</string>
    <string name="label_location_edit_profile">Tu Ubicación (Estado de México)</string>
    <string name="content_desc_select_state_edit_profile">Selecciona tu estado de México</string>
    <string name="save_changes">Guardar Cambios</string>

    <!-- activity_image_viewer.xml -->
    <string name="title_detail_image">Detalle de Imagen</string>
    <string name="content_desc_main_image">Imagen principal</string>
    <string name="me_gusta">Me gusta</string>
    <string name="ver_comentarios">Ver comentarios</string>

    <!-- activity_main.xml -->
    <string name="back_button_desc">Botón regresar</string>
    <string name="previous">Anterior</string>
    <string name="next">Siguiente</string>
    <string name="cancelar">Cancelar</string>
    <string name="notifications">Notificaciones</string>
    <string name="sound_on">Sonido activado</string>
    <string name="sound_off">Sonido desactivado</string>
    <string name="logo_mexico_paranormal">Logo de México Paranormal</string>
    <string name="mexico">MÉXICO</string>
    <string name="paranormal">PARANORMAL</string>
    <string name="slogan">Descubre lo oculto, comparte lo inexplicable.</string>
    <string name="search">Buscar</string>
    <string name="search_hint">Buscar lugares, leyendas, mitos</string>
    <string name="search_action_desc">Acción de búsqueda</string>
    <string name="fotos">Fotos</string>
    <string name="videos">Videos</string>
    <string name="relatos">Relatos</string>
    <string name="recientes">Recientes</string>
    <string name="favoritos">Favoritos</string>
    <string name="lugares_investigados">Lugares Investigados</string>
    <string name="mapa_paranormal">Mapa Paranormal</string>
    <string name="como_funciona">¿Cómo funciona?</string>

    <!-- activity_maps.xml -->
    <!-- No contiene strings -->

    <!-- activity_pending_uploads.xml -->
    <string name="title_pending_uploads">Mis Envíos Pendientes</string>

    <!-- activity_relato_viewer.xml -->
    <string name="title_detail_story">Detalle del Relato</string>
    <string name="content_desc_story_attached_image">Imagen adjunta al relato</string>

    <!-- activity_search_results.xml -->
    <string name="filter_location">Ubicación</string>
    <string name="filter_date">Fecha</string>
    <string name="filter_types">Tipos</string>
    <string name="page_1">1</string>
    <string name="page_2">2</string>
    <string name="page_3">3</string>

    <!-- activity_upload_image.xml -->
    <string name="upload_image_title">Subir Imagen</string>
    <string name="image_title_hint">Título de la imagen</string>
    <string name="info_attach_file">Solo 1 archivo (JPG, PNG, etc.), máx 10MB</string>
    <string name="desc_file_info">Información sobre formatos de archivo permitidos</string>
    <string name="select_file_button"> Seleccionar archivo</string>
    <string name="image_preview_description">Previsualización de la imagen seleccionada</string>
    <string name="image_preview_label">* No te preocupes si no carga completa, es solo una vista previa ;)</string>
    <string name="location_question">¿Dónde fue tomada la imagen?</string>
    <string name="label_coordinates">Coordenadas (Opcional)</string>
    <string name="info_coordinates">¿Puedes ubicarlo en el mapa?</string>
    <string name="desc_coordinates_section">Sección para ingresar las coordenadas de la historia</string>
    <string name="select_location_map">Seleccione en el mapa en donde ocurrió</string>
    <string name="edit_coordinates">Editar coordenadas</string>
    <string name="image_description_hint">Escribe una descripción para la imagen</string>
    <string name="fecha">Fecha</string>
    <string name="desc_date_section">Sección de selección de fecha</string>
    <string name="date_type_year">Solo Año</string>
    <string name="date_type_exact">Fecha Exacta</string>
    <string name="date_type_range">Rango de Años</string>
    <string name="date_type_unknown">Desconocido</string>
    <string name="hint_year">Escribe aquí el Año (A partir de 1826)</string>
    <string name="hint_exact_date">Click aquí para seleccionar la fecha</string>
    <string name="hint_start_year">Año inicio (ej: 1990)</string>
    <string name="hint_end_year">Año fin (ej: 2000)</string>
    <string name="button_clear_all">Borrar todo</string>
    <string name="send_image_button">Enviar Imagen a revisión</string>
    <string name="cancel_upload_button">Cancelar Carga</string>

    <!-- activity_upload_story.xml -->
    <string name="title_upload_relato">Subir Relato</string>
    <string name="hint_story_title">Título del relato</string>
    <string name="label_story_type">Tipo de relato:</string>
    <string name="hint_specify_other_type">Especifica el tipo de relato</string>
    <string name="label_location_story">¿Dónde ocurrió?</string>
    <string name="hint_year_story">Escribe aquí el Año (A partir de 1582)</string>
    <string name="label_attach_image_story_optional">Adjuntar imagen (opcional)</string>
    <string name="button_send_story">Enviar relato a revisión</string>
    <string name="tab_title_write">Escribir</string>
    <string name="tab_title_record_audio">Grabar Audio</string>
    <string name="tab_title_attach_audio">Adjuntar Audio</string>
    <string name="label_record_audio_section">Grabar Audio (Opcional)</string>
    <string name="button_record">Grabar</string>
    <string name="button_pause">Pausar</string>
    <string name="button_resume">Reanudar</string>
    <string name="button_stop">Detener</string>
    <string name="text_audio_time_remaining">Restante: %s</string>
    <string name="label_recorded_audio">Audio Grabado:</string>
    <string name="text_recorded_on">Grabado: %s</string>
    <string name="audio_info_format">%1$s (%2$s)</string>
    <string name="button_play_audio">Reproducir Audio</string>
    <string name="button_delete_audio">Eliminar Audio</string>
    <string name="label_attach_audio_section">Adjuntar Audio (Opcional)</string>
    <string name="text_audio_playback_speed">Velocidad:</string>
    <string name="text_playback_speed_0.5x">0.5x</string>
    <string name="text_playback_speed_1_5x">1.5x</string>
    <string name="text_playback_speed_2x">2x</string>
    <string name="text_playback_speed_2_5x">2.5x</string>
    <string name="text_playback_speed_3x">3x</string>
    <string name="text_playback_speed_3_5x">3.5x</string>
    <string name="text_playback_speed_4x">4x</string>
    <string name="content_desc_record_button">Botón grabar audio</string>
    <string name="content_desc_stop_button">Botón detener grabación</string>
    <string name="content_desc_select_audio_button">Botón seleccionar archivo de audio</string>
    <string name="content_desc_audio_controls">Controles de reproducción de audio</string>
    <string name="content_desc_time_remaining_display">Visualización del tiempo de grabación restante</string>
    <string name="content_desc_audio_filename_display">Nombre del archivo de audio adjunto o grabado</string>
    <string name="content_desc_playback_speed_selector">Selector de velocidad de reproducción de audio</string>
    <string name="story_type_other">Otro (especifique)</string>
    <string name="hint_write_story">Escribe aquí tu relato paranormal</string>

    <!-- activity_upload_video.xml -->
    <string name="title_upload_video">Subir Video</string>
    <string name="hint_video_title">Título del video</string>
    <string name="label_attach_video">Adjuntar vídeo (hasta 10MB)</string>
    <string name="play_video">Reproducir video</string>
    <string name="pause_video">Pausar video</string>
    <string name="stop_video">Detener video</string>
    <string name="close_video">Cerrar video</string>
    <string name="hint_youtube_link">Enlace de YouTube (opcional)</string>
    <string name="hint_video_description">Escribe una descripción para el video</string>
    <string name="label_location">¿Dónde ocurrió?</string>
    <string name="desc_info_icon">Más información sobre formatos de fecha</string>
    <string name="hint_year_video">Escribe aquí el Año (A partir de 1896)</string>
    <string name="button_clear_all_video">Borrar todo</string>
    <string name="button_send_video">Enviar Video a revisión</string>

    <!-- activity_video_viewer.xml -->
    <string name="title_detail_video">Detalle del Video</string>
    <string name="label_complementary_image">Imagen Complementaria:</string>
    <string name="content_desc_complementary_image_video">Imagen complementaria del video</string>

    <!-- dialog_custom_date_picker.xml -->
    <!-- No contiene strings -->

    <!-- fragment_admin_moderation.xml -->
    <string name="moderation_pending_approval">🕵️ Pendientes por aprobar:</string>
    <string name="moderation_stories">📖 Relatos</string>
    <string name="moderation_no_items_pending">No hay elementos pendientes por aprobar.</string>
    <string name="moderation_photos">📷 Fotos</string>
    <string name="moderation_videos">🎥 Videos</string>
    <string name="moderation_history">🗂️ Historial de Moderación:</string>
    <string name="moderation_status_approved_rejected">- Aprobado / Rechazado</string>
    <string name="moderation_no_history">No hay historial de moderación.</string>
    <string name="moderation_user_management">👥 Gestión de Usuarios:</string>
    <string name="moderation_active_users">- Activos</string>
    <string name="moderation_no_users_to_manage">No hay usuarios para gestionar.</string>
    <string name="moderation_banned_users">- Baneados</string>
    <string name="moderation_ban_button">[✓ Banear]</string>
    <string name="moderation_unban_button">[✓ Desbanear]</string>
    <string name="admin_moderation_placeholder">Contenido de Moderación (Próximamente)</string>

    <!-- fragment_attach_audio.xml -->
    <string name="button_select_audio">Seleccionar Audio</string>
    <string name="loading_waveform">Cargando onda de audio…</string>
    <string name="label_attached_audio">Audio Adjunto:</string>
    <string name="content_desc_play_button">Botón reproducir audio</string>
    <string name="content_desc_pause_button">Botón pausar grabación</string>
    <string name="content_desc_delete_audio_button">Botón eliminar audio</string>

    <!-- fragment_record_audio.xml -->
    <string name="audio_source_label">Fuente:</string>
    <string name="audio_source_prompt">Fuente de Audio:</string>
    <string name="timer_default">00:00.00</string>
    <string name="cd_start_recording_button">Botón para iniciar grabación</string>
    <string name="cd_pause_recording_button">Botón para pausar grabación</string>
    <string name="error_no_audio_recorded_after_stop">No se pudo guardar el audio o el archivo está vacío.</string>
    <string name="error_no_audio_recorded">No se grabó ningún audio o el archivo está vacío.</string>
    <string name="player_recorded_audio_title">Audio Grabado</string>
    <string name="cd_play_recorded_audio">Reproducir audio grabado</string>
    <string name="cd_pause_recorded_audio">Pausar audio grabado</string>
    <string name="cd_playback_speed">Velocidad de reproducción</string>
    <string name="cd_save_local_audio">Guardar audio localmente</string>
    <string name="cd_delete_recorded_audio">Eliminar audio grabado</string>

    <!-- fragment_settings.xml -->
    <string name="comments">Ver comentarios</string>
    <string name="favorites">Favoritos guardados</string>
    <string name="account_section_title">Cuenta</string>
    <string name="logout">Cerrar sesión</string>

    <!-- fragment_uploads.xml -->
    <string name="upload_relato">Subir Relato</string>
    <string name="upload_foto">Subir Foto</string>
    <string name="upload_video">Subir Video</string>
    <string name="my_uploads">Mis Envíos:</string>
    <string name="pending">Pendientes</string>
    <string name="approved">Aprobados</string>
    <string name="rejected">Rechazados</string>

    <!-- fragment_write_story.xml -->
    <!-- No contiene strings -->

    <!-- item_comment.xml -->
    <!-- No contiene strings -->

    <!--  item_dashboard_card.xml -->
    <!-- No contiene strings -->

    <!--  item_search_result.xml -->
    <!-- No contiene strings -->

    <!-- list_item_pending_upload.xml -->
    <string name="content_desc_item_type_icon">Icono de tipo de envío</string>
    <string name="content_desc_pending_status">Estado: Pendiente</string>

    <!-- list_item_section_header.xml -->
    <string name="placeholder_section_title">Título de Sección</string>

</resources>


===== Archivo: app\src\main\res\values\styles.xml =====


<?xml version="1.0" encoding="utf-8"?>
<resources>
    <style name="TextAppearance.Headline" parent="TextAppearance.AppCompat.Headline">
        <item name="android:textColor">@color/white</item>
        <item name="android:textStyle">bold</item>
    </style>

    <style name="TextAppearance.Slogan" parent="TextAppearance.AppCompat.Small">
        <item name="android:textColor">@color/grey_light</item>
    </style>

    <style name="Widget.App.Chip" parent="Widget.MaterialComponents.Chip.Action">
        <item name="chipBackgroundColor">@color/white</item>
        <item name="strokeColor">@color/blue_primary</item>
        <item name="strokeWidth">1dp</item>
        <item name="android:textColor">@color/grey_light</item>
        <item name="android:textSize">14sp</item>
        <item name="android:textStyle">bold</item>
        <item name="shapeAppearance">@style/ShapeAppearance.App.SmallComponent</item>
        <item name="android:paddingStart">16dp</item>
        <item name="android:paddingEnd">16dp</item>
        <item name="android:layout_marginEnd">8dp</item>
    </style>

    <style name="Widget.App.Button.Primary" parent="Widget.MaterialComponents.Button">
        <item name="android:backgroundTint">@color/blue_primary</item>
        <item name="android:textColor">@color/white</item>
        <item name="android:textSize">16sp</item>
        <item name="android:textStyle">bold</item>
        <item name="cornerRadius">8dp</item>
        <item name="android:paddingTop">12dp</item>
        <item name="android:paddingBottom">12dp</item>
        <item name="android:elevation">4dp</item>
    </style>

    <style name="TextAppearance.Link" parent="TextAppearance.AppCompat.Small">
        <item name="android:textColor">@color/blue_light</item>
        <item name="android:textSize">14sp</item>
        <item name="android:clickable">true</item>
        <item name="android:focusable">true</item>
    </style>

    <style name="Widget.App.Card" parent="CardView">
        <item name="cardBackgroundColor">@android:color/transparent</item>
        <item name="cardCornerRadius">8dp</item>
        <item name="cardElevation">4dp</item>
    </style>

    <style name="TextAppearance.CardTitle" parent="TextAppearance.AppCompat.Medium">
        <item name="android:textColor">@color/white</item>
        <item name="android:textStyle">bold</item>
    </style>

    <style name="TextAppearance.CardDescription" parent="TextAppearance.AppCompat.Small">
        <item name="android:textColor">@color/grey_light</item>
    </style>

    <style name="ShapeAppearance.App.SmallComponent" parent="ShapeAppearance.Material3.SmallComponent">
        <item name="cornerFamily">rounded</item>
        <item name="cornerSize">20dp</item>
    </style>

    <style name="ChipStyle" parent="Widget.MaterialComponents.Chip.Choice">
        <item name="chipBackgroundColor">@color/glass_background</item>
        <item name="chipStrokeColor">@color/glass_stroke</item>
        <item name="chipStrokeWidth">1dp</item>
        <item name="android:textColor">@color/white</item>
        <item name="android:textSize">18sp</item>
        <item name="android:textStyle">bold</item>
        <item name="shapeAppearance">@style/ShapeAppearance.App.SmallComponent</item>
        <item name="android:minHeight">48dp</item>
    </style>

    <style name="NumberPickerTheme" parent="Theme.AppCompat.Light">
        <item name="android:textColorPrimary">@color/white</item>
        <item name="android:textColorSecondary">@color/grey_light</item>
        <item name="android:background">@android:color/transparent</item>
        <item name="android:textSize">18sp</item>
    </style>
</resources>


===== Archivo: app\src\main\res\values\themes.xml =====


<resources>
    <!-- Base application theme. -->
    <style name="Base.Theme.MexicoParanormal" parent="Theme.Material3.DayNight.NoActionBar">
        <!-- Customize your light theme here. -->
        <item name="colorPrimary">@color/blue_primary</item>
        <item name="colorOnPrimary">@color/white</item>
        <item name="colorSecondary">@color/blue_light</item>
        <item name="colorOnSecondary">@color/white</item>
        <item name="android:windowBackground">@color/purple_dark</item>
    </style>

    <style name="Theme.MexicoParanormal" parent="Base.Theme.MexicoParanormal" />
</resources>


===== Archivo: app\src\main\res\values-night\themes.xml =====


<resources xmlns:tools="http://schemas.android.com/tools">
    <style name="Base.Theme.MexicoParanormal" parent="Theme.Material3.DayNight.NoActionBar">
    </style>
    <style name="Theme.MexicoParanormal" parent="Base.Theme.MexicoParanormal" />
</resources>


===== Archivo: app\src\main\res\xml\backup_rules.xml =====


<?xml version="1.0" encoding="utf-8"?><!--
   Sample backup rules file; uncomment and customize as necessary.
   See https://developer.android.com/guide/topics/data/autobackup
   for details.
   Note: This file is ignored for devices older than API 31
   See https://developer.android.com/about/versions/12/backup-restore
-->
<full-backup-content>
    <!--
   <include domain="sharedpref" path="."/>
   <exclude domain="sharedpref" path="device.xml"/>
-->
</full-backup-content>


===== Archivo: app\src\main\res\xml\data_extraction_rules.xml =====


<?xml version="1.0" encoding="utf-8"?><!--
   Sample data extraction rules file; uncomment and customize as necessary.
   See https://developer.android.com/about/versions/12/backup-restore#xml-changes
   for details.
-->
<data-extraction-rules>
    <cloud-backup>
        <!-- TODO: Use <include> and <exclude> to control what is backed up.
        <include .../>
        <exclude .../>
        -->
    </cloud-backup>
    <!--
    <device-transfer>
        <include .../>
        <exclude .../>
    </device-transfer>
    -->
</data-extraction-rules>


===== Archivo: app\src\test\java\com\example\mexicoparanormal\ExampleUnitTest.kt =====


package com.example.mexicoparanormal

import org.junit.Test

import org.junit.Assert.*

/**
 * Example local unit test, which will execute on the development machine (host).
 *
 * See [testing documentation](http://d.android.com/tools/testing).
 */
class ExampleUnitTest {
    @Test
    fun addition_isCorrect() {
        assertEquals(4, 2 + 2)
    }
}
