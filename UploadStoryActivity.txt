package com.example.mexicoparanormal

import android.Manifest // No se usa directamente, pero puede ser necesario para permisos de audio/imagen
import android.app.Activity
import android.app.AlertDialog
import android.content.ContentResolver
// Eliminada importación no utilizada de android.content.pm.PackageManager
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.graphics.Matrix
import androidx.exifinterface.media.ExifInterface
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.provider.OpenableColumns
import android.text.Editable
import android.text.TextWatcher
import android.util.Log
import android.view.View
import android.widget.AdapterView
import android.widget.ArrayAdapter
import android.widget.Toast
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AppCompatActivity
// Eliminada importación no utilizada de androidx.core.content.ContextCompat
import androidx.core.net.toUri
import androidx.core.view.isVisible
import androidx.fragment.app.Fragment
import com.cloudinary.android.MediaManager
import com.cloudinary.android.callback.ErrorInfo
import com.cloudinary.android.callback.UploadCallback
import com.example.mexicoparanormal.databinding.ActivityUploadStoryBinding
import com.google.android.material.tabs.TabLayoutMediator
import com.google.android.material.textfield.TextInputLayout
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.firestore.FieldValue
import com.google.firebase.firestore.FirebaseFirestore
import java.io.ByteArrayOutputStream
import java.io.File // Necesario para manejo de archivos de audio
import java.io.InputStream
import java.io.FileNotFoundException
// Eliminada importación no utilizada de java.io.FileOutputStream
import java.io.IOException
import java.text.ParseException
import java.text.SimpleDateFormat
import java.util.Calendar
import java.util.Locale
import java.util.UUID
import android.content.Intent
// import kotlin.math.max // No se usa directamente
import kotlin.math.roundToInt
import androidx.core.graphics.scale

class UploadStoryActivity : AppCompatActivity(),
    DialogCustomDatePicker.OnDateSelectedListener,
    RecordAudioFragment.AudioRecordListener,
    AttachAudioFragment.AudioAttachListener {

    private lateinit var binding: ActivityUploadStoryBinding
    private lateinit var auth: FirebaseAuth
    private lateinit var firestore: FirebaseFirestore
    private lateinit var storyInputPagerAdapter: StoryInputPagerAdapter

    private var selectedLatitude: Double? = null
    private var selectedLongitude: Double? = null
    private var selectedCityName: String? = null

    private lateinit var mapsActivityResultLauncher: ActivityResultLauncher<Intent>

    private var selectedImageUri: Uri? = null // Para imagen opcional del relato
    private var recordedAudioUri: Uri? = null
    private var recordedAudioOriginalName: String? = null
    private var attachedAudioUri: Uri? = null
    private var attachedAudioOriginalName: String? = null
    private var finalAudioToUploadUri: Uri? = null // El URI que finalmente se subirá (grabado o adjunto)
    private var finalAudioOriginalName: String? = null // Nombre original del audio final

    private val MIN_YEAR_STORY = 1582 // Año mínimo para relatos
    private val dateFormatStory = SimpleDateFormat("dd/MM/yyyy", Locale.getDefault())

    private var isSubmitting = false
    private var currentStoryImageUploadRequestId: String? = null // ID para subida de imagen del relato
    private var currentAudioFileUploadRequestId: String? = null // ID para subida de audio

    companion object {
        private const val TAG = "UploadStoryActivity"
        private const val MAX_IMAGE_FILE_SIZE_MB = 10 // Para imagen opcional
        // El tamaño máximo del archivo de audio se maneja en los fragmentos de audio
    }

    private val selectImageLauncher = registerForActivityResult(ActivityResultContracts.GetContent()) { uri: Uri? ->
        uri?.let {
            try {
                val contentResolver: ContentResolver = applicationContext.contentResolver
                val type = contentResolver.getType(it)
                val allowedMimeTypes = listOf("image/jpeg", "image/png", "image/jfif", "image/webp")

                if (type != null && allowedMimeTypes.contains(type.lowercase(Locale.getDefault()))) {
                    val fileSize = getFileSize(contentResolver, it) // Pasar contentResolver
                    val maxFileSizeInBytes = MAX_IMAGE_FILE_SIZE_MB * 1024 * 1024
                    if (fileSize > maxFileSizeInBytes) {
                        showToast(getString(R.string.error_audio_file_too_large_detailed, MAX_IMAGE_FILE_SIZE_MB, fileSize / (1024*1024)))
                        clearOptionalImageSelection()
                        return@registerForActivityResult
                    }
                    selectedImageUri = it
                    binding.imageViewPreviewStory.setImageURI(it)
                    binding.imageViewPreviewStory.isVisible = true
                    binding.textViewPreviewLabelStory.isVisible = true
                    Log.i(TAG, getString(R.string.log_optional_image_selected, it.toString()))
                    showToast(getString(R.string.image_selection_successful))
                } else {
                    val allowedFormats = allowedMimeTypes.joinToString(", ") { mime -> mime.substringAfter("/") }
                    Log.w(TAG, getString(R.string.log_invalid_file_type_optional_image, it.toString(), type))
                    showToast(getString(R.string.error_invalid_file_type_specific, allowedFormats))
                    clearOptionalImageSelection()
                }
            } catch (e: SecurityException) {
                Log.e(TAG, getString(R.string.log_security_exception_validating_optional_image, it.toString()), e)
                showToast(getString(R.string.error_accessing_file_permission, it.lastPathSegment ?: getString(R.string.selected_image_default_name)))
                clearOptionalImageSelection()
            } catch (e: IllegalArgumentException) {
                Log.e(TAG, getString(R.string.log_illegal_argument_validating_optional_image, it.toString()), e)
                showToast(getString(R.string.error_invalid_file_type_specific, getString(R.string.unknown_format)))
                clearOptionalImageSelection()
            } catch (e: Exception) {
                Log.e(TAG, getString(R.string.log_unexpected_error_validating_optional_image, it.toString()), e)
                showToast(getString(R.string.upload_file_error_message, e.localizedMessage ?: getString(R.string.unknown_error)))
                clearOptionalImageSelection()
            }
        } ?: run { // Si el URI es nulo (selección cancelada)
            clearOptionalImageSelection()
            Log.d(TAG, getString(R.string.log_optional_image_selection_cancelled))
            showToast(getString(R.string.image_selection_cancelled))
        }
    }


    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityUploadStoryBinding.inflate(layoutInflater)
        setContentView(binding.root)

        auth = FirebaseAuth.getInstance()
        firestore = FirebaseFirestore.getInstance()
        dateFormatStory.isLenient = false // Para validación estricta de fechas

        if (auth.currentUser == null) {
            Log.w(TAG, getString(R.string.log_user_not_authenticated_oncreate_story))
            Toast.makeText(this, getString(R.string.error_user_not_authenticated), Toast.LENGTH_LONG).show()
            finish()
            return
        }

        mapsActivityResultLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result ->
            if (result.resultCode == Activity.RESULT_OK) {
                result.data?.let { data ->
                    selectedLatitude = data.getDoubleExtra(getString(R.string.intent_extra_latitude_result), 0.0).takeIf { lat -> lat != 0.0 }
                    selectedLongitude = data.getDoubleExtra(getString(R.string.intent_extra_longitude_result), 0.0).takeIf { lon -> lon != 0.0 }
                    selectedCityName = data.getStringExtra(getString(R.string.intent_extra_cityname_result))
                    Log.i(TAG, getString(R.string.log_coordinates_received_story, selectedLatitude.toString(), selectedLongitude.toString(), selectedCityName))
                    actualizarUIcoordenadas()
                }
            } else {
                Log.d(TAG, getString(R.string.log_map_selection_cancelled_story))
            }
        }

        if (savedInstanceState != null) {
            selectedLatitude = savedInstanceState.getDouble("selectedLatitude", 0.0).takeIf { it != 0.0 }
            selectedLongitude = savedInstanceState.getDouble("selectedLongitude", 0.0).takeIf { it != 0.0 }
            selectedCityName = savedInstanceState.getString("selectedCityName")
            selectedImageUri = savedInstanceState.getString("selectedImageUriKey")?.toUri()
            recordedAudioUri = savedInstanceState.getString("recordedAudioUriKey")?.toUri()
            recordedAudioOriginalName = savedInstanceState.getString("recordedAudioOriginalNameKey")
            attachedAudioUri = savedInstanceState.getString("attachedAudioUriKey")?.toUri()
            attachedAudioOriginalName = savedInstanceState.getString("attachedAudioOriginalNameKey")
            finalAudioToUploadUri = savedInstanceState.getString("finalAudioToUploadUriKey")?.toUri()
            finalAudioOriginalName = savedInstanceState.getString("finalAudioOriginalNameKey")

            if (selectedImageUri != null) {
                binding.imageViewPreviewStory.setImageURI(selectedImageUri)
                binding.imageViewPreviewStory.isVisible = true
                binding.textViewPreviewLabelStory.isVisible = true
            }
            Log.d(TAG, getString(R.string.log_state_restored_upload_story, selectedImageUri.toString(), recordedAudioUri.toString(), attachedAudioUri.toString(), selectedLatitude.toString()))
        }

        setupUI()
        checkCloudinaryInitialization()
        updateAudioWarningVisibility() // Llamar después de restaurar estado
    }

    private fun setupUI() {
        storyInputPagerAdapter = StoryInputPagerAdapter(this)
        binding.viewPagerStoryInput.adapter = storyInputPagerAdapter

        TabLayoutMediator(binding.tabLayoutStoryInput, binding.viewPagerStoryInput) { tab, position ->
            tab.text = when (position) {
                0 -> getString(R.string.tab_title_write)
                1 -> getString(R.string.tab_title_record_audio)
                2 -> getString(R.string.tab_title_attach_audio)
                else -> null
            }
        }.attach()

        setupTextWatchers()
        binding.btnBack.setOnClickListener { onBackPressedDispatcher.onBackPressed() }
        setupSpinners()
        setupDateSelection()
        setupCoordinatesSection()
        setupUploadCancelButton()

        binding.infoIconDate.setOnClickListener { if (it.isEnabled) showDateFormatInfoDialog() }
        binding.btnSelectImageStory.setOnClickListener { if (it.isEnabled) selectImageLauncher.launch("image/*") }
        binding.btnBorrarTodo.setOnClickListener { clearAllFields() }
        binding.btnEnviarRelato.setOnClickListener { processStorySubmission() }

        // Visibilidad inicial de campos
        binding.textInputLayoutOtherStoryType.isVisible = false
        binding.textInputLayoutYear.isVisible = false
        binding.textInputLayoutExactDate.isVisible = false
        binding.dateRangeLayout.isVisible = false
        binding.dateInputFieldsContainer.isVisible = false
        binding.imageViewPreviewStory.isVisible = selectedImageUri != null // Basado en si hay URI guardada
        binding.textViewPreviewLabelStory.isVisible = selectedImageUri != null
        binding.uploadProgressOverlayStory.isVisible = false
        binding.mapSelectionContainer.isVisible = binding.switchCoordinates.isChecked
        actualizarUIcoordenadas()
    }

    private fun checkCloudinaryInitialization() {
        try {
            if (MediaManager.get().cloudinary == null) {
                Log.e(TAG, getString(R.string.log_error_cloudinary_not_configured_story))
                Toast.makeText(this, getString(R.string.cloudinary_config_error), Toast.LENGTH_LONG).show()
                binding.btnEnviarRelato.isEnabled = false
            }
        } catch (e: IllegalStateException) {
            Log.e(TAG, getString(R.string.log_error_cloudinary_not_initialized_story), e)
            Toast.makeText(this, getString(R.string.cloudinary_init_error), Toast.LENGTH_LONG).show()
            binding.btnEnviarRelato.isEnabled = false
        } catch (e: Exception) {
            Log.e(TAG, getString(R.string.log_error_cloudinary_unknown_check_story), e)
            Toast.makeText(this, getString(R.string.cloudinary_check_error), Toast.LENGTH_LONG).show()
            binding.btnEnviarRelato.isEnabled = false
        }
    }

    private fun setupUploadCancelButton() {
        binding.btnCancelUploadStory.setOnClickListener {
            currentStoryImageUploadRequestId?.let {
                try { MediaManager.get().cancelRequest(it)
                    Log.i(TAG, getString(R.string.log_story_image_upload_cancellation_sent, it))
                }
                catch (e: Exception) { Log.e(TAG, getString(R.string.log_error_cancelling_story_image_upload, it), e)}
            }
            currentAudioFileUploadRequestId?.let {
                try { MediaManager.get().cancelRequest(it)
                    Log.i(TAG, getString(R.string.log_story_audio_upload_cancellation_sent, it))
                }
                catch (e: Exception) { Log.e(TAG, getString(R.string.log_error_cancelling_story_audio_upload, it), e)}
            }
            Log.i(TAG, getString(R.string.log_general_upload_cancellation_sent))
            handleUploadError(getString(R.string.upload_cancelled)) // Mensaje genérico de cancelación
        }
    }


    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        selectedLatitude?.let { outState.putDouble("selectedLatitude", it) }
        selectedLongitude?.let { outState.putDouble("selectedLongitude", it) }
        outState.putString("selectedCityName", selectedCityName)
        selectedImageUri?.let { outState.putString("selectedImageUriKey", it.toString()) }
        recordedAudioUri?.let { outState.putString("recordedAudioUriKey", it.toString()) }
        recordedAudioOriginalName?.let { outState.putString("recordedAudioOriginalNameKey", it) }
        attachedAudioUri?.let { outState.putString("attachedAudioUriKey", it.toString()) }
        attachedAudioOriginalName?.let { outState.putString("attachedAudioOriginalNameKey", it) }
        finalAudioToUploadUri?.let { outState.putString("finalAudioToUploadUriKey", it.toString())} // Guardar audio final
        finalAudioOriginalName?.let { outState.putString("finalAudioOriginalNameKey", it) } // Guardar nombre de audio final
    }

    private fun setupSpinners() {
        val storyTypes = resources.getStringArray(R.array.story_types_array)
        val storyTypeAdapter = ArrayAdapter(this, R.layout.spinner_item, storyTypes)
        storyTypeAdapter.setDropDownViewResource(R.layout.spinner_dropdown_item)
        binding.spinnerStoryType.adapter = storyTypeAdapter
        binding.spinnerStoryType.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
            override fun onItemSelected(parent: AdapterView<*>?, view: View?, position: Int, id: Long) {
                val selectedType = parent?.getItemAtPosition(position).toString()
                binding.textInputLayoutOtherStoryType.isVisible = selectedType == getString(R.string.story_type_other)
                if (selectedType != getString(R.string.story_type_other)) {
                    binding.editTextOtherStoryType.text?.clear()
                    binding.textInputLayoutOtherStoryType.error = null // Limpiar error si se cambia de "Otro"
                }
            }
            override fun onNothingSelected(parent: AdapterView<*>?) { /* No se necesita acción */ }
        }

        val locations = resources.getStringArray(R.array.locations_array)
        val locationAdapter = ArrayAdapter(this, R.layout.spinner_item, locations)
        locationAdapter.setDropDownViewResource(R.layout.spinner_dropdown_item)
        binding.spinnerLocation.adapter = locationAdapter
        binding.spinnerLocation.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
            override fun onItemSelected(parent: AdapterView<*>?, view: View?, position: Int, id: Long) {
                if (position <= 1) { // "Seleccione una ubicación" o "desconocido"
                    if (binding.switchCoordinates.isChecked) {
                        binding.switchCoordinates.isChecked = false // Desactivar si se selecciona opción inválida
                    } else {
                        binding.mapSelectionContainer.isVisible = false // Si ya estaba desactivado, solo ocultar
                        resetCoordinates()
                    }
                }
            }
            override fun onNothingSelected(p0: AdapterView<*>?) { /* No se necesita acción */ }
        }
    }

    private fun setupCoordinatesSection() {
        binding.switchCoordinates.setOnCheckedChangeListener { _, isChecked ->
            if (isChecked) {
                if (binding.spinnerLocation.selectedItemPosition <= 1) { // No permitir si no hay estado válido
                    showToast(getString(R.string.error_select_state_first))
                    binding.switchCoordinates.isChecked = false // Revertir el switch
                    return@setOnCheckedChangeListener
                }
                binding.mapSelectionContainer.isVisible = true
            } else {
                binding.mapSelectionContainer.isVisible = false
                resetCoordinates() // Limpiar coordenadas si se apaga el switch
            }
            actualizarUIcoordenadas() // Actualizar la UI en ambos casos
        }

        binding.textViewSelectCoordinates.setOnClickListener {
            if (binding.spinnerLocation.selectedItemPosition > 1) { // Solo si hay un estado válido seleccionado
                openMapForSelection()
            } else {
                showToast(getString(R.string.error_select_state_first))
            }
        }
        binding.btnEditCoordinates.setOnClickListener {
            if (binding.spinnerLocation.selectedItemPosition > 1) { // Solo si hay un estado válido seleccionado
                openMapForSelection()
            }
            // No es necesario un 'else' aquí si el botón solo es visible cuando hay un estado
        }
    }

    private fun openMapForSelection() {
        val intent = Intent(this, MapsActivity::class.java).apply {
            putExtra(getString(R.string.intent_extra_selected_state), binding.spinnerLocation.selectedItem.toString())
            selectedLatitude?.let { putExtra(getString(R.string.intent_extra_latitude), it) }
            selectedLongitude?.let { putExtra(getString(R.string.intent_extra_longitude), it) }
        }
        mapsActivityResultLauncher.launch(intent)
    }

    private fun actualizarUIcoordenadas() {
        val coordinatesAvailable = selectedLatitude != null && selectedLongitude != null
        val switchIsOn = binding.switchCoordinates.isChecked

        if (switchIsOn) {
            binding.mapSelectionContainer.isVisible = true // Asegurar que el contenedor sea visible si el switch está ON
            if (coordinatesAvailable) {
                binding.textViewSelectedCoordinates.text = getString(R.string.selected_coordinates_format, selectedLatitude, selectedLongitude)
                binding.textViewSelectedCoordinates.isVisible = true
                binding.textViewCityName.text = selectedCityName ?: ""
                binding.textViewCityName.isVisible = !selectedCityName.isNullOrEmpty()
                binding.btnEditCoordinates.isVisible = true
                binding.textViewSelectCoordinates.isVisible = false
            } else {
                binding.textViewSelectedCoordinates.isVisible = false
                binding.textViewCityName.isVisible = false
                binding.btnEditCoordinates.isVisible = false
                binding.textViewSelectCoordinates.isVisible = true
            }
        } else {
            binding.mapSelectionContainer.isVisible = false // Ocultar si el switch está OFF
        }
    }

    private fun resetCoordinates() {
        selectedLatitude = null
        selectedLongitude = null
        selectedCityName = null
        actualizarUIcoordenadas() // Actualizar la UI para reflejar el reseteo
    }

    private fun setupDateSelection() {
        binding.radioGroupDateType.setOnCheckedChangeListener { _, checkedId ->
            binding.textInputLayoutYear.isVisible = false
            binding.textInputLayoutExactDate.isVisible = false
            binding.dateRangeLayout.isVisible = false
            binding.dateInputFieldsContainer.isVisible = true // Mostrar contenedor de campos de fecha

            if (checkedId != -1) binding.radioUnknown.isChecked = false // Desmarcar "Desconocido" si se selecciona otro
            clearDateErrors() // Limpiar errores al cambiar tipo

            when (checkedId) {
                R.id.radioYear -> binding.textInputLayoutYear.isVisible = true
                R.id.radioExactDate -> binding.textInputLayoutExactDate.isVisible = true
                R.id.radioDateRange -> binding.dateRangeLayout.isVisible = true
                else -> binding.dateInputFieldsContainer.isVisible = false // Ocultar si no hay nada seleccionado
            }
        }
        binding.radioUnknown.setOnCheckedChangeListener { _, isChecked ->
            if (isChecked) {
                binding.radioGroupDateType.clearCheck() // Desmarcar otros tipos de fecha
                binding.textInputLayoutYear.isVisible = false
                binding.textInputLayoutExactDate.isVisible = false
                binding.dateRangeLayout.isVisible = false
                binding.dateInputFieldsContainer.isVisible = false // Ocultar contenedor
                clearDateFields() // Limpiar campos de fecha
                clearDateErrors() // Limpiar errores
            }
        }
        binding.editTextExactDate.setOnClickListener { if (it.isEnabled) showCustomDatePickerStoryFragment() }

        // Asegurar visibilidad inicial correcta basada en el estado guardado o por defecto
        val initiallyCheckedId = binding.radioGroupDateType.checkedRadioButtonId
        if (initiallyCheckedId != -1) {
            binding.dateInputFieldsContainer.isVisible = true
            when (initiallyCheckedId) {
                R.id.radioYear -> binding.textInputLayoutYear.isVisible = true
                R.id.radioExactDate -> binding.textInputLayoutExactDate.isVisible = true
                R.id.radioDateRange -> binding.dateRangeLayout.isVisible = true
            }
        } else if (binding.radioUnknown.isChecked) {
            binding.dateInputFieldsContainer.isVisible = false
        } else {
            // Por defecto, si nada está seleccionado, el contenedor de campos de fecha debería estar oculto
            binding.dateInputFieldsContainer.isVisible = false
        }
    }

    private fun clearDateErrors() {
        binding.textInputLayoutYear.error = null
        binding.textInputLayoutExactDate.error = null
        binding.textInputLayoutStartYear.error = null
        binding.textInputLayoutEndYear.error = null
        binding.textDateMessageStory.isVisible = false // Ocultar mensaje de error de fecha
    }

    private fun showCustomDatePickerStoryFragment() {
        val cal = Calendar.getInstance()
        var currentDay = cal.get(Calendar.DAY_OF_MONTH)
        var currentMonth = cal.get(Calendar.MONTH) // 0-11
        var currentYear = cal.get(Calendar.YEAR)

        val dateStr = binding.editTextExactDate.text.toString()
        if (dateStr.isNotEmpty()) {
            try {
                val date = dateFormatStory.parse(dateStr)
                date?.let {
                    val selectedCal = Calendar.getInstance().apply { time = it }
                    currentDay = selectedCal.get(Calendar.DAY_OF_MONTH)
                    currentMonth = selectedCal.get(Calendar.MONTH)
                    currentYear = selectedCal.get(Calendar.YEAR)
                }
            } catch (e: ParseException) {
                Log.w(TAG, getString(R.string.log_error_parsing_date_datepicker_story, dateStr), e)
                // No es necesario mostrar un Toast aquí, el diálogo usará la fecha actual
            }
        }

        val dialog = DialogCustomDatePicker.newInstance(
            initialDay = currentDay,
            initialMonth = currentMonth,
            initialYear = currentYear,
            minYear = MIN_YEAR_STORY, // minYear específico para relatos
            title = getString(R.string.dialog_title_story_date) // Título específico
        )
        dialog.show(supportFragmentManager, "customDatePickerStoryDialog")
    }


    override fun onDateSelected(day: Int, month: Int, year: Int) {
        val cal = Calendar.getInstance().apply { set(year, month, day, 0, 0, 0) } // Asegurar hora 00:00:00
        binding.editTextExactDate.setText(dateFormatStory.format(cal.time))
        binding.textInputLayoutExactDate.error = null // Limpiar error al seleccionar
    }

    private fun clearAllFields() {
        binding.editTextStoryTitle.text?.clear()
        binding.textInputLayoutStoryTitle.error = null

        // Limpiar fragmentos
        getFragmentAtIndex<WriteStoryFragment>(0)?.setStoryText("") // Limpiar texto del relato
        getFragmentAtIndex<RecordAudioFragment>(1)?.resetState() // Resetear fragmento de grabación
        getFragmentAtIndex<AttachAudioFragment>(2)?.resetState() // Resetear fragmento de adjuntar

        // Limpiar URIs y nombres de audio
        recordedAudioUri = null
        recordedAudioOriginalName = null
        attachedAudioUri = null
        attachedAudioOriginalName = null
        finalAudioToUploadUri = null
        finalAudioOriginalName = null
        updateAudioWarningVisibility() // Actualizar advertencia de audio

        binding.spinnerStoryType.setSelection(0) // Resetear spinner de tipo de relato
        binding.editTextOtherStoryType.text?.clear()
        binding.textInputLayoutOtherStoryType.error = null
        binding.spinnerLocation.setSelection(0) // Resetear spinner de ubicación
        binding.radioGroupDateType.clearCheck() // Limpiar selección de tipo de fecha
        binding.radioUnknown.isChecked = false // Desmarcar "Desconocido"
        clearDateFields() // Limpiar campos de fecha individuales
        clearOptionalImageSelection() // Limpiar selección de imagen opcional
        binding.switchCoordinates.isChecked = false // Resetear switch de coordenadas

        // Resetear estado de subida
        binding.uploadProgressOverlayStory.isVisible = false
        setUiEnabled(true)
        isSubmitting = false
        currentStoryImageUploadRequestId = null
        currentAudioFileUploadRequestId = null
        Log.d(TAG, getString(R.string.log_all_fields_cleared_story))
    }

    private fun clearDateFields() {
        binding.editTextYear.text?.clear()
        binding.editTextExactDate.text?.clear()
        binding.editTextStartYear.text?.clear()
        binding.editTextEndYear.text?.clear()
        clearDateErrors() // También limpiar errores de fecha
    }

    private fun clearOptionalImageSelection() {
        selectedImageUri = null
        binding.imageViewPreviewStory.setImageDrawable(null) // Limpiar la imagen
        binding.imageViewPreviewStory.isVisible = false
        binding.textViewPreviewLabelStory.isVisible = false
    }

    private fun showDateFormatInfoDialog() {
        AlertDialog.Builder(this)
            .setTitle(R.string.desc_info_date_format_title)
            .setMessage(R.string.desc_info_date_format_message)
            .setPositiveButton(R.string.dialog_positive_button_understood, null)
            .show()
    }

    private fun getFileSize(resolver: ContentResolver, uri: Uri): Long {
        var size = 0L
        try {
            resolver.query(uri, arrayOf(OpenableColumns.SIZE), null, null, null)?.use { cursor ->
                if (cursor.moveToFirst()) {
                    val sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE)
                    if (sizeIndex != -1) size = cursor.getLong(sizeIndex)
                }
            }
        } catch (e: SecurityException) {
            Log.e(TAG, getString(R.string.log_security_exception_get_filesize_uri_story, uri.toString()), e)
            showToast(getString(R.string.error_accessing_file_permission, uri.lastPathSegment ?: getString(R.string.default_file_name)))
        } catch (e: IllegalArgumentException) {
            Log.e(TAG, getString(R.string.log_illegal_argument_get_filesize_uri_story, uri.toString()), e)
            showToast(getString(R.string.error_invalid_file_type_specific, getString(R.string.unknown_format)))
        } catch (e: Exception) { // Captura más genérica para otros errores
            Log.e(TAG, getString(R.string.log_error_get_filesize_uri_story, uri.toString()), e)
            showToast(getString(R.string.upload_file_error_message, e.localizedMessage ?: getString(R.string.unknown_error)))
        }
        return size
    }


    private fun setupTextWatchers() {
        fun createWatcher(layout: TextInputLayout) = object : TextWatcher {
            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}
            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) { layout.error = null }
            override fun afterTextChanged(s: Editable?) {}
        }
        binding.editTextStoryTitle.addTextChangedListener(createWatcher(binding.textInputLayoutStoryTitle))
        binding.editTextOtherStoryType.addTextChangedListener(createWatcher(binding.textInputLayoutOtherStoryType))
        binding.editTextYear.addTextChangedListener(createWatcher(binding.textInputLayoutYear))
        binding.editTextExactDate.addTextChangedListener(createWatcher(binding.textInputLayoutExactDate))
        binding.editTextStartYear.addTextChangedListener(createWatcher(binding.textInputLayoutStartYear))
        binding.editTextEndYear.addTextChangedListener(createWatcher(binding.textInputLayoutEndYear))
    }

    private fun showToast(message: String) {
        Toast.makeText(this, message, Toast.LENGTH_SHORT).show()
    }

    private fun processStorySubmission() {
        if (isSubmitting) {
            Log.d(TAG, getString(R.string.log_submission_already_in_progress_story))
            return
        }

        val storyText = getStoryTextFromFragment()
        if (!validateForm(storyText)) {
            Log.w(TAG, getString(R.string.log_form_not_valid_story))
            return
        }

        // Determinar qué audio se va a subir
        finalAudioToUploadUri = recordedAudioUri ?: attachedAudioUri
        finalAudioOriginalName = recordedAudioOriginalName ?: attachedAudioOriginalName

        val dialogMessage = if (finalAudioToUploadUri != null && selectedImageUri != null) {
            getString(R.string.submission_success_story_audio_image)
        } else if (finalAudioToUploadUri != null) {
            getString(R.string.dialog_confirm_upload_story_with_audio_message)
        } else if (selectedImageUri != null) {
            getString(R.string.submission_success_story_image)
        }
        else { // Solo relato de texto
            getString(R.string.dialog_confirm_upload_story_text_only_message)
        }


        AlertDialog.Builder(this)
            .setTitle(getString(R.string.dialog_confirm_upload_title))
            .setMessage(dialogMessage)
            .setPositiveButton(getString(R.string.accept)) { _, _ ->
                proceedWithSubmission(storyText)
            }
            .setNegativeButton(getString(R.string.cancelar), null)
            .show()
    }

    private fun proceedWithSubmission(storyText: String) {
        setUiEnabled(false) // Deshabilitar UI
        isSubmitting = true

        binding.uploadProgressOverlayStory.isVisible = true
        binding.progressBarUploadStory.progress = 0 // Resetear progreso
        binding.textProgressStory.text = getString(R.string.uploading_content_progress) // Mensaje inicial

        val currentUser = auth.currentUser ?: run {
            Log.e(TAG, getString(R.string.log_error_user_not_authenticated_submission_story))
            handleUploadError(getString(R.string.error_user_not_authenticated))
            return
        }
        val userId = currentUser.uid

        firestore.collection(getString(R.string.firestore_collection_users)).document(userId).get()
            .addOnSuccessListener { userDocument ->
                val authorUsername = userDocument.getString(getString(R.string.firestore_field_username))?.takeIf { it.isNotEmpty() } ?: currentUser.displayName ?: getString(R.string.unknown_user)
                val authorProfileImageUrl = userDocument.getString(getString(R.string.firestore_field_profileImageUrl))?.takeIf { it.isNotEmpty() } ?: currentUser.photoUrl?.toString() ?: ""

                val storyTitle = binding.editTextStoryTitle.text.toString().trim()
                var storyTypeSelected = binding.spinnerStoryType.selectedItem.toString()
                if (storyTypeSelected == getString(R.string.story_type_other)) {
                    storyTypeSelected = binding.editTextOtherStoryType.text.toString().trim()
                }
                val location = binding.spinnerLocation.selectedItem.toString()
                val dateData = getDateFromInputs()

                val storyData = hashMapOf<String, Any?>(
                    getString(R.string.firestore_field_userId) to userId,
                    getString(R.string.firestore_field_authorUsername) to authorUsername,
                    getString(R.string.firestore_field_authorProfileImageUrl) to authorProfileImageUrl,
                    getString(R.string.firestore_field_title) to storyTitle,
                    getString(R.string.firestore_field_text) to storyText.takeIf { it.isNotBlank() }, // Guardar texto solo si no está vacío
                    getString(R.string.firestore_field_type) to getString(R.string.content_type_story), // Tipo de contenido
                    getString(R.string.firestore_field_storyType) to storyTypeSelected,
                    getString(R.string.firestore_field_location) to location,
                    getString(R.string.firestore_field_date) to dateData, // Mapa de datos de fecha
                    getString(R.string.firestore_field_timestamp) to FieldValue.serverTimestamp(),
                    getString(R.string.firestore_field_status) to getString(R.string.status_pending_value), // Estado inicial
                    getString(R.string.firestore_field_isVisible) to false, // No visible hasta aprobación
                    getString(R.string.firestore_field_likes) to 0,
                    getString(R.string.firestore_field_commentsCount) to 0,
                    getString(R.string.firestore_field_imageUrl) to null, // Se actualizará si hay imagen
                    getString(R.string.firestore_field_audioUrl) to null, // Se actualizará si hay audio
                    getString(R.string.firestore_field_audioOriginalName) to null, // Nombre original del audio
                    getString(R.string.firestore_field_latitude) to selectedLatitude,
                    getString(R.string.firestore_field_longitude) to selectedLongitude,
                    getString(R.string.firestore_field_cityName) to selectedCityName,
                    getString(R.string.firestore_field_moderatedBy) to null,
                    getString(R.string.firestore_field_moderationTimestamp) to null,
                    getString(R.string.firestore_field_rejectionReason) to null
                )

                // Lógica de subida secuencial: Audio -> Imagen (si existe) -> Firestore
                if (finalAudioToUploadUri != null) {
                    Log.i(TAG, getString(R.string.log_starting_cloudinary_audio_upload, finalAudioToUploadUri.toString()))
                    runOnUiThread { binding.textProgressStory.text = getString(R.string.info_audio_preparing) } // Mensaje específico
                    uploadAudioToCloudinary(finalAudioToUploadUri!!, finalAudioOriginalName, storyData) { audioUrl, originalName ->
                        storyData[getString(R.string.firestore_field_audioUrl)] = audioUrl
                        storyData[getString(R.string.firestore_field_audioOriginalName)] = originalName // Guardar nombre original
                        if (selectedImageUri != null) {
                            Log.i(TAG, getString(R.string.log_audio_uploaded_starting_optional_image_upload, selectedImageUri.toString()))
                            uploadOptionalImageToCloudinary(selectedImageUri!!, storyData) { imageUrl ->
                                storyData[getString(R.string.firestore_field_imageUrl)] = imageUrl
                                saveStoryDataToFirestore(storyData)
                            }
                        } else {
                            Log.i(TAG, getString(R.string.log_audio_uploaded_no_optional_image))
                            saveStoryDataToFirestore(storyData)
                        }
                    }
                } else if (selectedImageUri != null) { // Si no hay audio pero sí imagen
                    Log.i(TAG, getString(R.string.log_no_audio_starting_optional_image_upload, selectedImageUri.toString()))
                    uploadOptionalImageToCloudinary(selectedImageUri!!, storyData) { imageUrl ->
                        storyData[getString(R.string.firestore_field_imageUrl)] = imageUrl
                        saveStoryDataToFirestore(storyData)
                    }
                } else { // Solo texto
                    Log.i(TAG, getString(R.string.log_no_audio_no_optional_image))
                    saveStoryDataToFirestore(storyData)
                }
            }
            .addOnFailureListener { e ->
                Log.e(TAG, getString(R.string.log_error_getting_user_data_for_authorship_story), e)
                handleUploadError(getString(R.string.submission_generic_error_message_upload) + getString(R.string.error_suffix_user_data_fetch))
            }
    }


    private fun validateForm(storyText: String): Boolean {
        var isValid = true
        val storyTitle = binding.editTextStoryTitle.text.toString().trim()
        if (storyTitle.isBlank()) {
            binding.textInputLayoutStoryTitle.error = getString(R.string.error_story_title_required)
            isValid = false
        } else if (storyTitle.length > 37) { // Asumiendo que 37 es el límite
            binding.textInputLayoutStoryTitle.error = getString(R.string.error_title_length)
            isValid = false
        } else {
            binding.textInputLayoutStoryTitle.error = null
        }

        // Validar que haya texto o audio
        if (storyText.isBlank() && recordedAudioUri == null && attachedAudioUri == null) {
            showToast(getString(R.string.error_story_text_or_audio_required))
            binding.tabLayoutStoryInput.getTabAt(0)?.select() // Enfocar pestaña de texto
            isValid = false
        } else if (storyText.length > 20000) { // Límite de caracteres para el texto
            showToast(getString(R.string.error_story_text_too_long, 20000))
            binding.tabLayoutStoryInput.getTabAt(0)?.select() // Enfocar pestaña de texto
            isValid = false
        }


        if (binding.spinnerStoryType.selectedItemPosition == 0) { // "Seleccione un tipo"
            showToast(getString(R.string.error_story_type_required))
            isValid = false
        } else if (binding.spinnerStoryType.selectedItem.toString() == getString(R.string.story_type_other)) {
            if (binding.editTextOtherStoryType.text.toString().trim().isBlank()) {
                binding.textInputLayoutOtherStoryType.error = getString(R.string.error_other_story_type_required)
                isValid = false
            } else {
                binding.textInputLayoutOtherStoryType.error = null
            }
        }

        if (binding.spinnerLocation.selectedItemPosition == 0) { // "Seleccione una ubicación"
            showToast(getString(R.string.error_location_required))
            isValid = false
        }

        if (!validateDateSelection()) isValid = false

        if (binding.switchCoordinates.isChecked && (selectedLatitude == null || selectedLongitude == null)) {
            showToast(getString(R.string.error_select_coordinates_on_map))
            isValid = false
        }
        return isValid
    }

    private fun validateDateSelection(): Boolean {
        var dateValid = true
        clearDateErrors() // Limpiar errores previos
        val checkedId = binding.radioGroupDateType.checkedRadioButtonId

        // Si no se ha seleccionado ningún tipo de fecha Y "Desconocido" no está marcado
        if (checkedId == -1 && !binding.radioUnknown.isChecked) {
            binding.textDateMessageStory.text = getString(R.string.error_select_date_type_or_unknown)
            binding.textDateMessageStory.isVisible = true
            return false // No es válido si no se selecciona nada
        }
        // Si "Desconocido" está marcado, es válido
        if (binding.radioUnknown.isChecked) return true

        // Validaciones para los tipos de fecha específicos
        val currentYear = Calendar.getInstance().get(Calendar.YEAR)
        val minDateCalStory = Calendar.getInstance().apply { set(MIN_YEAR_STORY, Calendar.JANUARY, 1,0,0,0) } // Para comparación


        when (checkedId) {
            R.id.radioYear -> {
                val yearStr = binding.editTextYear.text.toString()
                val year = yearStr.toIntOrNull()
                if (yearStr.isEmpty() || year == null || year < MIN_YEAR_STORY || year > currentYear) {
                    binding.textInputLayoutYear.error = getString(R.string.error_invalid_year_range_simple, MIN_YEAR_STORY, currentYear)
                    dateValid = false
                }
            }
            R.id.radioExactDate -> {
                val dateStr = binding.editTextExactDate.text.toString()
                if (dateStr.isEmpty()) {
                    binding.textInputLayoutExactDate.error = getString(R.string.error_select_exact_date)
                    dateValid = false
                } else {
                    try {
                        val date = dateFormatStory.parse(dateStr) // dateFormatStory ya es lenient = false
                        val selectedCal = Calendar.getInstance().apply { time = date!! }
                        // Normalizar horas, minutos, segundos para comparación justa de fechas
                        selectedCal.set(Calendar.HOUR_OF_DAY, 0); selectedCal.set(Calendar.MINUTE, 0); selectedCal.set(Calendar.SECOND, 0); selectedCal.set(Calendar.MILLISECOND, 0)
                        val todayCal = Calendar.getInstance().apply {set(Calendar.HOUR_OF_DAY, 0); set(Calendar.MINUTE, 0); set(Calendar.SECOND, 0); set(Calendar.MILLISECOND, 0) }

                        if (selectedCal.before(minDateCalStory) || selectedCal.after(todayCal)) {
                            binding.textInputLayoutExactDate.error = getString(R.string.error_invalid_date_range, dateFormatStory.format(minDateCalStory.time), dateFormatStory.format(todayCal.time))
                            dateValid = false
                        }
                    } catch (e: ParseException) {
                        binding.textInputLayoutExactDate.error = getString(R.string.error_invalid_date_format)
                        dateValid = false
                    }
                }
            }
            R.id.radioDateRange -> {
                val startYearStr = binding.editTextStartYear.text.toString()
                val endYearStr = binding.editTextEndYear.text.toString()
                val startYear = startYearStr.toIntOrNull()
                val endYear = endYearStr.toIntOrNull()

                var individualYearsValid = true
                if (startYearStr.isEmpty() || startYear == null || startYear < MIN_YEAR_STORY || startYear > currentYear) {
                    binding.textInputLayoutStartYear.error = getString(R.string.error_invalid_year_range_simple, MIN_YEAR_STORY, currentYear)
                    individualYearsValid = false
                }
                if (endYearStr.isEmpty() || endYear == null || endYear < MIN_YEAR_STORY || endYear > currentYear) {
                    binding.textInputLayoutEndYear.error = getString(R.string.error_invalid_year_range_simple, MIN_YEAR_STORY, currentYear)
                    individualYearsValid = false
                }

                if (individualYearsValid && startYear != null && endYear != null && startYear > endYear) {
                    binding.textInputLayoutStartYear.error = getString(R.string.error_year_range_order)
                    binding.textInputLayoutEndYear.error = getString(R.string.error_year_range_order) // Mostrar error en ambos
                    dateValid = false
                } else if (!individualYearsValid) { // Si alguno de los años individuales no es válido
                    dateValid = false
                }
            }
        }
        if (!dateValid) { // Si alguna validación falló, mostrar mensaje general
            binding.textDateMessageStory.text = getString(R.string.error_correct_date_errors)
            binding.textDateMessageStory.isVisible = true
        }
        return dateValid
    }


    private fun getDateFromInputs(): Map<String, Any?> {
        val dateMap = mutableMapOf<String, Any?>()
        if (binding.radioUnknown.isChecked) {
            dateMap[getString(R.string.firestore_field_date_type)] = getString(R.string.date_type_value_unknown)
            dateMap[getString(R.string.firestore_field_date_value)] = getString(R.string.date_type_unknown) // Valor textual para "Desconocido"
        } else {
            when (binding.radioGroupDateType.checkedRadioButtonId) {
                R.id.radioYear -> {
                    dateMap[getString(R.string.firestore_field_date_type)] = getString(R.string.date_type_value_year)
                    dateMap[getString(R.string.firestore_field_date_value)] = binding.editTextYear.text.toString().toIntOrNull()
                }
                R.id.radioExactDate -> {
                    dateMap[getString(R.string.firestore_field_date_type)] = getString(R.string.date_type_value_exact)
                    dateMap[getString(R.string.firestore_field_date_value)] = binding.editTextExactDate.text.toString() // Guardar como String dd/MM/yyyy
                }
                R.id.radioDateRange -> {
                    dateMap[getString(R.string.firestore_field_date_type)] = getString(R.string.date_type_value_range)
                    dateMap[getString(R.string.firestore_field_date_startYear)] = binding.editTextStartYear.text.toString().toIntOrNull()
                    dateMap[getString(R.string.firestore_field_date_endYear)] = binding.editTextEndYear.text.toString().toIntOrNull()
                }
                else -> dateMap[getString(R.string.firestore_field_date_type)] = getString(R.string.date_type_value_none) // Caso por defecto
            }
        }
        return dateMap
    }


    private fun getStoryTextFromFragment(): String {
        val writeFragment = getFragmentAtIndex<WriteStoryFragment>(0) // Índice 0 para WriteStoryFragment
        return writeFragment?.getStoryText()?.trim() ?: ""
    }

    private fun uploadAudioToCloudinary(audioFileUri: Uri, originalFileName: String?, storyData: HashMap<String, Any?>, onComplete: (audioUrl: String?, originalName: String?) -> Unit) {
        runOnUiThread {
            binding.progressBarUploadStory.isIndeterminate = false // Asegurar que no sea indeterminada
            binding.progressBarUploadStory.progress = 0
            binding.textProgressStory.text = getString(R.string.uploading_audio_progress, 0)
        }

        val audioBytes = getBytesFromUri(audioFileUri) ?: run {
            Log.e(TAG, getString(R.string.log_error_getting_bytes_from_audio_uri, audioFileUri.toString()))
            handleUploadError(getString(R.string.error_audio_compression)) // Mensaje genérico de error de audio
            onComplete(null, originalFileName) // Notificar que falló
            return
        }

        // Crear un nombre de archivo más seguro para Cloudinary
        val cloudinaryFileName = originalFileName?.let {
            it.substringBeforeLast('.').replace(Regex("[^a-zA-Z0-9_-]"), "_") // Reemplazar caracteres no válidos
        } ?: getString(R.string.cloudinary_default_audio_filename_prefix) + System.currentTimeMillis()


        val options = HashMap<String, Any>().apply {
            put(getString(R.string.cloudinary_option_folder), getString(R.string.cloudinary_folder_story_audios, storyData[getString(R.string.firestore_field_userId)]))
            put(getString(R.string.cloudinary_option_resource_type), getString(R.string.cloudinary_resource_type_video)) // Cloudinary trata audios como "videos"
            put(getString(R.string.cloudinary_option_public_id), cloudinaryFileName) // Usar el nombre sanitizado

            // No es necesario especificar 'format' para tipos comunes como m4a, mp3, opus, ogg, aac.
            // Cloudinary intentará detectarlo.
        }

        currentAudioFileUploadRequestId = MediaManager.get().upload(audioBytes)
            .options(options)
            .callback(object : UploadCallback {
                override fun onStart(requestId: String?) { Log.i(TAG, getString(R.string.log_cloudinary_audio_upload_started, requestId)) }
                override fun onProgress(requestId: String?, bytes: Long, totalBytes: Long) {
                    val progress = if (totalBytes > 0) (bytes.toDouble() / totalBytes * 100).toInt() else 0
                    runOnUiThread {
                        binding.progressBarUploadStory.progress = progress
                        binding.textProgressStory.text = getString(R.string.uploading_audio_progress, progress)
                    }
                }
                override fun onSuccess(requestId: String?, resultData: MutableMap<Any?, Any?>?) {
                    currentAudioFileUploadRequestId = null
                    val url = resultData?.get(getString(R.string.cloudinary_result_secure_url)) as? String
                    Log.i(TAG, getString(R.string.log_cloudinary_audio_upload_success, url))
                    onComplete(url, originalFileName) // Pasar nombre original
                }
                override fun onError(requestId: String?, error: ErrorInfo?) {
                    currentAudioFileUploadRequestId = null
                    val errorMsg = error?.description ?: getString(R.string.error_unknown_upload)
                    Log.e(TAG, getString(R.string.log_error_cloudinary_audio_upload, requestId, errorMsg, error?.code.toString()))
                    if (error?.code == ErrorInfo.REQUEST_CANCELLED) {
                        handleUploadError(getString(R.string.upload_cancelled) + getString(R.string.error_suffix_audio_upload))
                    } else {
                        handleUploadError(getString(R.string.error_upload_audio_generic, errorMsg))
                    }
                    onComplete(null, originalFileName)
                }
                override fun onReschedule(requestId: String?, error: ErrorInfo?) {
                    currentAudioFileUploadRequestId = null
                    Log.w(TAG, getString(R.string.log_cloudinary_audio_upload_rescheduled, requestId, error?.description, error?.code.toString()))
                    handleUploadError(getString(R.string.error_upload_audio_rescheduled))
                    onComplete(null, originalFileName)
                }
            })
            .dispatch()
    }

    private fun uploadOptionalImageToCloudinary(imageUri: Uri, storyData: HashMap<String, Any?>, onComplete: (String?) -> Unit) {
        runOnUiThread { // Asegurar que se ejecuta en UI thread
            binding.textProgressStory.text = getString(R.string.uploading_image_progress_percent, 0)
            binding.progressBarUploadStory.progress = 0 // Resetear progreso para la imagen
            binding.progressBarUploadStory.isIndeterminate = false // Asegurar que no sea indeterminada
        }

        val imageBytes = compressImageToWebP(imageUri, 70, 1280) ?: run {
            Log.e(TAG, getString(R.string.log_error_compressing_optional_image_uri, imageUri.toString()))
            handleUploadError(getString(R.string.error_image_compression_failed))
            onComplete(null) // Notificar que falló
            return
        }

        val options = HashMap<String, Any>().apply {
            put(getString(R.string.cloudinary_option_folder), getString(R.string.cloudinary_folder_story_images, storyData[getString(R.string.firestore_field_userId)]))
            put(getString(R.string.cloudinary_option_public_id), getString(R.string.cloudinary_public_id_story_image_prefix) + System.currentTimeMillis() + "_" + UUID.randomUUID())
            put(getString(R.string.cloudinary_option_resource_type), getString(R.string.cloudinary_resource_type_image))
        }

        currentStoryImageUploadRequestId = MediaManager.get().upload(imageBytes)
            .options(options)
            .callback(object : UploadCallback {
                override fun onStart(requestId: String?) { Log.i(TAG, getString(R.string.log_cloudinary_optional_image_upload_started, requestId)) }
                override fun onProgress(requestId: String?, bytes: Long, totalBytes: Long) {
                    val progress = if (totalBytes > 0) (bytes.toDouble() / totalBytes * 100).toInt() else 0
                    runOnUiThread {
                        binding.progressBarUploadStory.progress = progress
                        binding.textProgressStory.text = getString(R.string.uploading_image_progress_percent, progress)
                    }
                }
                override fun onSuccess(requestId: String?, resultData: MutableMap<Any?, Any?>?) {
                    currentStoryImageUploadRequestId = null
                    val url = resultData?.get(getString(R.string.cloudinary_result_secure_url)) as? String
                    Log.i(TAG, getString(R.string.log_cloudinary_optional_image_upload_success, url))
                    onComplete(url)
                }
                override fun onError(requestId: String?, error: ErrorInfo?) {
                    currentStoryImageUploadRequestId = null
                    val errorMsg = error?.description ?: getString(R.string.error_unknown_upload)
                    Log.e(TAG, getString(R.string.log_error_cloudinary_optional_image_upload, requestId, errorMsg, error?.code.toString()))
                    if (error?.code == ErrorInfo.REQUEST_CANCELLED) {
                        handleUploadError(getString(R.string.upload_cancelled) + getString(R.string.error_suffix_story_image_upload))
                    } else {
                        handleUploadError(getString(R.string.error_upload_image_generic_story, errorMsg))
                    }
                    onComplete(null) // Notificar que falló
                }
                override fun onReschedule(requestId: String?, error: ErrorInfo?) {
                    currentStoryImageUploadRequestId = null
                    Log.w(TAG, getString(R.string.log_cloudinary_optional_image_upload_rescheduled, requestId, error?.description, error?.code.toString()))
                    handleUploadError(getString(R.string.error_upload_image_rescheduled_story))
                    onComplete(null) // Notificar que falló
                }
            })
            .dispatch()
    }


    private fun saveStoryDataToFirestore(storyData: HashMap<String, Any?>) {
        runOnUiThread { binding.textProgressStory.text = getString(R.string.uploading_content_progress) } // Mensaje "Guardando..."
        firestore.collection(getString(R.string.firestore_collection_stories_pending)).add(storyData)
            .addOnSuccessListener { documentReference ->
                Log.i(TAG, getString(R.string.log_firestore_story_data_saved, documentReference.id))
                runOnUiThread {
                    binding.uploadProgressOverlayStory.isVisible = false // Ocultar overlay

                    // Determinar mensaje de éxito basado en lo que se subió
                    val successMessage = when {
                        storyData[getString(R.string.firestore_field_audioUrl)] != null && storyData[getString(R.string.firestore_field_imageUrl)] != null -> getString(R.string.submission_success_story_audio_image_sent)
                        storyData[getString(R.string.firestore_field_audioUrl)] != null -> getString(R.string.submission_success_story_audio_sent)
                        storyData[getString(R.string.firestore_field_imageUrl)] != null -> getString(R.string.submission_success_story_image_sent)
                        else -> getString(R.string.submission_success_message_story) // Solo texto
                    }

                    showSubmissionConfirmationDialog(
                        getString(R.string.submission_success_title_story),
                        successMessage
                    )
                }
            }
            .addOnFailureListener { e ->
                Log.e(TAG, getString(R.string.log_error_firestore_saving_story_data), e)
                handleUploadError(getString(R.string.save_story_error_message, e.localizedMessage) + getString(R.string.error_suffix_firestore_save_story))
            }
    }

    private fun handleUploadError(errorMessage: String) {
        Log.e(TAG, getString(R.string.log_handling_upload_error_story, errorMessage))
        currentStoryImageUploadRequestId = null // Limpiar IDs
        currentAudioFileUploadRequestId = null
        runOnUiThread {
            binding.uploadProgressOverlayStory.isVisible = false
            showAlertDialog(getString(R.string.error_dialog_title), getString(R.string.upload_error_prefix, errorMessage))
            setUiEnabled(true) // Reactivar UI
            isSubmitting = false
        }
    }

    private fun showSubmissionConfirmationDialog(title: String, message: String) {
        if (isFinishing || isDestroyed) {
            Log.w(TAG, getString(R.string.log_activity_finishing_dialog_not_shown_story))
            return
        }
        AlertDialog.Builder(this)
            .setTitle(title)
            .setMessage(message)
            .setPositiveButton(R.string.dialog_positive_button_understood) { _, _ ->
                finish()
            }
            .setCancelable(false) // No permitir cancelar el diálogo con back button
            .show()
    }


    private fun setUiEnabled(enabled: Boolean) {
        binding.btnEnviarRelato.isEnabled = enabled
        binding.btnBorrarTodo.isEnabled = enabled
        binding.editTextStoryTitle.isEnabled = enabled

        // Habilitar/deshabilitar interacción con las pestañas
        for (i in 0 until binding.tabLayoutStoryInput.tabCount) {
            val tabView = (binding.tabLayoutStoryInput.getTabAt(i)?.view)
            tabView?.isClickable = enabled
            tabView?.alpha = if (enabled) 1.0f else 0.5f // Efecto visual de deshabilitado
        }
        binding.viewPagerStoryInput.isUserInputEnabled = enabled // Deshabilitar swipe entre pestañas


        binding.spinnerStoryType.isEnabled = enabled
        binding.editTextOtherStoryType.isEnabled = enabled && binding.textInputLayoutOtherStoryType.isVisible
        binding.spinnerLocation.isEnabled = enabled
        binding.btnSelectImageStory.isEnabled = enabled

        binding.radioGroupDateType.isEnabled = enabled
        for (i in 0 until binding.radioGroupDateType.childCount) {
            binding.radioGroupDateType.getChildAt(i).isEnabled = enabled
        }
        binding.radioUnknown.isEnabled = enabled

        binding.editTextYear.isEnabled = enabled && binding.textInputLayoutYear.isVisible
        binding.editTextExactDate.isEnabled = enabled && binding.textInputLayoutExactDate.isVisible
        binding.editTextStartYear.isEnabled = enabled && binding.dateRangeLayout.isVisible
        binding.editTextEndYear.isEnabled = enabled && binding.dateRangeLayout.isVisible
        binding.infoIconDate.isEnabled = enabled

        binding.switchCoordinates.isEnabled = enabled
        binding.textViewSelectCoordinates.isEnabled = enabled && binding.mapSelectionContainer.isVisible && binding.textViewSelectCoordinates.isVisible
        binding.btnEditCoordinates.isEnabled = enabled && binding.mapSelectionContainer.isVisible && binding.btnEditCoordinates.isVisible
    }

    private fun resizeBitmapKeepingAspectRatio(bitmap: Bitmap, maxSideLength: Int): Bitmap {
        val currentWidth = bitmap.width
        val currentHeight = bitmap.height

        if (currentWidth <= maxSideLength && currentHeight <= maxSideLength) {
            return bitmap
        }

        val ratio = currentWidth.toFloat() / currentHeight.toFloat()
        var newWidth: Int
        var newHeight: Int

        if (currentWidth > currentHeight) {
            newWidth = maxSideLength
            newHeight = (maxSideLength / ratio).roundToInt()
        } else {
            newHeight = maxSideLength
            newWidth = (maxSideLength * ratio).roundToInt()
        }

        // Asegurar que las nuevas dimensiones no sean cero
        if (newWidth <= 0) newWidth = 1
        if (newHeight <= 0) newHeight = 1

        return bitmap.scale(newWidth, newHeight, true)
    }

    private fun compressImageToWebP(uri: Uri, quality: Int, maxSideLength: Int): ByteArray? {
        var inputStream: InputStream? = null
        var exifInputStream: InputStream? = null
        try {
            inputStream = contentResolver.openInputStream(uri) ?: throw FileNotFoundException(getString(R.string.error_inputstream_null_for_uri_compress, uri.toString()))
            val originalBitmap = BitmapFactory.decodeStream(inputStream)
                ?: throw IOException(getString(R.string.error_failed_decode_bitmap_from_uri_compress, uri.toString()))

            exifInputStream = contentResolver.openInputStream(uri) ?: throw FileNotFoundException(getString(R.string.error_exif_inputstream_null_for_uri_compress, uri.toString()))
            val exif = ExifInterface(exifInputStream)
            val orientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL)

            val matrix = Matrix()
            when (orientation) {
                ExifInterface.ORIENTATION_ROTATE_90 -> matrix.postRotate(90f)
                ExifInterface.ORIENTATION_ROTATE_180 -> matrix.postRotate(180f)
                ExifInterface.ORIENTATION_ROTATE_270 -> matrix.postRotate(270f)
                ExifInterface.ORIENTATION_FLIP_HORIZONTAL -> matrix.postScale(-1f, 1f)
                ExifInterface.ORIENTATION_FLIP_VERTICAL -> matrix.postScale(1f, -1f)
                ExifInterface.ORIENTATION_TRANSPOSE -> { matrix.postRotate(90f); matrix.postScale(-1f, 1f) }
                ExifInterface.ORIENTATION_TRANSVERSE -> { matrix.postRotate(-90f); matrix.postScale(-1f, 1f) }
            }
            val rotatedBitmap = Bitmap.createBitmap(originalBitmap, 0, 0, originalBitmap.width, originalBitmap.height, matrix, true)
            if (originalBitmap != rotatedBitmap) { // Solo reciclar si se creó un nuevo bitmap
                originalBitmap.recycle()
            }

            val resizedBitmap = resizeBitmapKeepingAspectRatio(rotatedBitmap, maxSideLength)
            if (rotatedBitmap != resizedBitmap) { // Solo reciclar si se creó un nuevo bitmap
                rotatedBitmap.recycle()
            }

            ByteArrayOutputStream().use { outputStream ->
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
                    resizedBitmap.compress(Bitmap.CompressFormat.WEBP_LOSSY, quality, outputStream)
                } else {
                    @Suppress("DEPRECATION") // WEBP_LOSSY es preferido en R+, pero WEBP es la opción para < R
                    resizedBitmap.compress(Bitmap.CompressFormat.WEBP, quality, outputStream)
                }
                resizedBitmap.recycle() // Reciclar el bitmap final
                return outputStream.toByteArray()
            }

        } catch (fnfe: FileNotFoundException) {
            Log.e(TAG, getString(R.string.log_error_file_not_found_compress_webp_story, uri.toString()), fnfe)
            showToast(getString(R.string.error_file_not_found_for_compression, uri.lastPathSegment ?: getString(R.string.selected_image_default_name)))
            return null
        } catch (ioe: IOException) {
            Log.e(TAG, getString(R.string.log_error_io_compress_webp_story, uri.toString()), ioe)
            showToast(getString(R.string.error_io_compressing_image))
            return null
        } catch (e: Exception) { // Captura más genérica para otros errores
            Log.e(TAG, getString(R.string.log_error_unexpected_compress_webp_story, uri.toString()), e)
            showToast(getString(R.string.error_unknown_compressing_image))
            return null
        } finally {
            try {
                inputStream?.close()
                exifInputStream?.close()
            } catch (ioe: IOException) {
                Log.e(TAG, getString(R.string.log_error_closing_streams_compress_webp_uri_story, uri.toString()), ioe)
            }
        }
    }


    private fun getBytesFromUri(uri: Uri): ByteArray? {
        try {
            return contentResolver.openInputStream(uri)?.use { it.readBytes() }
        } catch (fnfe: FileNotFoundException) {
            Log.e(TAG, getString(R.string.log_error_file_not_found_get_bytes, uri.toString()), fnfe)
            showToast(getString(R.string.error_file_not_found_for_compression, uri.lastPathSegment ?: getString(R.string.default_file_name)))
            return null
        } catch (ioe: IOException) {
            Log.e(TAG, getString(R.string.log_error_io_get_bytes, uri.toString()), ioe)
            showToast(getString(R.string.error_io_compressing_image)) // Reutilizar si es genérico
            return null
        } catch (e: SecurityException) { // Añadir manejo de SecurityException
            Log.e(TAG, getString(R.string.log_security_exception_get_bytes, uri.toString()), e)
            showToast(getString(R.string.error_accessing_file_permission, uri.lastPathSegment ?: getString(R.string.default_file_name)))
            return null
        }
        catch (e: Exception) { // Captura genérica para otros errores
            Log.e(TAG, getString(R.string.log_unexpected_error_get_bytes, uri.toString()), e)
            showToast(getString(R.string.upload_file_error_message, e.localizedMessage ?: getString(R.string.unknown_error)))
            return null
        }
    }

    // --- Implementación de AudioRecordListener ---
    override fun onAudioRecorded(uri: Uri?, originalFileName: String?) {
        Log.i(TAG, getString(R.string.log_audio_recorded_received, uri.toString(), originalFileName))
        recordedAudioUri = uri
        recordedAudioOriginalName = originalFileName
        if (uri != null) { // Si se grabó un audio, limpiar el adjunto
            attachedAudioUri = null
            attachedAudioOriginalName = null
            getFragmentAtIndex<AttachAudioFragment>(2)?.resetState() // Notificar al fragmento de adjuntar
            Log.d(TAG, getString(R.string.log_attached_audio_reset_due_to_new_recording))
        }
        updateAudioWarningVisibility()
    }

    override fun onRecordingStateChanged(isRecording: Boolean) {
        Log.i(TAG, getString(R.string.log_recording_state_changed, isRecording.toString()))
        val attachAudioTab = binding.tabLayoutStoryInput.getTabAt(2) // Pestaña de Adjuntar Audio
        val writeStoryTab = binding.tabLayoutStoryInput.getTabAt(0) // Pestaña de Escribir Relato

        if (isRecording) {
            // Si se empieza a grabar, limpiar cualquier audio adjunto
            attachedAudioUri = null
            attachedAudioOriginalName = null
            getFragmentAtIndex<AttachAudioFragment>(2)?.resetState() // Notificar al fragmento de adjuntar
            Log.d(TAG, getString(R.string.log_attached_audio_reset_recording_started))

            // Deshabilitar otras pestañas durante la grabación
            attachAudioTab?.view?.isClickable = false
            attachAudioTab?.view?.alpha = 0.5f
            writeStoryTab?.view?.isClickable = false
            writeStoryTab?.view?.alpha = 0.5f
        } else {
            // Habilitar pestañas cuando la grabación no está activa
            attachAudioTab?.view?.isClickable = true
            attachAudioTab?.view?.alpha = 1.0f
            writeStoryTab?.view?.isClickable = true
            writeStoryTab?.view?.alpha = 1.0f
        }
        updateAudioWarningVisibility()
    }
    override fun onAudioDeleted() { // Desde RecordAudioFragment
        Log.i(TAG, getString(R.string.log_recorded_audio_deleted_from_fragment))
        recordedAudioUri = null
        recordedAudioOriginalName = null
        updateAudioWarningVisibility()
    }

    // --- Implementación de AudioAttachListener ---
    override fun onAudioAttached(uri: Uri?, originalFileName: String?) {
        Log.i(TAG, getString(R.string.log_audio_attached_received, uri.toString(), originalFileName))
        attachedAudioUri = uri
        attachedAudioOriginalName = originalFileName
        if (uri != null) { // Si se adjuntó un audio, limpiar el grabado
            recordedAudioUri = null
            recordedAudioOriginalName = null
            getFragmentAtIndex<RecordAudioFragment>(1)?.resetState() // Notificar al fragmento de grabar
            Log.d(TAG, getString(R.string.log_recorded_audio_reset_due_to_new_attachment))
        }
        updateAudioWarningVisibility()
    }
    override fun onAttachedAudioDeleted() { // Desde AttachAudioFragment
        Log.i(TAG, getString(R.string.log_attached_audio_deleted_from_fragment))
        attachedAudioUri = null
        attachedAudioOriginalName = null
        updateAudioWarningVisibility()
    }

    private fun updateAudioWarningVisibility() {
        val recordTab = binding.tabLayoutStoryInput.getTabAt(1) // Pestaña Grabar
        val attachTab = binding.tabLayoutStoryInput.getTabAt(2) // Pestaña Adjuntar

        val isCurrentlyRecording = getFragmentAtIndex<RecordAudioFragment>(1)?.isRecording ?: false

        if (isCurrentlyRecording) {
            binding.tvAudioSelectionWarning.text = getString(R.string.warning_recording_in_progress)
            binding.tvAudioSelectionWarning.isVisible = true
            attachTab?.view?.isClickable = false // Deshabilitar adjuntar mientras se graba
            attachTab?.view?.alpha = 0.5f
        } else if (recordedAudioUri != null) { // Hay un audio grabado, pero no se está grabando activamente
            binding.tvAudioSelectionWarning.text = getString(R.string.warning_recorded_audio_active)
            binding.tvAudioSelectionWarning.isVisible = true
            attachTab?.view?.isClickable = false // Deshabilitar adjuntar si hay audio grabado
            attachTab?.view?.alpha = 0.5f
            recordTab?.view?.isClickable = true // Permitir interactuar con la pestaña de grabación (para eliminarlo, etc.)
            recordTab?.view?.alpha = 1.0f
        } else if (attachedAudioUri != null) { // Hay un audio adjunto
            binding.tvAudioSelectionWarning.text = getString(R.string.warning_attached_audio_active)
            binding.tvAudioSelectionWarning.isVisible = true
            recordTab?.view?.isClickable = false // Deshabilitar grabar si hay audio adjunto
            recordTab?.view?.alpha = 0.5f
            attachTab?.view?.isClickable = true // Permitir interactuar con la pestaña de adjuntar
            attachTab?.view?.alpha = 1.0f
        } else { // No hay audio grabado ni adjunto, ni se está grabando
            binding.tvAudioSelectionWarning.isVisible = false
            recordTab?.view?.isClickable = true
            recordTab?.view?.alpha = 1.0f
            attachTab?.view?.isClickable = true
            attachTab?.view?.alpha = 1.0f
        }
        Log.d(TAG, getString(R.string.log_audio_warning_visibility_updated, isCurrentlyRecording.toString(), recordedAudioUri.toString(), attachedAudioUri.toString()))
    }

    // Helper para obtener fragmentos del ViewPager2
    internal inline fun <reified T : Fragment> getFragmentAtIndex(index: Int): T? {
        // El ViewPager2 crea fragmentos con un tag "f" + índice.
        val fragmentByTag = supportFragmentManager.findFragmentByTag("f$index")
        return if (fragmentByTag is T) {
            fragmentByTag
        } else {
            // Registrar si el fragmento no es del tipo esperado o no se encuentra
            if (fragmentByTag != null) {
                Log.e(TAG, getString(R.string.log_error_fragment_type_mismatch, index.toString(), T::class.java.simpleName, fragmentByTag.javaClass.simpleName))
            } else {
                Log.w(TAG, getString(R.string.log_warning_fragment_not_found_by_tag, index.toString(), "f$index"))
            }
            null
        }
    }

    // Definición de showAlertDialog para esta actividad (si no está ya en una clase base o helper)
    private fun showAlertDialog(title: String, message: String) {
        if (isFinishing || isDestroyed) { // Evitar mostrar diálogo si la actividad está finalizando
            Log.w(TAG, getString(R.string.log_activity_finishing_dialog_not_shown_story_alert))
            return
        }
        AlertDialog.Builder(this)
            .setTitle(title)
            .setMessage(message)
            .setPositiveButton(getString(R.string.dialog_ok), null) // Usar string resource
            .show()
    }
}
