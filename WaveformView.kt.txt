package com.example.mexicoparanormal

import android.annotation.SuppressLint
import android.content.Context
import android.graphics.Canvas
// import android.graphics.Color // Ya no es necesario para parseColor
import android.graphics.Paint
import android.graphics.Path
import android.util.AttributeSet
import android.util.Log
import android.view.MotionEvent
import android.view.View
import androidx.core.content.ContextCompat // Import para ContextCompat
import java.util.LinkedList
import kotlin.math.max

class WaveformView @JvmOverloads constructor(
    context: Context, // [cite: 1159]
    attrs: AttributeSet? = null,
    defStyleAttr: Int = 0
) : View(context, attrs, defStyleAttr) {

    // --- Listener para interacción ---
    interface OnWaveformInteractionListener {
        fun onWaveformSeek(progressRatio: Float)
    }
    var onWaveformInteractionListener: OnWaveformInteractionListener? = null

    // --- Colores Personalizables (cargados desde resources) ---
    private var waveColor: Int
    private var waveformBackgroundColor: Int // Renombrado para evitar conflicto con View.getBackgroundColor()
    private var gridColor: Int
    private var indicatorColor: Int
    private var centerLineGridColor: Int // [cite: 1160]

    // --- Paints ---
    private val wavePaint = Paint().apply {
        // el color se establecerá en init
        style = Paint.Style.FILL
        isAntiAlias = true
    }

    private val gridPaint = Paint().apply {
        // el color se establecerá en init
        strokeWidth = dpToPx(0.5f)
        isAntiAlias = true
    } // [cite: 1161]

    private val centerLineGridPaint = Paint().apply {
        // el color se establecerá en init
        strokeWidth = dpToPx(0.75f) // Línea central ligeramente más gruesa
        isAntiAlias = true
    }

    private val indicatorPaint = Paint().apply {
        // el color se establecerá en init
        strokeWidth = dpToPx(1.5f) // Indicador más visible
        isAntiAlias = true
    }

    private val amplitudes = LinkedList<Float>() // Normalizadas 0.0f a 1.0f // [cite: 1162]
    private var maxDisplayablePoints = WAVEFORM_SAMPLES_CONST // MODIFICACIÓN: Inicializar directamente
    // maxReportableAmplitude ya no se usa aquí para normalizar, se hace antes.
    // private val maxReportableAmplitude = 32767f

    private var currentPlaybackProgressRatio: Float? = null // Rango de 0.0f a 1.0f

    // --- Para la cuadrícula ---
    private val gridLinesHorizontal = 4 // Número de líneas internas horizontales (resulta en 5 secciones)
    private val gridLinesVertical = 10  // Número de líneas internas verticales (resulta en 11 secciones)

    companion object { // [cite: 1163]
        private const val TAG = "WaveformView" // Etiqueta para logs
        const val WAVEFORM_SAMPLES_CONST = 100 // Número de puntos/muestras a mostrar en la forma de onda
    }

    init {
        // Cargar colores desde resources
        waveColor = ContextCompat.getColor(context, R.color.waveform_wave_color)
        waveformBackgroundColor = ContextCompat.getColor(context, R.color.waveform_background_color)
        gridColor = ContextCompat.getColor(context, R.color.waveform_grid_color)
        indicatorColor = ContextCompat.getColor(context, R.color.waveform_indicator_color) // [cite: 1164]
        centerLineGridColor = ContextCompat.getColor(context, R.color.waveform_center_line_grid_color)

        // Asignar colores a los Paints
        wavePaint.color = waveColor
        gridPaint.color = gridColor
        centerLineGridPaint.color = centerLineGridColor
        indicatorPaint.color = indicatorColor

        setupTouchListener()
        contentDescription = context.getString(R.string.cd_waveform_visualizer) // Descripción de contenido por defecto
    }

    private fun dpToPx(dp: Float): Float {
        return dp * resources.displayMetrics.density // [cite: 1165]
    }

    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {
        super.onSizeChanged(w, h, oldw, oldh)
        // maxDisplayablePoints ya está inicializado con WAVEFORM_SAMPLES_CONST.
        // Si se quisiera que dependa del ancho, aquí se calcularía.
        Log.d(TAG, context.getString(R.string.log_waveform_size_changed, w, h, maxDisplayablePoints))
    }

    /**
     * Añade una nueva amplitud cruda (de MediaRecorder.maxAmplitude) a la forma de onda.
     * La amplitud se normaliza y se añade a la lista. Si la lista excede // [cite: 1166]
     * `maxDisplayablePoints`, se elimina el punto más antiguo.
     * @param rawAmplitude La amplitud cruda (ej. de MediaRecorder).
     */
    fun addAmplitude(rawAmplitude: Int) {
        // Normalizar la amplitud a un rango de 0.0f a 1.0f usando el valor máximo teórico de un Short.
        // Esto es para la grabación en tiempo real. Para archivos adjuntos, la normalización ya se hizo.
        val maxTheoreticalAmplitude = 32767f
        val normalizedAmplitude = (rawAmplitude.toFloat().coerceIn(0f, maxTheoreticalAmplitude)) / maxTheoreticalAmplitude
        synchronized(amplitudes) { // [cite: 1167]
            amplitudes.add(normalizedAmplitude)
            // Mantener solo el número máximo de puntos visibles
            if (amplitudes.size > maxDisplayablePoints && maxDisplayablePoints > 0) {
                amplitudes.removeFirst()
            }
        }
        postInvalidate() // Solicitar redibujado
    }

    /** // [cite: 1168]
     * Establece los datos completos de la forma de onda a partir de una lista de amplitudes ya normalizadas.
     * Se espera que la lista ya esté submuestreada/interpolada al número correcto de puntos (maxDisplayablePoints).
     * @param normalizedAmplitudes Lista de amplitudes normalizadas (0.0f a 1.0f).
     */
    fun setWaveformData(normalizedAmplitudes: List<Float>) {
        if (maxDisplayablePoints <= 0) { // Esta condición ahora será menos probable que sea true
            Log.w(TAG, context.getString(R.string.log_waveform_setdata_empty_or_no_points) + " (maxDisplayablePoints es $maxDisplayablePoints)")
            synchronized(amplitudes) {
                amplitudes.clear() // [cite: 1169]
            }
            currentPlaybackProgressRatio = null
            postInvalidate()
            return
        }

        synchronized(amplitudes) {
            amplitudes.clear()
            if (normalizedAmplitudes.isNotEmpty()) {
                // Simplemente toma los primeros 'maxDisplayablePoints' o todos si son menos.
                // Se asume que normalizedAmplitudes ya tiene el tamaño correcto o cercano.
                amplitudes.addAll(normalizedAmplitudes.take(maxDisplayablePoints)) // [cite: 1170]
            }
        }

        // Si después de tomar los puntos, aún no llegamos a maxDisplayablePoints (porque la lista de entrada era más corta),
        // y tenemos al menos un punto, rellenamos con el último valor.
        // Esto es más un fallback, idealmente normalizedAmplitudes ya tiene WAVEFORM_SAMPLES_CONST elementos. // [cite: 1171]
        if (amplitudes.isNotEmpty() && amplitudes.size < maxDisplayablePoints) {
            val lastVal = amplitudes.last()
            while(amplitudes.size < maxDisplayablePoints) {
                amplitudes.add(lastVal)
            }
        }


        currentPlaybackProgressRatio = if (amplitudes.isNotEmpty()) 0f else null // Resetear indicador al inicio si hay datos // [cite: 1172]
        Log.d(TAG, context.getString(R.string.log_waveform_setdata_processed, amplitudes.size))
        postInvalidate()
    }


    /**
     * Actualiza la posición del indicador de reproducción.
     * @param currentPositionMillis Posición actual de reproducción en milisegundos.
     * @param totalDurationMillis Duración total del audio en milisegundos.
     */
    fun updatePlaybackIndicator(currentPositionMillis: Long, totalDurationMillis: Long) {
        if (totalDurationMillis > 0) {
            currentPlaybackProgressRatio = (currentPositionMillis.toFloat() / totalDurationMillis).coerceIn(0f, 1f)
        } else {
            currentPlaybackProgressRatio = 0f // O null si se prefiere no mostrarlo si no hay duración // [cite: 1173]
        }
        postInvalidate()
    }

    /**
     * Limpia la forma de onda y el indicador de reproducción.
     */
    fun clearWaveform() {
        synchronized(amplitudes) {
            amplitudes.clear()
        }
        currentPlaybackProgressRatio = null // [cite: 1174]
        postInvalidate()
        Log.d(TAG, context.getString(R.string.log_waveform_cleared))
    }

    @SuppressLint("ClickableViewAccessibility")
    private fun setupTouchListener() {
        setOnTouchListener { _, event ->
            when (event.action) {
                MotionEvent.ACTION_DOWN, MotionEvent.ACTION_MOVE -> {
                    if (width > 0) { // Asegurar que la vista tiene ancho // [cite: 1175]
                        val progressRatio = (event.x / width.toFloat()).coerceIn(0f, 1f)
                        onWaveformInteractionListener?.onWaveformSeek(progressRatio)
                        // Actualizar el indicador visualmente de inmediato si se desea,
                        // aunque el reproductor debería hacerlo a través de updatePlaybackIndicator // [cite: 1176]
                        // currentPlaybackProgressRatio = progressRatio
                        // postInvalidate()
                    }
                    true // Consumir el evento // [cite: 1177]
                }
                else -> false // No consumir otros eventos
            }
        }
    }

    override fun onDraw(canvas: Canvas) {
        super.onDraw(canvas)
        val width = width.toFloat()
        val height = height.toFloat() // [cite: 1178]
        val centerY = height / 2f

        // 1. Dibujar fondo
        canvas.drawColor(waveformBackgroundColor)

        // 2. Dibujar cuadrícula
        // Líneas horizontales
        val horizontalStep = height / (gridLinesHorizontal + 1)
        for (i in 1..gridLinesHorizontal) {
            val y = i * horizontalStep
            canvas.drawLine(0f, y, width, y, gridPaint) // [cite: 1179]
        }
        // Línea central (más gruesa)
        canvas.drawLine(0f, centerY, width, centerY, centerLineGridPaint)

        // Líneas verticales
        val verticalStep = width / (gridLinesVertical + 1)
        for (i in 1..gridLinesVertical) {
            val x = i * verticalStep
            canvas.drawLine(x, 0f, x, height, gridPaint) // [cite: 1180]
        }

        // 3. Dibujar forma de onda
        val wavePath = Path()
        synchronized(amplitudes) {
            if (amplitudes.isNotEmpty()) {
                // Si solo hay un punto, dibuja una línea horizontal en el centro.
                // Si hay más, calcula pointWidth.
                val pointWidth = if (amplitudes.size > 1) width / (amplitudes.size - 1).toFloat() else width // [cite: 1181]

                wavePath.moveTo(0f, centerY) // Empezar en el centro a la izquierda

                // Dibujar la parte superior de la onda
                for ((index, normalizedAmplitude) in amplitudes.withIndex()) {
                    val xPos = index * pointWidth
                    // Asegurar que la amplitud normalizada esté entre 0 y 1
                    val clampedAmplitude = normalizedAmplitude.coerceIn(0f, 1f) // [cite: 1182]
                    val peakHeight = clampedAmplitude * centerY // Altura del pico basada en la amplitud normalizada
                    wavePath.lineTo(xPos, centerY - peakHeight)
                } // [cite: 1183]
                // Conectar el último punto superior al centro a la derecha
                wavePath.lineTo(width, centerY)

                // Dibujar la parte inferior de la onda (en reversa para cerrar el path)
                for (index in (amplitudes.size - 1) downTo 0) { // [cite: 1184]
                    val xPos = index * pointWidth
                    val normalizedAmplitude = amplitudes[index]
                    val clampedAmplitude = normalizedAmplitude.coerceIn(0f, 1f)
                    val peakHeight = clampedAmplitude * centerY
                    wavePath.lineTo(xPos, centerY + peakHeight) // [cite: 1185]
                }
                wavePath.close() // Cerrar el path para rellenar
                canvas.drawPath(wavePath, wavePaint)
            }
        }

        // 4. Dibujar indicador de reproducción
        currentPlaybackProgressRatio?.let { ratio -> // [cite: 1186]
            val indicatorX = ratio * width
            canvas.drawLine(indicatorX, 0f, indicatorX, height, indicatorPaint)
        }
    }
}